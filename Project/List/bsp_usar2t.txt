; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\bsp_usar2t.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\bsp_usar2t.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\BSP_USART2 -IC:\Users\Administrator\Desktop\FreeRTOS工程摸板V2.0.0\Project\RTE -IF:\keil5-22\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -IF:\keil5-22\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\bsp_usar2t.crf ..\BSP\BSP_USART2\BSP_USAR2T.C]
                          THUMB

                          AREA ||i.BSP_USART2_Init||, CODE, READONLY, ALIGN=2

                  BSP_USART2_Init PROC
;;;63     
;;;64      void BSP_USART2_Init(void)
000000  b500              PUSH     {lr}
;;;65     {
000002  b087              SUB      sp,sp,#0x1c
;;;66     		GPIO_InitTypeDef GPIO_InitStructure;
;;;67     		USART_InitTypeDef USART_InitStructure;
;;;68     	
;;;69     #if USART2_Rx_INT_ENABLE
;;;70     		NVIC_InitTypeDef NVIC_InitStructure;
;;;71     #endif	 
;;;72     		RCC_APB2PeriphClockCmd(RCC_APB1Periph_USART2|USART2_GPIO_CLK, ENABLE);	//使能USART2,USART2_GPIO时钟
000004  2101              MOVS     r1,#1
000006  482d              LDR      r0,|L1.188|
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;73     
;;;74     #if USART2_PinRemap
;;;75     		GPIO_PinRemapConfig(GPIO_Remap_USART2,ENABLE); //开启串口1重映射时钟
;;;76     #endif
;;;77     		USART_DeInit(USART2);  //复位串口1
00000c  482c              LDR      r0,|L1.192|
00000e  f7fffffe          BL       USART_DeInit
;;;78     //USART2_TX   PA.9 PB.6
;;;79     		GPIO_InitStructure.GPIO_Pin = USART2_PIN_Tx; //PA.9
000012  2004              MOVS     r0,#4
000014  f8ad0018          STRH     r0,[sp,#0x18]
;;;80     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d001a          STRB     r0,[sp,#0x1a]
;;;81     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00001e  2018              MOVS     r0,#0x18
000020  f88d001b          STRB     r0,[sp,#0x1b]
;;;82     		GPIO_Init(USART2_GPIO, &GPIO_InitStructure); //初始化PA9
000024  a906              ADD      r1,sp,#0x18
000026  4827              LDR      r0,|L1.196|
000028  f7fffffe          BL       GPIO_Init
;;;83     //USART2_RX	  PA.10 PB.7
;;;84     		GPIO_InitStructure.GPIO_Pin = USART2_PIN_Rx;
00002c  2008              MOVS     r0,#8
00002e  f8ad0018          STRH     r0,[sp,#0x18]
;;;85     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000032  2004              MOVS     r0,#4
000034  f88d001b          STRB     r0,[sp,#0x1b]
;;;86     		GPIO_Init(USART2_GPIO, &GPIO_InitStructure);  //初始化
000038  a906              ADD      r1,sp,#0x18
00003a  4822              LDR      r0,|L1.196|
00003c  f7fffffe          BL       GPIO_Init
;;;87     //USART 初始化设置
;;;88     		USART_InitStructure.USART_BaudRate = USART2_Baud_Rate;//一般设置为9600;
000040  f44f30e1          MOV      r0,#0x1c200
000044  9002              STR      r0,[sp,#8]
;;;89     		USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000046  2000              MOVS     r0,#0
000048  f8ad000c          STRH     r0,[sp,#0xc]
;;;90     		USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
00004c  f8ad000e          STRH     r0,[sp,#0xe]
;;;91     		USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
000050  f8ad0010          STRH     r0,[sp,#0x10]
;;;92     		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000054  f8ad0014          STRH     r0,[sp,#0x14]
;;;93     		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000058  200c              MOVS     r0,#0xc
00005a  f8ad0012          STRH     r0,[sp,#0x12]
;;;94     		USART_Init(USART2, &USART_InitStructure); //初始化串口
00005e  a902              ADD      r1,sp,#8
000060  4817              LDR      r0,|L1.192|
000062  f7fffffe          BL       USART_Init
;;;95     		
;;;96     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000066  2002              MOVS     r0,#2
000068  f8ad0018          STRH     r0,[sp,#0x18]
;;;97     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00006c  2010              MOVS     r0,#0x10
00006e  f88d001b          STRB     r0,[sp,#0x1b]
;;;98     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000072  2003              MOVS     r0,#3
000074  f88d001a          STRB     r0,[sp,#0x1a]
;;;99     		GPIO_Init(USART2_GPIO, &GPIO_InitStructure);  
000078  a906              ADD      r1,sp,#0x18
00007a  4812              LDR      r0,|L1.196|
00007c  f7fffffe          BL       GPIO_Init
;;;100    		PAout(1) = 1; 		//RS485接收模式
000080  2001              MOVS     r0,#1
000082  4911              LDR      r1,|L1.200|
000084  6008              STR      r0,[r1,#0]
;;;101    	
;;;102    #if USART2_Rx_INT_ENABLE	//如果使能了接收配置USART2 NVIC   
;;;103    		NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000086  2026              MOVS     r0,#0x26
000088  f88d0004          STRB     r0,[sp,#4]
;;;104    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=USART2_PreemptionPriority ;//抢占优先级0
00008c  2000              MOVS     r0,#0
00008e  f88d0005          STRB     r0,[sp,#5]
;;;105    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = USART2_ChannelSubPriority;		//子优先级3
000092  f88d0006          STRB     r0,[sp,#6]
;;;106    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000096  2001              MOVS     r0,#1
000098  f88d0007          STRB     r0,[sp,#7]
;;;107    		NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00009c  a801              ADD      r0,sp,#4
00009e  f7fffffe          BL       NVIC_Init
;;;108    		 
;;;109    		USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启中断
0000a2  2201              MOVS     r2,#1
0000a4  f2405125          MOV      r1,#0x525
0000a8  4805              LDR      r0,|L1.192|
0000aa  f7fffffe          BL       USART_ITConfig
;;;110    #endif
;;;111    		USART_Cmd(USART2, ENABLE);                    //使能串口 
0000ae  2101              MOVS     r1,#1
0000b0  4803              LDR      r0,|L1.192|
0000b2  f7fffffe          BL       USART_Cmd
;;;112    }
0000b6  b007              ADD      sp,sp,#0x1c
0000b8  bd00              POP      {pc}
;;;113    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L1.188|
                          DCD      0x00020004
                  |L1.192|
                          DCD      0x40004400
                  |L1.196|
                          DCD      0x40010800
                  |L1.200|
                          DCD      0x42210184

                          AREA ||i.RS485SendStr||, CODE, READONLY, ALIGN=2

                  RS485SendStr PROC
;;;152    
;;;153     u8 RS485SendStr(u8 *str,u16 strlen)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;155    	u8 i = 0;
000006  2400              MOVS     r4,#0
;;;156        RS485_TX_EN = 1;
000008  2001              MOVS     r0,#1
00000a  490e              LDR      r1,|L2.68|
00000c  6008              STR      r0,[r1,#0]
;;;157    	
;;;158    	for(i=0;i<strlen;i++)
00000e  bf00              NOP      
000010  e00c              B        |L2.44|
                  |L2.18|
;;;159    	{
;;;160    		USART_SendData(USART2,*(str+i));
000012  5d29              LDRB     r1,[r5,r4]
000014  480c              LDR      r0,|L2.72|
000016  f7fffffe          BL       USART_SendData
;;;161    		/* Loop until the end of transmission */
;;;162    		while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
00001a  bf00              NOP      
                  |L2.28|
00001c  2180              MOVS     r1,#0x80
00001e  480a              LDR      r0,|L2.72|
000020  f7fffffe          BL       USART_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L2.28|
000028  1c60              ADDS     r0,r4,#1              ;158
00002a  b2c4              UXTB     r4,r0                 ;158
                  |L2.44|
00002c  42b4              CMP      r4,r6                 ;158
00002e  dbf0              BLT      |L2.18|
;;;163    	}
;;;164        vTaskDelay(1000);//延时小了最后一个字节发送不出去，最少延时一个字节的时间
000030  f44f707a          MOV      r0,#0x3e8
000034  f7fffffe          BL       vTaskDelay
;;;165    	RS485_TX_EN = 0;  
000038  2000              MOVS     r0,#0
00003a  4902              LDR      r1,|L2.68|
00003c  6008              STR      r0,[r1,#0]
;;;166    	return 1;
00003e  2001              MOVS     r0,#1
;;;167    }
000040  bd70              POP      {r4-r6,pc}
;;;168    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x42210184
                  |L2.72|
                          DCD      0x40004400

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;120    **********************************************/ 
;;;121    void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123      u8 Res;
;;;124    	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000002  f2405125          MOV      r1,#0x525
000006  4821              LDR      r0,|L3.140|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b330              CBZ      r0,|L3.92|
;;;125    	{
;;;126    		Res =USART_ReceiveData(USART2);//(USART2->DR);	//读取接收到的数据
00000e  481f              LDR      r0,|L3.140|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
;;;127    		USART_SendData(USART2, Res);
000016  4621              MOV      r1,r4
000018  481c              LDR      r0,|L3.140|
00001a  f7fffffe          BL       USART_SendData
;;;128    		if((USART2_RX_STA&0x8000)==0)//接收未完成
00001e  481c              LDR      r0,|L3.144|
000020  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
000022  f4004000          AND      r0,r0,#0x8000
000026  b9c8              CBNZ     r0,|L3.92|
;;;129    		{
;;;130    				if(USART2_RX_STA&0x4000)//接收到了0x0d
000028  4819              LDR      r0,|L3.144|
00002a  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
00002c  f4004080          AND      r0,r0,#0x4000
000030  b160              CBZ      r0,|L3.76|
;;;131    				{
;;;132    						if(Res!=0x0a)USART2_RX_STA=0;//接收错误,重新开始
000032  2c0a              CMP      r4,#0xa
000034  d003              BEQ      |L3.62|
000036  2000              MOVS     r0,#0
000038  4915              LDR      r1,|L3.144|
00003a  8008              STRH     r0,[r1,#0]
00003c  e020              B        |L3.128|
                  |L3.62|
;;;133    						else USART2_RX_STA|=0x8000;	//接收完成了 
00003e  4814              LDR      r0,|L3.144|
000040  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
000042  f4404000          ORR      r0,r0,#0x8000
000046  4912              LDR      r1,|L3.144|
000048  8008              STRH     r0,[r1,#0]
00004a  e019              B        |L3.128|
                  |L3.76|
;;;134    				}
;;;135    				else //还没收到0X0D
;;;136    				{	
;;;137    						if(Res==0x0d)USART2_RX_STA|=0x4000;
00004c  2c0d              CMP      r4,#0xd
00004e  d106              BNE      |L3.94|
000050  480f              LDR      r0,|L3.144|
000052  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
000054  f4404080          ORR      r0,r0,#0x4000
000058  490d              LDR      r1,|L3.144|
00005a  8008              STRH     r0,[r1,#0]
                  |L3.92|
00005c  e010              B        |L3.128|
                  |L3.94|
;;;138    						else
;;;139    						{
;;;140    								USART2_RX_BUF[USART2_RX_STA&0X3FFF]=Res ;
00005e  480c              LDR      r0,|L3.144|
000060  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
000062  f3c0000d          UBFX     r0,r0,#0,#14
000066  490b              LDR      r1,|L3.148|
000068  540c              STRB     r4,[r1,r0]
;;;141    								USART2_RX_STA++;
00006a  4809              LDR      r0,|L3.144|
00006c  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
00006e  1c40              ADDS     r0,r0,#1
000070  4907              LDR      r1,|L3.144|
000072  8008              STRH     r0,[r1,#0]
;;;142    								if(USART2_RX_STA>(USART2_REC_LEN-1))USART2_RX_STA=0;//接收数据错误,重新开始接收	  
000074  4608              MOV      r0,r1
000076  8800              LDRH     r0,[r0,#0]  ; USART2_RX_STA
000078  28c7              CMP      r0,#0xc7
00007a  dd01              BLE      |L3.128|
00007c  2000              MOVS     r0,#0
00007e  8008              STRH     r0,[r1,#0]
                  |L3.128|
;;;143    						}		 
;;;144    				}
;;;145    		}   	
;;;146    	}
;;;147    	USART_ClearITPendingBit(USART2, USART_IT_RXNE );
000080  f2405125          MOV      r1,#0x525
000084  4801              LDR      r0,|L3.140|
000086  f7fffffe          BL       USART_ClearITPendingBit
;;;148    }
00008a  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L3.140|
                          DCD      0x40004400
                  |L3.144|
                          DCD      USART2_RX_STA
                  |L3.148|
                          DCD      USART2_RX_BUF

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART2_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART2_RX_STA
000000  0000              DCW      0x0000

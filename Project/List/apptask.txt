; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\apptask.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\apptask.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\apptask.crf ..\User\AppTask.c]
                          THUMB

                          AREA ||i.AppObjCreate||, CODE, READONLY, ALIGN=2

                  AppObjCreate PROC
;;;575    
;;;576    void AppObjCreate (void)
000000  b510              PUSH     {r4,lr}
;;;577    {
;;;578        xQueue_RS485 = xQueueCreate(8, 50);//sizeof(uint8_t)
000002  2200              MOVS     r2,#0
000004  2132              MOVS     r1,#0x32
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       xQueueGenericCreate
00000c  4904              LDR      r1,|L1.32|
00000e  6008              STR      r0,[r1,#0]  ; xQueue_RS485
;;;579        if( xQueue_RS485 == NULL ){ /* 没有创建成功，用户可以在这里加入创建失败的处理机制 */}
;;;580    	
;;;581    	    /* 创建信号量 */  
;;;582       xSem_swch1 = xSemaphoreCreateBinary();  
000010  2203              MOVS     r2,#3
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       xQueueGenericCreate
00001a  4902              LDR      r1,|L1.36|
00001c  6008              STR      r0,[r1,#0]  ; xSem_swch1
;;;583       
;;;584       if( xSem_swch1 == NULL )  
;;;585       {  
;;;586           /* 因堆栈不足，信号量创建失败，这里进行失败处理*/  
;;;587       } 
;;;588    }
00001e  bd10              POP      {r4,pc}
;;;589    /* Private functions -----------------------------------*/
                          ENDP

                  |L1.32|
                          DCD      xQueue_RS485
                  |L1.36|
                          DCD      xSem_swch1

                          AREA ||i.vLORA_Task||, CODE, READONLY, ALIGN=2

                  vLORA_Task PROC
;;;886    extern const uint8_t Function_TEST_Msg1[27];
;;;887    static void vLORA_Task( void *pvParameters )
000000  2032              MOVS     r0,#0x32
;;;888    {   
;;;889    #if defined (SX1278_RX)
;;;890        Radio->StartRx( );   //RFLR_STATE_RX_INIT
;;;891    #elif defined (SX1278_TX)
;;;892    	vTaskDelay(50);
000002  f7fffffe          BL       vTaskDelay
;;;893    	Radio->SetTxPacket( Function_TEST_Msg1, 27 );
000006  4812              LDR      r0,|L2.80|
000008  6800              LDR      r0,[r0,#0]  ; Radio
00000a  211b              MOVS     r1,#0x1b
00000c  6902              LDR      r2,[r0,#0x10]
00000e  4811              LDR      r0,|L2.84|
000010  4790              BLX      r2
;;;894    #endif
;;;895    	{
;;;896    		static uint8_t powerState = 1;
;;;897    		
;;;898    		while(1)
000012  e01b              B        |L2.76|
                  |L2.20|
;;;899    		{	
;;;900    			if (powerState != gITASMsg.payload.power_state) {	//! power_state: 0 -> 1 will cause system reboot
000014  4810              LDR      r0,|L2.88|
000016  7b40              LDRB     r0,[r0,#0xd]
000018  4910              LDR      r1,|L2.92|
00001a  7809              LDRB     r1,[r1,#0]  ; powerState
00001c  4288              CMP      r0,r1
00001e  d009              BEQ      |L2.52|
;;;901    				powerState  = gITASMsg.payload.power_state; //初始化时为0
000020  480d              LDR      r0,|L2.88|
000022  7b40              LDRB     r0,[r0,#0xd]
000024  490d              LDR      r1,|L2.92|
000026  7008              STRB     r0,[r1,#0]
;;;902    				
;;;903    				if (powerState == 1) {
000028  4608              MOV      r0,r1
00002a  7800              LDRB     r0,[r0,#0]  ; powerState
00002c  2801              CMP      r0,#1
00002e  d101              BNE      |L2.52|
;;;904    					systemReboot();
000030  f7fffffe          BL       systemReboot
                  |L2.52|
;;;905    				}
;;;906    			}
;;;907    			parseRadioData();
000034  f7fffffe          BL       parseRadioData
;;;908    //			switch(meshMode)
;;;909    //			{
;;;910    //			case MESH_MODE_UNINIT:
;;;911    //			case MESH_MODE_IDLE:
;;;912    //				meshMode = MESH_MODE_START_MESH;
;;;913    //				break;
;;;914    //			
;;;915    //			case MESH_MODE_START_MESH:
;;;916    //				startNewMesh();
;;;917    ////				msg_ask_for_data_send(2);
;;;918    //				meshMode = MESH_MODE_MESH;
;;;919    //				break;
;;;920    
;;;921    //			case MESH_MODE_MESH:                                                                  //???
;;;922    //				if (gGetStartNewMeshAck == false) {	//! if not received ask for id msg?
;;;923    //					meshMode = MESH_MODE_START_MESH;
;;;924    //					
;;;925    //				} else if (gMeshFinished == true) {
;;;926    //					meshMode = MESH_MODE_NORMAL;		
;;;927    //				}	
;;;928    //				break;
;;;929    //			
;;;930    //			case MESH_MODE_NORMAL:
;;;931    //				checkNodesStatePeriod();
;;;932    //				askForDataPeriod();						
;;;933    //				break;
;;;934    //				
;;;935    //			case MESH_MODE_SELF_CHECK:
;;;936    //				break;
;;;937    //			
;;;938    //			case MESH_MODE_NONE:	
;;;939    //				break;
;;;940    //			}
;;;941    	//		xEventGroupSetBits(xCreatedEventGroup, TASK_BIT_MESH);//事件标志组代表状态
;;;942    			
;;;943    			PBout(3) = ~PBout(3);
000038  4809              LDR      r0,|L2.96|
00003a  6800              LDR      r0,[r0,#0]
00003c  43c0              MVNS     r0,r0
00003e  4909              LDR      r1,|L2.100|
000040  f8c1018c          STR      r0,[r1,#0x18c]
;;;944    			vTaskDelay(500);
000044  f44f70fa          MOV      r0,#0x1f4
000048  f7fffffe          BL       vTaskDelay
                  |L2.76|
00004c  e7e2              B        |L2.20|
;;;945    
;;;946    		}
;;;947    	}
;;;948    }
;;;949    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      Radio
                  |L2.84|
                          DCD      Function_TEST_Msg1
                  |L2.88|
                          DCD      gITASMsg
                  |L2.92|
                          DCD      |symbol_number.34|
                  |L2.96|
                          DCD      0x4221818c
                  |L2.100|
                          DCD      0x42218000

                          AREA ||i.vMESH_Task||, CODE, READONLY, ALIGN=2

                  vMESH_Task PROC
;;;809    **********************************************/ 
;;;810    static void vMESH_Task( void *pvParameters )
000000  2501              MOVS     r5,#1
;;;811    {   
;;;812    	static uint8_t powerState = 1;
;;;813    	uint8_t RandvVlue = 1;
;;;814    	u16 m=60,n=400;
000002  243c              MOVS     r4,#0x3c
000004  f44f76c8          MOV      r6,#0x190
;;;815    	while(1)
000008  e041              B        |L3.142|
                  |L3.10|
;;;816    	{
;;;817    		
;;;818    		
;;;819    //		if (powerState != gITASMsg.payload.power_state){	//! power_state: 0 -> 1 will cause system reboot
;;;820    //			powerState  = gITASMsg.payload.power_state;
;;;821    //			
;;;822    //			if (powerState == 1) {
;;;823    //				systemReboot();
;;;824    //			}
;;;825    //		}
;;;826    //		Lora_Handle();
;;;827    		parseRadioData();
00000a  f7fffffe          BL       parseRadioData
;;;828    
;;;829    		switch(meshMode)
00000e  4820              LDR      r0,|L3.144|
000010  7800              LDRB     r0,[r0,#0]  ; meshMode
000012  2807              CMP      r0,#7
000014  d236              BCS      |L3.132|
000016  e8dff000          TBB      [pc,r0]
00001a  0408              DCB      0x04,0x08
00001c  0c23282d          DCB      0x0c,0x23,0x28,0x2d
000020  2e00              DCB      0x2e,0x00
;;;830    		{
;;;831    		case MESH_MODE_UNINIT:
;;;832    			meshMode = MESH_MODE_IDLE;
000022  2001              MOVS     r0,#1
000024  491a              LDR      r1,|L3.144|
000026  7008              STRB     r0,[r1,#0]
;;;833    			break;
000028  e02d              B        |L3.134|
;;;834    		
;;;835    		case MESH_MODE_IDLE://空闲
;;;836    			meshMode = MESH_MODE_START_MESH;
00002a  2002              MOVS     r0,#2
00002c  4918              LDR      r1,|L3.144|
00002e  7008              STRB     r0,[r1,#0]
;;;837    			break;
000030  e029              B        |L3.134|
;;;838    	
;;;839    		case MESH_MODE_START_MESH://开始组网
;;;840    			srand(Get_Adc(ADC_Channel_10));
000032  200a              MOVS     r0,#0xa
000034  f7fffffe          BL       Get_Adc
000038  4607              MOV      r7,r0
00003a  f7fffffe          BL       srand
;;;841    			RandvVlue = rand()%(n-m+1)+m;
00003e  f7fffffe          BL       rand
000042  1b31              SUBS     r1,r6,r4
000044  1c49              ADDS     r1,r1,#1
000046  fb90f2f1          SDIV     r2,r0,r1
00004a  fb010012          MLS      r0,r1,r2,r0
00004e  4420              ADD      r0,r0,r4
000050  b2c5              UXTB     r5,r0
;;;842    			vTaskDelay(RandvVlue);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       vTaskDelay
;;;843    			meshMode = MESH_MODE_MESH;//组网
000058  2003              MOVS     r0,#3
00005a  490d              LDR      r1,|L3.144|
00005c  7008              STRB     r0,[r1,#0]
;;;844    			break;
00005e  e012              B        |L3.134|
;;;845    		
;;;846    		case MESH_MODE_MESH:
;;;847    			meshMode = taskMesh();
000060  f7fffffe          BL       taskMesh
000064  490a              LDR      r1,|L3.144|
000066  7008              STRB     r0,[r1,#0]
;;;848    //			if (gGetStartNewMeshAck == false) {//! if not received ask for id msg?
;;;849    //				meshMode = MESH_MODE_START_MESH;//开始组网
;;;850    //				
;;;851    //			} else if (gMeshFinished == true) {
;;;852    //				meshMode = MESH_MODE_NORMAL;//组网正常
;;;853    //			}	
;;;854    			break;
000068  e00d              B        |L3.134|
;;;855    		 
;;;856    		case MESH_MODE_NORMAL://组网正常
;;;857    			meshMode = taskNormalMission();
00006a  f7fffffe          BL       taskNormalMission
00006e  4908              LDR      r1,|L3.144|
000070  7008              STRB     r0,[r1,#0]
;;;858    			break;
000072  e008              B        |L3.134|
;;;859    
;;;860    		case MESH_MODE_SELF_CHECK://组网自检
;;;861    			break;
000074  e007              B        |L3.134|
;;;862    		
;;;863    		case MESH_MODE_NONE:	//非组网状态
;;;864    				if (current_node.slave_addr2 == 0) {		//! it can come out of the NONE mode and start apply for id again
000076  4807              LDR      r0,|L3.148|
000078  7940              LDRB     r0,[r0,#5]  ; current_node
00007a  b910              CBNZ     r0,|L3.130|
;;;865    				meshMode = MESH_MODE_START_MESH;
00007c  2002              MOVS     r0,#2
00007e  4904              LDR      r1,|L3.144|
000080  7008              STRB     r0,[r1,#0]
                  |L3.130|
;;;866    			}
;;;867    			break;
000082  e000              B        |L3.134|
                  |L3.132|
;;;868    			
;;;869    		default :
;;;870    				break;
000084  bf00              NOP      
                  |L3.134|
000086  bf00              NOP                            ;833
;;;871    		}
;;;872    	
;;;873    		vTaskDelay(2);
000088  2002              MOVS     r0,#2
00008a  f7fffffe          BL       vTaskDelay
                  |L3.142|
00008e  e7bc              B        |L3.10|
;;;874    //		xEventGroupSetBits(xCreatedEventGroup, TASK_BIT_MESH);
;;;875    	}
;;;876    //! can not be running into here
;;;877    //	systemReboot();
;;;878    }
;;;879    
                          ENDP

                  |L3.144|
                          DCD      meshMode
                  |L3.148|
                          DCD      current_node

                          AREA ||i.vStart_Task||, CODE, READONLY, ALIGN=2

                  vStart_Task PROC
;;;595    **********************************************/ 
;;;596    void vStart_Task( void *pvParameters )
000000  b51f              PUSH     {r0-r4,lr}
;;;597    {
;;;598    	BSP_Init();	
000002  f7fffffe          BL       BSP_Init
;;;599    	AppObjCreate ();
000006  f7fffffe          BL       AppObjCreate
;;;600    //	vTaskDelay(50);
;;;601    	while(1)
00000a  e029              B        |L4.96|
                  |L4.12|
;;;602    	{		
;;;603    		xTaskCreate( vSwitch_Task, 	//任务函数名
00000c  2000              MOVS     r0,#0
00000e  2303              MOVS     r3,#3
000010  e9cd3000          STRD     r3,r0,[sp,#0]
000014  9002              STR      r0,[sp,#8]
000016  4603              MOV      r3,r0
000018  f44f7200          MOV      r2,#0x200
00001c  a111              ADR      r1,|L4.100|
00001e  9003              STR      r0,[sp,#0xc]
000020  4814              LDR      r0,|L4.116|
000022  f7fffffe          BL       xTaskGenericCreate
;;;604    	               "vSwitch_Task",  //具有描述性的任务名
;;;605    								 Switch_Task_STACK, //内核为任务分配堆栈空间大小 usStackDepth 字
;;;606    								 NULL, 
;;;607    								 Switch_Task_PRIO, 	//任务执行的优先级
;;;608    								 NULL);	  //创建一个让LED1闪烁的任务	 
;;;609    							 
;;;610    		xTaskCreate( vTrigger_Task, 	//任务函数名
000026  2000              MOVS     r0,#0
000028  2303              MOVS     r3,#3
00002a  e9cd3000          STRD     r3,r0,[sp,#0]
00002e  9002              STR      r0,[sp,#8]
000030  4603              MOV      r3,r0
000032  f44f7200          MOV      r2,#0x200
000036  a110              ADR      r1,|L4.120|
000038  9003              STR      r0,[sp,#0xc]
00003a  4813              LDR      r0,|L4.136|
00003c  f7fffffe          BL       xTaskGenericCreate
;;;611    	               "vTrigger_Task",  //具有描述性的任务名
;;;612    								 Trigger_Task_STACK, //内核为任务分配堆栈空间大小 usStackDepth 字
;;;613    								 NULL, 
;;;614    								 Trigger_Task_PRIO, 	//任务执行的优先级
;;;615    								 NULL);		//创建一个让LED1闪烁的任务
;;;616    		
;;;617    		xTaskCreate( vMESH_Task, 	//任务函数名
000040  2000              MOVS     r0,#0
000042  2303              MOVS     r3,#3
000044  e9cd3000          STRD     r3,r0,[sp,#0]
000048  9002              STR      r0,[sp,#8]
00004a  4603              MOV      r3,r0
00004c  f44f7200          MOV      r2,#0x200
000050  a10e              ADR      r1,|L4.140|
000052  9003              STR      r0,[sp,#0xc]
000054  4810              LDR      r0,|L4.152|
000056  f7fffffe          BL       xTaskGenericCreate
;;;618    	               "vMESH_Task",  //具有描述性的任务名
;;;619    								 MESH_Task_STACK, //内核为任务分配堆栈空间大小 usStackDepth 字
;;;620    								 NULL, 
;;;621    								 MESH_Task_PRIO, 	//任务执行的优先级
;;;622    								 NULL);		//创建一个让LED1闪烁的任务
;;;623    		
;;;624    //		xTaskCreate( vLORA_Task, 	//任务函数名
;;;625    //	               "vLORA_Task",  //具有描述性的任务名
;;;626    //								 LORA_Task_STACK, //内核为任务分配堆栈空间大小 usStackDepth 字
;;;627    //								 NULL, 
;;;628    //								 LORA_Task_PRIO, 	//任务执行的优先级
;;;629    //								 NULL);		//创建一个让LED1闪烁的任务
;;;630    								 
;;;631    //		xTaskCreate( vTCP_Task, 	//任务函数名
;;;632    //	               "vTCP_Task",  //具有描述性的任务名
;;;633    //								 TCP_Task_STACK, //内核为任务分配堆栈空间大小 usStackDepth 字
;;;634    //								 NULL, 
;;;635    //								 TCP_Task_PRIO, 	//任务执行的优先级
;;;636    //								 NULL);		//创建一个让LED1闪烁的任务
;;;637    		
;;;638    		vTaskDelete( NULL );//只运行一次，删除自己
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       vTaskDelete
                  |L4.96|
000060  e7d4              B        |L4.12|
;;;639    	}
;;;640    }
;;;641    /**********************************************
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
000064  76537769          DCB      "vSwitch_Task",0
000068  7463685f
00006c  5461736b
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L4.116|
                          DCD      vSwitch_Task
                  |L4.120|
000078  76547269          DCB      "vTrigger_Task",0
00007c  67676572
000080  5f546173
000084  6b00    
000086  00                DCB      0
000087  00                DCB      0
                  |L4.136|
                          DCD      vTrigger_Task
                  |L4.140|
00008c  764d4553          DCB      "vMESH_Task",0
000090  485f5461
000094  736b00  
000097  00                DCB      0
                  |L4.152|
                          DCD      vMESH_Task

                          AREA ||i.vSwitch_Task||, CODE, READONLY, ALIGN=2

                  vSwitch_Task PROC
;;;646    **********************************************/ 
;;;647    static void vSwitch_Task( void *pvParameters )
000000  e010              B        |L5.36|
                  |L5.2|
;;;648    {
;;;649    //	u16 m=200,n=1000,x=1,y=20,RandvVlue=0;
;;;650    //	u16  adc = 0;
;;;651    //	u16  adc0 = 0;
;;;652    //	u16  adc1 = 0;
;;;653    	while(1)
;;;654    	{
;;;655    		u8 Switch_Flag ;
;;;656    //		wdgFeed();
;;;657    		
;;;658    		PCout(14) =~ PCout(14);
000002  4809              LDR      r0,|L5.40|
000004  6800              LDR      r0,[r0,#0]
000006  43c0              MVNS     r0,r0
000008  4908              LDR      r1,|L5.44|
00000a  f8c101b8          STR      r0,[r1,#0x1b8]
;;;659    //		KM_8 =~ KM_8;
;;;660    //		KM_7 =~ KM_7;
;;;661    
;;;662    //		PCout(14) =~ PCout(14);
;;;663    //		PCout(0) =~ PCout(0);
;;;664    //		PCout(1) =~ PCout(1);
;;;665    
;;;666    
;;;667    		Switch_Flag = Get_Switch_Status();
00000e  f7fffffe          BL       Get_Switch_Status
000012  4604              MOV      r4,r0
;;;668    		Get_Switch_Message(Switch_Flag);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       Get_Switch_Message
;;;669    //		PCout(14) =~ PCout(14);
;;;670    //		adc0 = Get_Adc(ADC_Channel_10); 
;;;671    //		adc1 = Get_Adc(ADC_Channel_11); 
;;;672    //		adc = adc0 + adc1;
;;;673    ////		printf("Get_Adc(ADC_Channel_10) %d \r\n",adc0);
;;;674    ////		printf("Get_Adc(ADC_Channel_11) %d \r\n",adc1);
;;;675    //		srand(adc%100);
;;;676    //		RandvVlue = rand()%(n-m+1)+m;
;;;677    //		printf("Get_Adc(ADC_Channel_10) %d : \r\n",RandvVlue);
;;;678    //		printf("Get_Adc(ADC_Channel_10) %d \r\n",Get_Adc(ADC_Channel_10));
;;;679    //		printf("current_node.slave_addr2 %d:  \r\n",current_node.slave_addr2);
;;;680    //		printf("bad_cnt %d: slave_addr2 %d   \r\n",current_node.bad_cnt,current_node.slave_addr2);
;;;681    		vTaskDelay(500);		
00001a  f44f70fa          MOV      r0,#0x1f4
00001e  f7fffffe          BL       vTaskDelay
;;;682    	}
000022  bf00              NOP      
                  |L5.36|
000024  e7ed              B        |L5.2|
;;;683    }
;;;684    /**********************************************
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x422201b8
                  |L5.44|
                          DCD      0x42220000

                          AREA ||i.vTCP_Task||, CODE, READONLY, ALIGN=2

                  vTCP_Task PROC
;;;955    **********************************************/ 
;;;956    static void vTCP_Task( void *pvParameters )
000000  e001              B        |L6.6|
                  |L6.2|
;;;957    {
;;;958    //	u8 clitest,len;
;;;959    //	Get_NetMsg();
;;;960    //	Internet_Init();
;;;961    //	printf("w5500initok \n");
;;;962    	while(W5500_Check_Link())  //没有插入网线
;;;963    	{
;;;964    		Internet_Init();
000002  f7fffffe          BL       Internet_Init
                  |L6.6|
000006  f7fffffe          BL       W5500_Check_Link
00000a  2800              CMP      r0,#0                 ;962
00000c  d1f9              BNE      |L6.2|
;;;965    	}
;;;966    
;;;967    	while(1)
00000e  e012              B        |L6.54|
                  |L6.16|
;;;968    	{
;;;969    		PBout(3) = ~PBout(3);
000010  4809              LDR      r0,|L6.56|
000012  6800              LDR      r0,[r0,#0]
000014  43c0              MVNS     r0,r0
000016  4909              LDR      r1,|L6.60|
000018  f8c1018c          STR      r0,[r1,#0x18c]
;;;970    		vTaskDelay(50);
00001c  2032              MOVS     r0,#0x32
00001e  f7fffffe          BL       vTaskDelay
;;;971    
;;;972    		PBout(3) = ~PBout(3);
000022  4806              LDR      r0,|L6.60|
000024  f8d0018c          LDR      r0,[r0,#0x18c]
000028  43c0              MVNS     r0,r0
00002a  4904              LDR      r1,|L6.60|
00002c  f8c1018c          STR      r0,[r1,#0x18c]
;;;973    		vTaskDelay(50);
000030  2032              MOVS     r0,#0x32
000032  f7fffffe          BL       vTaskDelay
                  |L6.54|
000036  e7eb              B        |L6.16|
;;;974    	}
;;;975    //	while (1)
;;;976    //	{
;;;977    //		PBout(3) = ~PBout(3);
;;;978    //		vTaskDelay(50);
;;;979    
;;;980    //		PBout(3) = ~PBout(3);
;;;981    //		vTaskDelay(50);
;;;982    ////		tcp server demo
;;;983    //		switch(getSn_SR(SOCK_TCPS))									   /*获取socket的状态*/
;;;984    //        {
;;;985    //		case SOCK_CLOSED:											    /*socket处于关闭状态*/
;;;986    //			socket(SOCK_TCPS ,Sn_MR_TCP,ConfigMsg.port,Sn_MR_ND);	     /*打开socket*/
;;;987    //			break;
;;;988    
;;;989    //		case SOCK_INIT:													/*socket已初始化状态*/
;;;990    //			listen(SOCK_TCPS);											/*socket建立监听*/
;;;991    //			break;
;;;992    
;;;993    //		case SOCK_ESTABLISHED:											/*socket处于连接建立状态*/
;;;994    //			if(getSn_IR(SOCK_TCPS) & Sn_IR_CON)
;;;995    //			{
;;;996    //				setSn_IR(SOCK_TCPS, Sn_IR_CON);							/*清除接收中断标志位*/
;;;997    //			}
;;;998    //			len=getSn_RX_RSR(SOCK_TCPS);							    /*定义len为已接收数据的长度*/
;;;999    //			if(len>0)
;;;1000   //			{
;;;1001   //				recv(SOCK_TCPS,Internet_Rxbuff,len);					/*接收来自Client的数据*/
;;;1002   //				send(SOCK_TCPS,ALL_FF,8);	/*向Client发送数据*/
;;;1003   
;;;1004   ////				send(SOCK_TCPS,Internet_Rxbuff,len);	/*向Client发送数据*/
;;;1005   ////			    close(SOCK_TCPS);	//短连接，每接受完成一次数据，断开连接
;;;1006   //			}	
;;;1007   //			break;
;;;1008   //		 case SOCK_CLOSE_WAIT:	/*socket处于等待关闭状态*/
;;;1009   //			close(SOCK_TCPS);
;;;1010   //			break;
;;;1011   //       }
;;;1012   ////		clitest = TCP_Client_Demo(8);
;;;1013   //	}
;;;1014   }
;;;1015   /********** (C) COPYRIGHT DIY嵌入式开发工作室 *****END OF FILE****************/
                          ENDP

                  |L6.56|
                          DCD      0x4221818c
                  |L6.60|
                          DCD      0x42218000

                          AREA ||i.vTrigger_Task||, CODE, READONLY, ALIGN=2

                  vTrigger_Task PROC
;;;689    **********************************************/ 
;;;690    static void vTrigger_Task( void *pvParameters )
000000  e06b              B        |L7.218|
                  |L7.2|
;;;691    {   
;;;692    	while(1)
;;;693    	{ 
;;;694    		In_Put_Handle_fun(); 
000002  f7fffffe          BL       In_Put_Handle_fun
;;;695    		
;;;696    		if((current_node.trigger_microwave3 == 1)||(Get_SWD2_GPIO_In == 0))
000006  4835              LDR      r0,|L7.220|
000008  7b40              LDRB     r0,[r0,#0xd]  ; current_node
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L7.20|
00000e  4834              LDR      r0,|L7.224|
000010  6800              LDR      r0,[r0,#0]
000012  b930              CBNZ     r0,|L7.34|
                  |L7.20|
;;;697    		{
;;;698    //			timer2Init(1000); 
;;;699    			LED_Lingt_Flash_Faster = 1;
000014  2001              MOVS     r0,#1
000016  4933              LDR      r1,|L7.228|
000018  7008              STRB     r0,[r1,#0]
;;;700    			LED_Lingt_Flash_Timer = 200;
00001a  20c8              MOVS     r0,#0xc8
00001c  4932              LDR      r1,|L7.232|
00001e  8008              STRH     r0,[r1,#0]
000020  e005              B        |L7.46|
                  |L7.34|
;;;701    		}
;;;702    		else
;;;703    		{
;;;704    //			timer2Init(2000);
;;;705    			LED_Lingt_Flash_Faster = 0;
000022  2000              MOVS     r0,#0
000024  492f              LDR      r1,|L7.228|
000026  7008              STRB     r0,[r1,#0]
;;;706    			KM_7 = 1;
000028  2001              MOVS     r0,#1
00002a  4930              LDR      r1,|L7.236|
00002c  6008              STR      r0,[r1,#0]
                  |L7.46|
;;;707    		}
;;;708    //输入检测
;;;709    //		if((SWD_1 == 1)||(SW_IN_1 == 0))
;;;710    //		{
;;;711    //			current_node.trigger_vehicle1 = 1;
;;;712    //		}
;;;713    //		if((SWD_2 == 1)||(SW_IN_2 == 0))
;;;714    //		{
;;;715    //			current_node.trigger_video2 = 1;
;;;716    //		}
;;;717    		
;;;718    //		if((SWD_3 == 1)||(SW_IN_3 == 0))
;;;719    //		{
;;;720    //			current_node.trigger_microwave3 = 1;
;;;721    //		}
;;;722    //		if((SWD_4 == 1)||(SW_IN_4 == 0))
;;;723    //		{
;;;724    //			current_node.trigger_reserve1 = 1;
;;;725    //		}
;;;726    //		if(gMeshFinished)
;;;727    //			PCout(14) = 0;
;;;728    //		else
;;;729    //			PCout(14) = 1;
;;;730    		
;;;731    //		current_node.slave_addr2 = 0X01;
;;;732    		current_node.master_addr = 0x01;
00002e  2001              MOVS     r0,#1
000030  492a              LDR      r1,|L7.220|
000032  70c8              STRB     r0,[r1,#3]
;;;733    //		current_node.location2   = 0X03;
;;;734    //输出控制
;;;735    //#define KM_1 PBout(3)
;;;736    //#define KM_2 PDout(2)
;;;737    //#define KM_3 PCout(12)
;;;738    //#define KM_4 PCout(11)
;;;739    //#define KM_5 PCout(10)
;;;740    //#define KM_6 PAout(15)
;;;741    		if(current_node.spikelamp_switch1 == 1)
000034  4608              MOV      r0,r1
000036  7bc0              LDRB     r0,[r0,#0xf]  ; current_node
000038  2801              CMP      r0,#1
00003a  d102              BNE      |L7.66|
;;;742    		{
;;;743    			KM_1 = 0;
00003c  2000              MOVS     r0,#0
00003e  492c              LDR      r1,|L7.240|
000040  6008              STR      r0,[r1,#0]
                  |L7.66|
;;;744    		}
;;;745    
;;;746    		if(current_node.voice_switch2 == 1)
000042  4826              LDR      r0,|L7.220|
000044  7c00              LDRB     r0,[r0,#0x10]  ; current_node
000046  2801              CMP      r0,#1
000048  d103              BNE      |L7.82|
;;;747    		{
;;;748    			KM_2 = 0;
00004a  2000              MOVS     r0,#0
00004c  4928              LDR      r1,|L7.240|
00004e  1f09              SUBS     r1,r1,#4
000050  6008              STR      r0,[r1,#0]
                  |L7.82|
;;;749    		}
;;;750    
;;;751    		if(current_node.led_switch3 == 1)
000052  4822              LDR      r0,|L7.220|
000054  7c40              LDRB     r0,[r0,#0x11]  ; current_node
000056  2801              CMP      r0,#1
000058  d103              BNE      |L7.98|
;;;752    		{
;;;753    			KM_3 = 0;
00005a  2000              MOVS     r0,#0
00005c  4924              LDR      r1,|L7.240|
00005e  3908              SUBS     r1,r1,#8
000060  6008              STR      r0,[r1,#0]
                  |L7.98|
;;;754    		}
;;;755    
;;;756    		if(current_node.reserve1_switch == 1)
000062  481e              LDR      r0,|L7.220|
000064  7c80              LDRB     r0,[r0,#0x12]  ; current_node
000066  2801              CMP      r0,#1
000068  d102              BNE      |L7.112|
;;;757    		{
;;;758    			KM_4 = 0;
00006a  2000              MOVS     r0,#0
00006c  4921              LDR      r1,|L7.244|
00006e  6008              STR      r0,[r1,#0]
                  |L7.112|
;;;759    		}
;;;760    
;;;761    		if(current_node.reserve2_switch == 1)
000070  481a              LDR      r0,|L7.220|
000072  7cc0              LDRB     r0,[r0,#0x13]  ; current_node
000074  2801              CMP      r0,#1
000076  d103              BNE      |L7.128|
;;;762    		{
;;;763    			KM_5 = 0;
000078  2000              MOVS     r0,#0
00007a  491c              LDR      r1,|L7.236|
00007c  3108              ADDS     r1,r1,#8
00007e  6008              STR      r0,[r1,#0]
                  |L7.128|
;;;764    		}
;;;765    
;;;766    		if(current_node.reserve3_switch == 1)
000080  4816              LDR      r0,|L7.220|
000082  7d00              LDRB     r0,[r0,#0x14]  ; current_node
000084  2801              CMP      r0,#1
000086  d103              BNE      |L7.144|
;;;767    		{
;;;768    			KM_6 = 0;
000088  2000              MOVS     r0,#0
00008a  4918              LDR      r1,|L7.236|
00008c  1d09              ADDS     r1,r1,#4
00008e  6008              STR      r0,[r1,#0]
                  |L7.144|
;;;769    		}
;;;770    		 
;;;771    //		if (current_node.bad_cnt > CURRENT_BAD_CNT_MAX) //! communication is bad ! run selfcheck !
;;;772    //		current_node.slave_addr2 = 0;
;;;773    		
;;;774    		current_node.id = current_node.slave_addr2;
000090  4812              LDR      r0,|L7.220|
000092  7940              LDRB     r0,[r0,#5]  ; current_node
000094  4911              LDR      r1,|L7.220|
000096  7008              STRB     r0,[r1,#0]
;;;775    		if(current_node.slave_addr2 == 0)
000098  4608              MOV      r0,r1
00009a  7940              LDRB     r0,[r0,#5]  ; current_node
00009c  b9a0              CBNZ     r0,|L7.200|
;;;776    		{
;;;777    //			current_node.spikelamp_switch1 = 0;
;;;778    //			current_node.voice_switch2     = 0;
;;;779    //			current_node.led_switch3       = 0;
;;;780    //			current_node.reserve1_switch   = 0;
;;;781    //			current_node.reserve2_switch   = 0;
;;;782    //			current_node.reserve3_switch   = 0;
;;;783    			KM_1 = 1;
00009e  2001              MOVS     r0,#1
0000a0  4913              LDR      r1,|L7.240|
0000a2  6008              STR      r0,[r1,#0]
;;;784    			KM_2 = 1;
0000a4  4914              LDR      r1,|L7.248|
0000a6  f8c10190          STR      r0,[r1,#0x190]
;;;785    			KM_3 = 1;
0000aa  4911              LDR      r1,|L7.240|
0000ac  3908              SUBS     r1,r1,#8
0000ae  6008              STR      r0,[r1,#0]
;;;786    			KM_4 = 1;
0000b0  4910              LDR      r1,|L7.244|
0000b2  6008              STR      r0,[r1,#0]
;;;787    			KM_5 = 1;
0000b4  490d              LDR      r1,|L7.236|
0000b6  3108              ADDS     r1,r1,#8
0000b8  6008              STR      r0,[r1,#0]
;;;788    			KM_6 = 1;
0000ba  1f09              SUBS     r1,r1,#4
0000bc  6008              STR      r0,[r1,#0]
;;;789    			KM_7 = 1;
0000be  1f09              SUBS     r1,r1,#4
0000c0  6008              STR      r0,[r1,#0]
;;;790    			KM_8 = 1;
0000c2  490e              LDR      r1,|L7.252|
0000c4  f8c101bc          STR      r0,[r1,#0x1bc]
                  |L7.200|
;;;791    		}
;;;792    		if(current_node.bad_cnt > CURRENT_BAD_CNT_RESTAR) //定时器中++
0000c8  4804              LDR      r0,|L7.220|
0000ca  7880              LDRB     r0,[r0,#2]  ; current_node
0000cc  283c              CMP      r0,#0x3c
0000ce  dd01              BLE      |L7.212|
;;;793    		{
;;;794    			systemReboot();
0000d0  f7fffffe          BL       systemReboot
                  |L7.212|
;;;795    		}
;;;796    		
;;;797    
;;;798    //		printf("KM_1 %d:  \r\n",(uint8_t)KM_1);
;;;799    //		printf("current_node.spikelamp_switch1 %d:  \r\n",(uint8_t)current_node.spikelamp_switch1);
;;;800    //		printf("km1_time %d:  \r\n",(uint8_t)km1_time);	
;;;801    		vTaskDelay(2);	
0000d4  2002              MOVS     r0,#2
0000d6  f7fffffe          BL       vTaskDelay
                  |L7.218|
0000da  e792              B        |L7.2|
;;;802    	}
;;;803    } 
;;;804    /**********************************************
                          ENDP

                  |L7.220|
                          DCD      current_node
                  |L7.224|
                          DCD      0x42210118
                  |L7.228|
                          DCD      LED_Lingt_Flash_Faster
                  |L7.232|
                          DCD      LED_Lingt_Flash_Timer
                  |L7.236|
                          DCD      0x422201a8
                  |L7.240|
                          DCD      0x42218194
                  |L7.244|
                          DCD      0x42228188
                  |L7.248|
                          DCD      0x42218000
                  |L7.252|
                          DCD      0x42210000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  Buffer
                          %        30
                  NetRS485Msg
                          %        86

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  crc16Tab
000000  00001021          DCW      0x0000,0x1021
000004  20423063          DCW      0x2042,0x3063
000008  408450a5          DCW      0x4084,0x50a5
00000c  60c670e7          DCW      0x60c6,0x70e7
000010  81089129          DCW      0x8108,0x9129
000014  a14ab16b          DCW      0xa14a,0xb16b
000018  c18cd1ad          DCW      0xc18c,0xd1ad
00001c  e1cef1ef          DCW      0xe1ce,0xf1ef
000020  12310210          DCW      0x1231,0x0210
000024  32732252          DCW      0x3273,0x2252
000028  52b54294          DCW      0x52b5,0x4294
00002c  72f762d6          DCW      0x72f7,0x62d6
000030  93398318          DCW      0x9339,0x8318
000034  b37ba35a          DCW      0xb37b,0xa35a
000038  d3bdc39c          DCW      0xd3bd,0xc39c
00003c  f3ffe3de          DCW      0xf3ff,0xe3de
000040  24623443          DCW      0x2462,0x3443
000044  04201401          DCW      0x0420,0x1401
000048  64e674c7          DCW      0x64e6,0x74c7
00004c  44a45485          DCW      0x44a4,0x5485
000050  a56ab54b          DCW      0xa56a,0xb54b
000054  85289509          DCW      0x8528,0x9509
000058  e5eef5cf          DCW      0xe5ee,0xf5cf
00005c  c5acd58d          DCW      0xc5ac,0xd58d
000060  36532672          DCW      0x3653,0x2672
000064  16110630          DCW      0x1611,0x0630
000068  76d766f6          DCW      0x76d7,0x66f6
00006c  569546b4          DCW      0x5695,0x46b4
000070  b75ba77a          DCW      0xb75b,0xa77a
000074  97198738          DCW      0x9719,0x8738
000078  f7dfe7fe          DCW      0xf7df,0xe7fe
00007c  d79dc7bc          DCW      0xd79d,0xc7bc
000080  48c458e5          DCW      0x48c4,0x58e5
000084  688678a7          DCW      0x6886,0x78a7
000088  08401861          DCW      0x0840,0x1861
00008c  28023823          DCW      0x2802,0x3823
000090  c9ccd9ed          DCW      0xc9cc,0xd9ed
000094  e98ef9af          DCW      0xe98e,0xf9af
000098  89489969          DCW      0x8948,0x9969
00009c  a90ab92b          DCW      0xa90a,0xb92b
0000a0  5af54ad4          DCW      0x5af5,0x4ad4
0000a4  7ab76a96          DCW      0x7ab7,0x6a96
0000a8  1a710a50          DCW      0x1a71,0x0a50
0000ac  3a332a12          DCW      0x3a33,0x2a12
0000b0  dbfdcbdc          DCW      0xdbfd,0xcbdc
0000b4  fbbfeb9e          DCW      0xfbbf,0xeb9e
0000b8  9b798b58          DCW      0x9b79,0x8b58
0000bc  bb3bab1a          DCW      0xbb3b,0xab1a
0000c0  6ca67c87          DCW      0x6ca6,0x7c87
0000c4  4ce45cc5          DCW      0x4ce4,0x5cc5
0000c8  2c223c03          DCW      0x2c22,0x3c03
0000cc  0c601c41          DCW      0x0c60,0x1c41
0000d0  edaefd8f          DCW      0xedae,0xfd8f
0000d4  cdecddcd          DCW      0xcdec,0xddcd
0000d8  ad2abd0b          DCW      0xad2a,0xbd0b
0000dc  8d689d49          DCW      0x8d68,0x9d49
0000e0  7e976eb6          DCW      0x7e97,0x6eb6
0000e4  5ed54ef4          DCW      0x5ed5,0x4ef4
0000e8  3e132e32          DCW      0x3e13,0x2e32
0000ec  1e510e70          DCW      0x1e51,0x0e70
0000f0  ff9fefbe          DCW      0xff9f,0xefbe
0000f4  dfddcffc          DCW      0xdfdd,0xcffc
0000f8  bf1baf3a          DCW      0xbf1b,0xaf3a
0000fc  9f598f78          DCW      0x9f59,0x8f78
000100  918881a9          DCW      0x9188,0x81a9
000104  b1caa1eb          DCW      0xb1ca,0xa1eb
000108  d10cc12d          DCW      0xd10c,0xc12d
00010c  f14ee16f          DCW      0xf14e,0xe16f
000110  108000a1          DCW      0x1080,0x00a1
000114  30c220e3          DCW      0x30c2,0x20e3
000118  50044025          DCW      0x5004,0x4025
00011c  70466067          DCW      0x7046,0x6067
000120  83b99398          DCW      0x83b9,0x9398
000124  a3fbb3da          DCW      0xa3fb,0xb3da
000128  c33dd31c          DCW      0xc33d,0xd31c
00012c  e37ff35e          DCW      0xe37f,0xf35e
000130  02b11290          DCW      0x02b1,0x1290
000134  22f332d2          DCW      0x22f3,0x32d2
000138  42355214          DCW      0x4235,0x5214
00013c  62777256          DCW      0x6277,0x7256
000140  b5eaa5cb          DCW      0xb5ea,0xa5cb
000144  95a88589          DCW      0x95a8,0x8589
000148  f56ee54f          DCW      0xf56e,0xe54f
00014c  d52cc50d          DCW      0xd52c,0xc50d
000150  34e224c3          DCW      0x34e2,0x24c3
000154  14a00481          DCW      0x14a0,0x0481
000158  74666447          DCW      0x7466,0x6447
00015c  54244405          DCW      0x5424,0x4405
000160  a7dbb7fa          DCW      0xa7db,0xb7fa
000164  879997b8          DCW      0x8799,0x97b8
000168  e75ff77e          DCW      0xe75f,0xf77e
00016c  c71dd73c          DCW      0xc71d,0xd73c
000170  26d336f2          DCW      0x26d3,0x36f2
000174  069116b0          DCW      0x0691,0x16b0
000178  66577676          DCW      0x6657,0x7676
00017c  46155634          DCW      0x4615,0x5634
000180  d94cc96d          DCW      0xd94c,0xc96d
000184  f90ee92f          DCW      0xf90e,0xe92f
000188  99c889e9          DCW      0x99c8,0x89e9
00018c  b98aa9ab          DCW      0xb98a,0xa9ab
000190  58444865          DCW      0x5844,0x4865
000194  78066827          DCW      0x7806,0x6827
000198  18c008e1          DCW      0x18c0,0x08e1
00019c  388228a3          DCW      0x3882,0x28a3
0001a0  cb7ddb5c          DCW      0xcb7d,0xdb5c
0001a4  eb3ffb1e          DCW      0xeb3f,0xfb1e
0001a8  8bf99bd8          DCW      0x8bf9,0x9bd8
0001ac  abbbbb9a          DCW      0xabbb,0xbb9a
0001b0  4a755a54          DCW      0x4a75,0x5a54
0001b4  6a377a16          DCW      0x6a37,0x7a16
0001b8  0af11ad0          DCW      0x0af1,0x1ad0
0001bc  2ab33a92          DCW      0x2ab3,0x3a92
0001c0  fd2eed0f          DCW      0xfd2e,0xed0f
0001c4  dd6ccd4d          DCW      0xdd6c,0xcd4d
0001c8  bdaaad8b          DCW      0xbdaa,0xad8b
0001cc  9de88dc9          DCW      0x9de8,0x8dc9
0001d0  7c266c07          DCW      0x7c26,0x6c07
0001d4  5c644c45          DCW      0x5c64,0x4c45
0001d8  3ca22c83          DCW      0x3ca2,0x2c83
0001dc  1ce00cc1          DCW      0x1ce0,0x0cc1
0001e0  ef1fff3e          DCW      0xef1f,0xff3e
0001e4  cf5ddf7c          DCW      0xcf5d,0xdf7c
0001e8  af9bbfba          DCW      0xaf9b,0xbfba
0001ec  8fd99ff8          DCW      0x8fd9,0x9ff8
0001f0  6e177e36          DCW      0x6e17,0x7e36
0001f4  4e555e74          DCW      0x4e55,0x5e74
0001f8  2e933eb2          DCW      0x2e93,0x3eb2
0001fc  0ed11ef0          DCW      0x0ed1,0x1ef0
                  xMaxBlockTime
                          DCD      0x000000c8

                          AREA ||.data||, DATA, ALIGN=2

                  BufferSize
000000  001e              DCW      0x001e
                  EnableMaster
000002  01                DCB      0x01
                  LED_Lingt_Flash_Faster
000003  00                DCB      0x00
                  LED_Lingt_Flash_Timer
000004  0000              DCW      0x0000
                  Send
000006  ffff              DCB      0xff,0xff
000008  ffffffff          DCB      0xff,0xff,0xff,0xff
                  num
00000c  30313233          DCB      0x30,0x31,0x32,0x33
000010  3435              DCB      0x34,0x35
                  letter
000012  6162              DCB      0x61,0x62
000014  63646566          DCB      0x63,0x64,0x65,0x66
                  ptMsg
                          DCD      0x00000000
                  ptClientMsg
                          DCD      0x00000000
                  xResult
                          DCD      0x00000000
                  xHandleRS485Task
                          DCD      0x00000000
                  xQueue_RS485
                          DCD      0x00000000
                  xSem_swch1
                          DCD      0x00000000
                  t
000030  00                DCB      0x00
                  powerState
000031  01                DCB      0x01
                  |symbol_number.34|
000032  01                DCB      0x01

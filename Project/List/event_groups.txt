; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\event_groups.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\event_groups.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\event_groups.crf ..\Libraries\FreeRTOS\event_groups.c]
                          THUMB

                          AREA ||i.prvTestWaitCondition||, CODE, READONLY, ALIGN=1

                  prvTestWaitCondition PROC
;;;577    
;;;578    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
000000  b510              PUSH     {r4,lr}
;;;579    {
000002  4603              MOV      r3,r0
;;;580    BaseType_t xWaitConditionMet = pdFALSE;
000004  2000              MOVS     r0,#0
;;;581    
;;;582    	if( xWaitForAllBits == pdFALSE )
000006  b922              CBNZ     r2,|L1.18|
;;;583    	{
;;;584    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;585    		set.  Is one already set? */
;;;586    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
000008  ea030401          AND      r4,r3,r1
00000c  b134              CBZ      r4,|L1.28|
;;;587    		{
;;;588    			xWaitConditionMet = pdTRUE;
00000e  2001              MOVS     r0,#1
000010  e004              B        |L1.28|
                  |L1.18|
;;;589    		}
;;;590    		else
;;;591    		{
;;;592    			mtCOVERAGE_TEST_MARKER();
;;;593    		}
;;;594    	}
;;;595    	else
;;;596    	{
;;;597    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;598    		Are they set already? */
;;;599    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000012  ea030401          AND      r4,r3,r1
000016  428c              CMP      r4,r1
000018  d100              BNE      |L1.28|
;;;600    		{
;;;601    			xWaitConditionMet = pdTRUE;
00001a  2001              MOVS     r0,#1
                  |L1.28|
;;;602    		}
;;;603    		else
;;;604    		{
;;;605    			mtCOVERAGE_TEST_MARKER();
;;;606    		}
;;;607    	}
;;;608    
;;;609    	return xWaitConditionMet;
;;;610    }
00001c  bd10              POP      {r4,pc}
;;;611    
                          ENDP


                          AREA ||i.vEventGroupDelete||, CODE, READONLY, ALIGN=1

                  vEventGroupDelete PROC
;;;546    
;;;547    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
000000  b570              PUSH     {r4-r6,lr}
;;;548    {
000002  4605              MOV      r5,r0
;;;549    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000004  462e              MOV      r6,r5
;;;550    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
000006  1d34              ADDS     r4,r6,#4
;;;551    
;;;552    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;553    	{
;;;554    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;555    
;;;556    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
00000c  e011              B        |L2.50|
                  |L2.14|
;;;557    		{
;;;558    			/* Unblock the task, returning 0 as the event list is being deleted
;;;559    			and	cannot therefore have any bits set. */
;;;560    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
00000e  f1040008          ADD      r0,r4,#8
000012  68e1              LDR      r1,[r4,#0xc]
000014  4281              CMP      r1,r0
000016  d001              BEQ      |L2.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L2.30|
                  |L2.28|
00001c  2000              MOVS     r0,#0
                  |L2.30|
00001e  b918              CBNZ     r0,|L2.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L2.38|
000026  e7fe              B        |L2.38|
                  |L2.40|
;;;561    			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, ( TickType_t ) eventUNBLOCKED_DUE_TO_BIT_SET );
000028  f04f7100          MOV      r1,#0x2000000
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L2.50|
000032  6820              LDR      r0,[r4,#0]            ;556
000034  2800              CMP      r0,#0                 ;556
000036  d1ea              BNE      |L2.14|
;;;562    		}
;;;563    
;;;564    		vPortFree( pxEventBits );
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       vPortFree
;;;565    	}
;;;566    	( void ) xTaskResumeAll();
00003e  f7fffffe          BL       xTaskResumeAll
;;;567    }
000042  bd70              POP      {r4-r6,pc}
;;;568    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupSetBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupSetBitsCallback PROC
;;;571    an interrupt. */
;;;572    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
000000  b570              PUSH     {r4-r6,lr}
;;;573    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;574    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       xEventGroupSetBits
;;;575    }
00000e  bd70              POP      {r4-r6,pc}
;;;576    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupClearBits||, CODE, READONLY, ALIGN=1

                  xEventGroupClearBits PROC
;;;400    
;;;401    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;402    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;403    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000008  4635              MOV      r5,r6
;;;404    EventBits_t uxReturn;
;;;405    
;;;406    	/* Check the user is not attempting to clear the bits used by the kernel
;;;407    	itself. */
;;;408    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00000a  f004407f          AND      r0,r4,#0xff000000
00000e  b908              CBNZ     r0,|L4.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L4.22|
                  |L4.20|
000014  2000              MOVS     r0,#0
                  |L4.22|
000016  b918              CBNZ     r0,|L4.32|
000018  f7fffffe          BL       ulPortSetInterruptMask
00001c  bf00              NOP      
                  |L4.30|
00001e  e7fe              B        |L4.30|
                  |L4.32|
;;;409    
;;;410    	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;411    	{
;;;412    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;413    
;;;414    		/* The value returned is the event group value prior to the bits being
;;;415    		cleared. */
;;;416    		uxReturn = pxEventBits->uxEventBits;
000024  682f              LDR      r7,[r5,#0]
;;;417    
;;;418    		/* Clear the bits. */
;;;419    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000026  6828              LDR      r0,[r5,#0]
000028  43a0              BICS     r0,r0,r4
00002a  6028              STR      r0,[r5,#0]
;;;420    	}
;;;421    	taskEXIT_CRITICAL();
00002c  f7fffffe          BL       vPortExitCritical
;;;422    
;;;423    	return uxReturn;
000030  4638              MOV      r0,r7
;;;424    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;425    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupClearBitsFromISR||, CODE, READONLY, ALIGN=1

                  xEventGroupClearBitsFromISR PROC
;;;426    
;;;427    EventBits_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;428    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;429    UBaseType_t uxSavedInterruptStatus;
;;;430    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000008  4635              MOV      r5,r6
;;;431    EventBits_t uxReturn;
;;;432    
;;;433    	/* Check the user is not attempting to clear the bits used by the kernel
;;;434    	itself. */
;;;435    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00000a  f004407f          AND      r0,r4,#0xff000000
00000e  b908              CBNZ     r0,|L5.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L5.22|
                  |L5.20|
000014  2000              MOVS     r0,#0
                  |L5.22|
000016  b918              CBNZ     r0,|L5.32|
000018  f7fffffe          BL       ulPortSetInterruptMask
00001c  bf00              NOP      
                  |L5.30|
00001e  e7fe              B        |L5.30|
                  |L5.32|
;;;436    
;;;437    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  4680              MOV      r8,r0
;;;438    	{
;;;439    		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
;;;440    
;;;441    		/* The value returned is the event group value prior to the bits being
;;;442    		cleared. */
;;;443    		uxReturn = pxEventBits->uxEventBits;
000026  682f              LDR      r7,[r5,#0]
;;;444    
;;;445    		/* Clear the bits. */
;;;446    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000028  6828              LDR      r0,[r5,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6028              STR      r0,[r5,#0]
;;;447    	}
;;;448    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       vPortClearInterruptMask
;;;449    
;;;450    	return uxReturn;
000034  4638              MOV      r0,r7
;;;451    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;452    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupCreate||, CODE, READONLY, ALIGN=1

                  xEventGroupCreate PROC
;;;128    
;;;129    EventGroupHandle_t xEventGroupCreate( void )
000000  b510              PUSH     {r4,lr}
;;;130    {
;;;131    EventGroup_t *pxEventBits;
;;;132    
;;;133    	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
000002  2018              MOVS     r0,#0x18
000004  f7fffffe          BL       pvPortMalloc
000008  4604              MOV      r4,r0
;;;134    	if( pxEventBits != NULL )
00000a  b124              CBZ      r4,|L6.22|
;;;135    	{
;;;136    		pxEventBits->uxEventBits = 0;
00000c  2000              MOVS     r0,#0
00000e  6020              STR      r0,[r4,#0]
;;;137    		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       vListInitialise
                  |L6.22|
;;;138    		traceEVENT_GROUP_CREATE( pxEventBits );
;;;139    	}
;;;140    	else
;;;141    	{
;;;142    		traceEVENT_GROUP_CREATE_FAILED();
;;;143    	}
;;;144    
;;;145    	return ( EventGroupHandle_t ) pxEventBits;
000016  4620              MOV      r0,r4
;;;146    }
000018  bd10              POP      {r4,pc}
;;;147    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSetBits||, CODE, READONLY, ALIGN=1

                  xEventGroupSetBits PROC
;;;453    
;;;454    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;455    {
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
;;;456    ListItem_t *pxListItem, *pxNext;
;;;457    ListItem_t const *pxListEnd;
;;;458    List_t *pxList;
;;;459    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;460    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00000c  4654              MOV      r4,r10
;;;461    BaseType_t xMatchFound = pdFALSE;
00000e  9000              STR      r0,[sp,#0]
;;;462    
;;;463    	/* Check the user is not attempting to set the bits used by the kernel
;;;464    	itself. */
;;;465    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000010  f007407f          AND      r0,r7,#0xff000000
000014  b908              CBNZ     r0,|L7.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L7.28|
                  |L7.26|
00001a  2000              MOVS     r0,#0
                  |L7.28|
00001c  b918              CBNZ     r0,|L7.38|
00001e  f7fffffe          BL       ulPortSetInterruptMask
000022  bf00              NOP      
                  |L7.36|
000024  e7fe              B        |L7.36|
                  |L7.38|
;;;466    
;;;467    	pxList = &( pxEventBits->xTasksWaitingForBits );
000026  f1040804          ADD      r8,r4,#4
;;;468    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00002a  f1080b08          ADD      r11,r8,#8
;;;469    	vTaskSuspendAll();
00002e  f7fffffe          BL       vTaskSuspendAll
;;;470    	{
;;;471    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;472    
;;;473    		pxListItem = listGET_HEAD_ENTRY( pxList );
000032  f8d8600c          LDR      r6,[r8,#0xc]
;;;474    
;;;475    		/* Set the bits. */
;;;476    		pxEventBits->uxEventBits |= uxBitsToSet;
000036  6820              LDR      r0,[r4,#0]
000038  4338              ORRS     r0,r0,r7
00003a  6020              STR      r0,[r4,#0]
;;;477    
;;;478    		/* See if the new bit value should unblock any tasks. */
;;;479    		while( pxListItem != pxListEnd )
00003c  e026              B        |L7.140|
                  |L7.62|
;;;480    		{
;;;481    			pxNext = listGET_NEXT( pxListItem );
00003e  6870              LDR      r0,[r6,#4]
000040  9002              STR      r0,[sp,#8]
;;;482    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
000042  6835              LDR      r5,[r6,#0]
;;;483    			xMatchFound = pdFALSE;
000044  2000              MOVS     r0,#0
000046  9000              STR      r0,[sp,#0]
;;;484    
;;;485    			/* Split the bits waited for from the control bits. */
;;;486    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
000048  f005497f          AND      r9,r5,#0xff000000
;;;487    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
00004c  f025457f          BIC      r5,r5,#0xff000000
;;;488    
;;;489    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
000050  f0096080          AND      r0,r9,#0x4000000
000054  b928              CBNZ     r0,|L7.98|
;;;490    			{
;;;491    				/* Just looking for single bit being set. */
;;;492    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
000056  6820              LDR      r0,[r4,#0]
000058  4028              ANDS     r0,r0,r5
00005a  b140              CBZ      r0,|L7.110|
;;;493    				{
;;;494    					xMatchFound = pdTRUE;
00005c  2001              MOVS     r0,#1
00005e  9000              STR      r0,[sp,#0]
000060  e005              B        |L7.110|
                  |L7.98|
;;;495    				}
;;;496    				else
;;;497    				{
;;;498    					mtCOVERAGE_TEST_MARKER();
;;;499    				}
;;;500    			}
;;;501    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
000062  6820              LDR      r0,[r4,#0]
000064  4028              ANDS     r0,r0,r5
000066  42a8              CMP      r0,r5
000068  d101              BNE      |L7.110|
;;;502    			{
;;;503    				/* All bits are set. */
;;;504    				xMatchFound = pdTRUE;
00006a  2001              MOVS     r0,#1
00006c  9000              STR      r0,[sp,#0]
                  |L7.110|
;;;505    			}
;;;506    			else
;;;507    			{
;;;508    				/* Need all bits to be set, but not all the bits were set. */
;;;509    			}
;;;510    
;;;511    			if( xMatchFound != pdFALSE )
00006e  9800              LDR      r0,[sp,#0]
000070  b158              CBZ      r0,|L7.138|
;;;512    			{
;;;513    				/* The bits match.  Should the bits be cleared on exit? */
;;;514    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
000072  f0097080          AND      r0,r9,#0x1000000
000076  b110              CBZ      r0,|L7.126|
;;;515    				{
;;;516    					uxBitsToClear |= uxBitsWaitedFor;
000078  9801              LDR      r0,[sp,#4]
00007a  4328              ORRS     r0,r0,r5
00007c  9001              STR      r0,[sp,#4]
                  |L7.126|
;;;517    				}
;;;518    				else
;;;519    				{
;;;520    					mtCOVERAGE_TEST_MARKER();
;;;521    				}
;;;522    
;;;523    				/* Store the actual event flag value in the task's event list
;;;524    				item before removing the task from the event list.  The
;;;525    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;526    				that is was unblocked due to its required bits matching, rather
;;;527    				than because it timed out. */
;;;528    				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
00007e  6820              LDR      r0,[r4,#0]
000080  f0407100          ORR      r1,r0,#0x2000000
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L7.138|
;;;529    			}
;;;530    
;;;531    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;532    			used here as the list item may have been removed from the event list
;;;533    			and inserted into the ready/pending reading list. */
;;;534    			pxListItem = pxNext;
00008a  9e02              LDR      r6,[sp,#8]
                  |L7.140|
00008c  455e              CMP      r6,r11                ;479
00008e  d1d6              BNE      |L7.62|
;;;535    		}
;;;536    
;;;537    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;538    		bit was set in the control word. */
;;;539    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000090  6820              LDR      r0,[r4,#0]
000092  9901              LDR      r1,[sp,#4]
000094  4388              BICS     r0,r0,r1
000096  6020              STR      r0,[r4,#0]
;;;540    	}
;;;541    	( void ) xTaskResumeAll();
000098  f7fffffe          BL       xTaskResumeAll
;;;542    
;;;543    	return pxEventBits->uxEventBits;
00009c  6820              LDR      r0,[r4,#0]
;;;544    }
00009e  e8bd8ffe          POP      {r1-r11,pc}
;;;545    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSync||, CODE, READONLY, ALIGN=1

                  xEventGroupSync PROC
;;;148    
;;;149    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;150    {
000004  4683              MOV      r11,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;151    EventBits_t uxOriginalBitValue, uxReturn;
;;;152    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00000c  465d              MOV      r5,r11
;;;153    BaseType_t xAlreadyYielded;
;;;154    
;;;155    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00000e  f004407f          AND      r0,r4,#0xff000000
000012  b908              CBNZ     r0,|L8.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L8.26|
                  |L8.24|
000018  2000              MOVS     r0,#0
                  |L8.26|
00001a  b918              CBNZ     r0,|L8.36|
00001c  f7fffffe          BL       ulPortSetInterruptMask
000020  bf00              NOP      
                  |L8.34|
000022  e7fe              B        |L8.34|
                  |L8.36|
;;;156    	configASSERT( uxBitsToWaitFor != 0 );
000024  b10c              CBZ      r4,|L8.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L8.44|
                  |L8.42|
00002a  2000              MOVS     r0,#0
                  |L8.44|
00002c  b918              CBNZ     r0,|L8.54|
00002e  f7fffffe          BL       ulPortSetInterruptMask
000032  bf00              NOP      
                  |L8.52|
000034  e7fe              B        |L8.52|
                  |L8.54|
;;;157    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;158    	{
;;;159    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;160    	}
;;;161    	#endif
;;;162    
;;;163    	vTaskSuspendAll();
000036  f7fffffe          BL       vTaskSuspendAll
;;;164    	{
;;;165    		traceEVENT_GROUP_SYNC_START( xEventGroup, uxBitsToSet );
;;;166    
;;;167    		uxOriginalBitValue = pxEventBits->uxEventBits;
00003a  f8d59000          LDR      r9,[r5,#0]
;;;168    
;;;169    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
00003e  4641              MOV      r1,r8
000040  4658              MOV      r0,r11
000042  f7fffffe          BL       xEventGroupSetBits
;;;170    
;;;171    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
000046  ea490008          ORR      r0,r9,r8
00004a  4020              ANDS     r0,r0,r4
00004c  42a0              CMP      r0,r4
00004e  d106              BNE      |L8.94|
;;;172    		{
;;;173    			/* All the rendezvous bits are now set - no need to block. */
;;;174    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
000050  ea490608          ORR      r6,r9,r8
;;;175    
;;;176    			/* Rendezvous always clear the bits.  They will have been cleared
;;;177    			already unless this is the only task in the rendezvous. */
;;;178    			pxEventBits->uxEventBits &= uxBitsToWaitFor;
000054  6828              LDR      r0,[r5,#0]
000056  4020              ANDS     r0,r0,r4
000058  6028              STR      r0,[r5,#0]
;;;179    
;;;180    			xTicksToWait = 0;
00005a  2700              MOVS     r7,#0
00005c  e009              B        |L8.114|
                  |L8.94|
;;;181    		}
;;;182    		else
;;;183    		{
;;;184    			if( xTicksToWait != ( TickType_t ) 0 )
00005e  b13f              CBZ      r7,|L8.112|
;;;185    			{
;;;186    				/* Store the bits that the calling task is waiting for in the
;;;187    				task's event list item so the kernel knows when a match is
;;;188    				found.  Then enter the blocked state. */
;;;189    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
000060  f04461a0          ORR      r1,r4,#0x5000000
000064  463a              MOV      r2,r7
000066  1d28              ADDS     r0,r5,#4
000068  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;190    
;;;191    				/* This assignment is obsolete as uxReturn will get set after
;;;192    				the task unblocks, but some compilers mistakenly generate a
;;;193    				warning about uxReturn being returned without being set if the
;;;194    				assignment is omitted. */
;;;195    				uxReturn = 0;
00006c  2600              MOVS     r6,#0
00006e  e000              B        |L8.114|
                  |L8.112|
;;;196    			}
;;;197    			else
;;;198    			{
;;;199    				/* The rendezvous bits were not set, but no block time was
;;;200    				specified - just return the current event bit value. */
;;;201    				uxReturn = pxEventBits->uxEventBits;
000070  682e              LDR      r6,[r5,#0]
                  |L8.114|
;;;202    			}
;;;203    		}
;;;204    	}
;;;205    	xAlreadyYielded = xTaskResumeAll();
000072  f7fffffe          BL       xTaskResumeAll
000076  4682              MOV      r10,r0
;;;206    
;;;207    	if( xTicksToWait != ( TickType_t ) 0 )
000078  b1cf              CBZ      r7,|L8.174|
;;;208    	{
;;;209    		if( xAlreadyYielded == pdFALSE )
00007a  f1ba0f00          CMP      r10,#0
00007e  d101              BNE      |L8.132|
;;;210    		{
;;;211    			portYIELD_WITHIN_API();
000080  f7fffffe          BL       vPortYield
                  |L8.132|
;;;212    		}
;;;213    		else
;;;214    		{
;;;215    			mtCOVERAGE_TEST_MARKER();
;;;216    		}
;;;217    
;;;218    		/* The task blocked to wait for its required bits to be set - at this
;;;219    		point either the required bits were set or the block time expired.  If
;;;220    		the required bits were set they will have been stored in the task's
;;;221    		event list item, and they should now be retrieved then cleared. */
;;;222    		uxReturn = uxTaskResetEventItemValue();
000084  f7fffffe          BL       uxTaskResetEventItemValue
000088  4606              MOV      r6,r0
;;;223    
;;;224    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
00008a  f0067000          AND      r0,r6,#0x2000000
00008e  b960              CBNZ     r0,|L8.170|
;;;225    		{
;;;226    			/* The task timed out, just return the current event bit value. */
;;;227    			taskENTER_CRITICAL();
000090  f7fffffe          BL       vPortEnterCritical
;;;228    			{
;;;229    				uxReturn = pxEventBits->uxEventBits;
000094  682e              LDR      r6,[r5,#0]
;;;230    
;;;231    				/* Although the task got here because it timed out before the
;;;232    				bits it was waiting for were set, it is possible that since it
;;;233    				unblocked another task has set the bits.  If this is the case
;;;234    				then it may be required to clear the bits before exiting. */
;;;235    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
000096  ea060004          AND      r0,r6,r4
00009a  42a0              CMP      r0,r4
00009c  d102              BNE      |L8.164|
;;;236    				{
;;;237    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00009e  6828              LDR      r0,[r5,#0]
0000a0  43a0              BICS     r0,r0,r4
0000a2  6028              STR      r0,[r5,#0]
                  |L8.164|
;;;238    				}
;;;239    				else
;;;240    				{
;;;241    					mtCOVERAGE_TEST_MARKER();
;;;242    				}
;;;243    			}
;;;244    			taskEXIT_CRITICAL();
0000a4  f7fffffe          BL       vPortExitCritical
0000a8  e001              B        |L8.174|
                  |L8.170|
;;;245    		}
;;;246    		else
;;;247    		{
;;;248    			/* The task unblocked because the bits were set.  Clear the control
;;;249    			bits before returning the value. */
;;;250    			uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000aa  f026467f          BIC      r6,r6,#0xff000000
                  |L8.174|
;;;251    		}
;;;252    	}
;;;253    
;;;254    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxReturn );
;;;255    	return uxReturn;
0000ae  4630              MOV      r0,r6
;;;256    }
0000b0  e8bd9ff0          POP      {r4-r12,pc}
;;;257    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupWaitBits||, CODE, READONLY, ALIGN=1

                  xEventGroupWaitBits PROC
;;;258    
;;;259    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;260    {
000004  b081              SUB      sp,sp,#4
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;261    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00000c  9c01              LDR      r4,[sp,#4]
;;;262    EventBits_t uxReturn, uxControlBits = 0;
00000e  f04f0900          MOV      r9,#0
;;;263    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;264    
;;;265    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;266    	itself, and that at least one bit is being requested. */
;;;267    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000012  f005407f          AND      r0,r5,#0xff000000
000016  b908              CBNZ     r0,|L9.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L9.30|
                  |L9.28|
00001c  2000              MOVS     r0,#0
                  |L9.30|
00001e  b918              CBNZ     r0,|L9.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L9.38|
000026  e7fe              B        |L9.38|
                  |L9.40|
;;;268    	configASSERT( uxBitsToWaitFor != 0 );
000028  b10d              CBZ      r5,|L9.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L9.48|
                  |L9.46|
00002e  2000              MOVS     r0,#0
                  |L9.48|
000030  b918              CBNZ     r0,|L9.58|
000032  f7fffffe          BL       ulPortSetInterruptMask
000036  bf00              NOP      
                  |L9.56|
000038  e7fe              B        |L9.56|
                  |L9.58|
;;;269    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;270    	{
;;;271    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;272    	}
;;;273    	#endif
;;;274    
;;;275    	vTaskSuspendAll();
00003a  f7fffffe          BL       vTaskSuspendAll
;;;276    	{
;;;277    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
00003e  6820              LDR      r0,[r4,#0]
000040  9000              STR      r0,[sp,#0]
;;;278    
;;;279    		traceEVENT_GROUP_WAIT_BITS_START( xEventGroup, uxBitsToWaitFor );
;;;280    
;;;281    		/* Check to see if the wait condition is already met or not. */
;;;282    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
000042  4642              MOV      r2,r8
000044  4629              MOV      r1,r5
000046  9800              LDR      r0,[sp,#0]
000048  f7fffffe          BL       prvTestWaitCondition
00004c  4682              MOV      r10,r0
;;;283    
;;;284    		if( xWaitConditionMet != pdFALSE )
00004e  f1ba0f00          CMP      r10,#0
000052  d007              BEQ      |L9.100|
;;;285    		{
;;;286    			/* The wait condition has already been met so there is no need to
;;;287    			block. */
;;;288    			uxReturn = uxCurrentEventBits;
000054  9e00              LDR      r6,[sp,#0]
;;;289    			xTicksToWait = ( TickType_t ) 0;
000056  2000              MOVS     r0,#0
000058  900e              STR      r0,[sp,#0x38]
;;;290    
;;;291    			/* Clear the wait bits if requested to do so. */
;;;292    			if( xClearOnExit != pdFALSE )
00005a  b1b7              CBZ      r7,|L9.138|
;;;293    			{
;;;294    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00005c  6820              LDR      r0,[r4,#0]
00005e  43a8              BICS     r0,r0,r5
000060  6020              STR      r0,[r4,#0]
000062  e012              B        |L9.138|
                  |L9.100|
;;;295    			}
;;;296    			else
;;;297    			{
;;;298    				mtCOVERAGE_TEST_MARKER();
;;;299    			}
;;;300    		}
;;;301    		else if( xTicksToWait == ( TickType_t ) 0 )
000064  980e              LDR      r0,[sp,#0x38]
000066  b908              CBNZ     r0,|L9.108|
;;;302    		{
;;;303    			/* The wait condition has not been met, but no block time was
;;;304    			specified, so just return the current value. */
;;;305    			uxReturn = uxCurrentEventBits;
000068  9e00              LDR      r6,[sp,#0]
00006a  e00e              B        |L9.138|
                  |L9.108|
;;;306    		}
;;;307    		else
;;;308    		{
;;;309    			/* The task is going to block to wait for its required bits to be
;;;310    			set.  uxControlBits are used to remember the specified behaviour of
;;;311    			this call to xEventGroupWaitBits() - for use when the event bits
;;;312    			unblock the task. */
;;;313    			if( xClearOnExit != pdFALSE )
00006c  b10f              CBZ      r7,|L9.114|
;;;314    			{
;;;315    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
00006e  f0497980          ORR      r9,r9,#0x1000000
                  |L9.114|
;;;316    			}
;;;317    			else
;;;318    			{
;;;319    				mtCOVERAGE_TEST_MARKER();
;;;320    			}
;;;321    
;;;322    			if( xWaitForAllBits != pdFALSE )
000072  f1b80f00          CMP      r8,#0
000076  d001              BEQ      |L9.124|
;;;323    			{
;;;324    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
000078  f0496980          ORR      r9,r9,#0x4000000
                  |L9.124|
;;;325    			}
;;;326    			else
;;;327    			{
;;;328    				mtCOVERAGE_TEST_MARKER();
;;;329    			}
;;;330    
;;;331    			/* Store the bits that the calling task is waiting for in the
;;;332    			task's event list item so the kernel knows when a match is
;;;333    			found.  Then enter the blocked state. */
;;;334    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
00007c  ea450109          ORR      r1,r5,r9
000080  1d20              ADDS     r0,r4,#4
000082  9a0e              LDR      r2,[sp,#0x38]
000084  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;335    
;;;336    			/* This is obsolete as it will get set after the task unblocks, but
;;;337    			some compilers mistakenly generate a warning about the variable
;;;338    			being returned without being set if it is not done. */
;;;339    			uxReturn = 0;
000088  2600              MOVS     r6,#0
                  |L9.138|
;;;340    		}
;;;341    	}
;;;342    	xAlreadyYielded = xTaskResumeAll();
00008a  f7fffffe          BL       xTaskResumeAll
00008e  4683              MOV      r11,r0
;;;343    
;;;344    	if( xTicksToWait != ( TickType_t ) 0 )
000090  980e              LDR      r0,[sp,#0x38]
000092  b1e0              CBZ      r0,|L9.206|
;;;345    	{
;;;346    		if( xAlreadyYielded == pdFALSE )
000094  f1bb0f00          CMP      r11,#0
000098  d101              BNE      |L9.158|
;;;347    		{
;;;348    			portYIELD_WITHIN_API();
00009a  f7fffffe          BL       vPortYield
                  |L9.158|
;;;349    		}
;;;350    		else
;;;351    		{
;;;352    			mtCOVERAGE_TEST_MARKER();
;;;353    		}
;;;354    
;;;355    		/* The task blocked to wait for its required bits to be set - at this
;;;356    		point either the required bits were set or the block time expired.  If
;;;357    		the required bits were set they will have been stored in the task's
;;;358    		event list item, and they should now be retrieved then cleared. */
;;;359    		uxReturn = uxTaskResetEventItemValue();
00009e  f7fffffe          BL       uxTaskResetEventItemValue
0000a2  4606              MOV      r6,r0
;;;360    
;;;361    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0000a4  f0067000          AND      r0,r6,#0x2000000
0000a8  b978              CBNZ     r0,|L9.202|
;;;362    		{
;;;363    			taskENTER_CRITICAL();
0000aa  f7fffffe          BL       vPortEnterCritical
;;;364    			{
;;;365    				/* The task timed out, just return the current event bit value. */
;;;366    				uxReturn = pxEventBits->uxEventBits;
0000ae  6826              LDR      r6,[r4,#0]
;;;367    
;;;368    				/* It is possible that the event bits were updated between this
;;;369    				task leaving the Blocked state and running again. */
;;;370    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0000b0  4642              MOV      r2,r8
0000b2  4629              MOV      r1,r5
0000b4  4630              MOV      r0,r6
0000b6  f7fffffe          BL       prvTestWaitCondition
0000ba  b118              CBZ      r0,|L9.196|
;;;371    				{
;;;372    					if( xClearOnExit != pdFALSE )
0000bc  b117              CBZ      r7,|L9.196|
;;;373    					{
;;;374    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000be  6820              LDR      r0,[r4,#0]
0000c0  43a8              BICS     r0,r0,r5
0000c2  6020              STR      r0,[r4,#0]
                  |L9.196|
;;;375    					}
;;;376    					else
;;;377    					{
;;;378    						mtCOVERAGE_TEST_MARKER();
;;;379    					}
;;;380    				}
;;;381    				else
;;;382    				{
;;;383    					mtCOVERAGE_TEST_MARKER();
;;;384    				}
;;;385    			}
;;;386    			taskEXIT_CRITICAL();
0000c4  f7fffffe          BL       vPortExitCritical
0000c8  e001              B        |L9.206|
                  |L9.202|
;;;387    		}
;;;388    		else
;;;389    		{
;;;390    			/* The task unblocked because the bits were set.  Clear the control
;;;391    			bits before returning the value. */
;;;392    			uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000ca  f026467f          BIC      r6,r6,#0xff000000
                  |L9.206|
;;;393    		}
;;;394    	}
;;;395    
;;;396    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxReturn );
;;;397    	return uxReturn;
0000ce  4630              MOV      r0,r6
;;;398    }
0000d0  b005              ADD      sp,sp,#0x14
0000d2  e8bd8ff0          POP      {r4-r11,pc}
;;;399    /*-----------------------------------------------------------*/
                          ENDP


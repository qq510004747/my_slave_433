; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\queue.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\queue.crf ..\Libraries\FreeRTOS\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;1653   
;;;1654   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;1655   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1656   	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
000006  6820              LDR      r0,[r4,#0]
000008  b170              CBZ      r0,|L1.40|
;;;1657   	{
;;;1658   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4408              ADD      r0,r0,r1
000010  60e0              STR      r0,[r4,#0xc]
;;;1659   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  6861              LDR      r1,[r4,#4]
000014  68e0              LDR      r0,[r4,#0xc]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L1.30|
;;;1660   		{
;;;1661   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
00001c  60e0              STR      r0,[r4,#0xc]
                  |L1.30|
;;;1662   		}
;;;1663   		else
;;;1664   		{
;;;1665   			mtCOVERAGE_TEST_MARKER();
;;;1666   		}
;;;1667   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L1.40|
;;;1668   	}
;;;1669   	else
;;;1670   	{
;;;1671   		mtCOVERAGE_TEST_MARKER();
;;;1672   	}
;;;1673   }
000028  bd70              POP      {r4-r6,pc}
;;;1674   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;1583   
;;;1584   static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  b570              PUSH     {r4-r6,lr}
;;;1585   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1586   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000008  6c20              LDR      r0,[r4,#0x40]
00000a  b938              CBNZ     r0,|L2.28|
;;;1587   	{
;;;1588   		#if ( configUSE_MUTEXES == 1 )
;;;1589   		{
;;;1590   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00000c  6820              LDR      r0,[r4,#0]
00000e  bb70              CBNZ     r0,|L2.110|
;;;1591   			{
;;;1592   				/* The mutex is no longer being held. */
;;;1593   				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
000010  6860              LDR      r0,[r4,#4]
000012  f7fffffe          BL       vTaskPriorityDisinherit
;;;1594   				pxQueue->pxMutexHolder = NULL;
000016  2000              MOVS     r0,#0
000018  6060              STR      r0,[r4,#4]
00001a  e028              B        |L2.110|
                  |L2.28|
;;;1595   			}
;;;1596   			else
;;;1597   			{
;;;1598   				mtCOVERAGE_TEST_MARKER();
;;;1599   			}
;;;1600   		}
;;;1601   		#endif /* configUSE_MUTEXES */
;;;1602   	}
;;;1603   	else if( xPosition == queueSEND_TO_BACK )
00001c  b97d              CBNZ     r5,|L2.62|
;;;1604   	{
;;;1605   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
00001e  4631              MOV      r1,r6
000020  6c22              LDR      r2,[r4,#0x40]
000022  68a0              LDR      r0,[r4,#8]
000024  f7fffffe          BL       __aeabi_memcpy
;;;1606   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
000028  6c21              LDR      r1,[r4,#0x40]
00002a  68a0              LDR      r0,[r4,#8]
00002c  4408              ADD      r0,r0,r1
00002e  60a0              STR      r0,[r4,#8]
;;;1607   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000030  e9d41001          LDRD     r1,r0,[r4,#4]
000034  4288              CMP      r0,r1
000036  d31a              BCC      |L2.110|
;;;1608   		{
;;;1609   			pxQueue->pcWriteTo = pxQueue->pcHead;
000038  6820              LDR      r0,[r4,#0]
00003a  60a0              STR      r0,[r4,#8]
00003c  e017              B        |L2.110|
                  |L2.62|
;;;1610   		}
;;;1611   		else
;;;1612   		{
;;;1613   			mtCOVERAGE_TEST_MARKER();
;;;1614   		}
;;;1615   	}
;;;1616   	else
;;;1617   	{
;;;1618   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00003e  4631              MOV      r1,r6
000040  6c22              LDR      r2,[r4,#0x40]
000042  68e0              LDR      r0,[r4,#0xc]
000044  f7fffffe          BL       __aeabi_memcpy
;;;1619   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000048  6c21              LDR      r1,[r4,#0x40]
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  1a40              SUBS     r0,r0,r1
00004e  60e0              STR      r0,[r4,#0xc]
;;;1620   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000050  6821              LDR      r1,[r4,#0]
000052  68e0              LDR      r0,[r4,#0xc]
000054  4288              CMP      r0,r1
000056  d203              BCS      |L2.96|
;;;1621   		{
;;;1622   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000058  6c21              LDR      r1,[r4,#0x40]
00005a  6860              LDR      r0,[r4,#4]
00005c  1a40              SUBS     r0,r0,r1
00005e  60e0              STR      r0,[r4,#0xc]
                  |L2.96|
;;;1623   		}
;;;1624   		else
;;;1625   		{
;;;1626   			mtCOVERAGE_TEST_MARKER();
;;;1627   		}
;;;1628   
;;;1629   		if( xPosition == queueOVERWRITE )
000060  2d02              CMP      r5,#2
000062  d104              BNE      |L2.110|
;;;1630   		{
;;;1631   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000064  6ba0              LDR      r0,[r4,#0x38]
000066  b110              CBZ      r0,|L2.110|
;;;1632   			{
;;;1633   				/* An item is not being added but overwritten, so subtract
;;;1634   				one from the recorded number of items in the queue so when
;;;1635   				one is added again below the number of recorded items remains
;;;1636   				correct. */
;;;1637   				--( pxQueue->uxMessagesWaiting );
000068  6ba0              LDR      r0,[r4,#0x38]
00006a  1e40              SUBS     r0,r0,#1
00006c  63a0              STR      r0,[r4,#0x38]
                  |L2.110|
;;;1638   			}
;;;1639   			else
;;;1640   			{
;;;1641   				mtCOVERAGE_TEST_MARKER();
;;;1642   			}
;;;1643   		}
;;;1644   		else
;;;1645   		{
;;;1646   			mtCOVERAGE_TEST_MARKER();
;;;1647   		}
;;;1648   	}
;;;1649   
;;;1650   	++( pxQueue->uxMessagesWaiting );
00006e  6ba0              LDR      r0,[r4,#0x38]
000070  1c40              ADDS     r0,r0,#1
000072  63a0              STR      r0,[r4,#0x38]
;;;1651   }
000074  bd70              POP      {r4-r6,pc}
;;;1652   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;1790   
;;;1791   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1792   {
000002  4605              MOV      r5,r0
;;;1793   BaseType_t xReturn;
;;;1794   
;;;1795   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1796   	{
;;;1797   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L3.16|
;;;1798   		{
;;;1799   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L3.18|
                  |L3.16|
;;;1800   		}
;;;1801   		else
;;;1802   		{
;;;1803   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L3.18|
;;;1804   		}
;;;1805   	}
;;;1806   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;1807   
;;;1808   	return xReturn;
000016  4620              MOV      r0,r4
;;;1809   }
000018  bd70              POP      {r4-r6,pc}
;;;1810   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;1829   
;;;1830   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1831   {
000002  4605              MOV      r5,r0
;;;1832   BaseType_t xReturn;
;;;1833   
;;;1834   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1835   	{
;;;1836   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L4.20|
;;;1837   		{
;;;1838   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L4.22|
                  |L4.20|
;;;1839   		}
;;;1840   		else
;;;1841   		{
;;;1842   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L4.22|
;;;1843   		}
;;;1844   	}
;;;1845   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1846   
;;;1847   	return xReturn;
00001a  4620              MOV      r0,r4
;;;1848   }
00001c  bd70              POP      {r4-r6,pc}
;;;1849   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;1675   
;;;1676   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b510              PUSH     {r4,lr}
;;;1677   {
000002  4604              MOV      r4,r0
;;;1678   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1679   
;;;1680   	/* The lock counts contains the number of extra data items placed or
;;;1681   	removed from the queue while the queue was locked.  When a queue is
;;;1682   	locked items can be added or removed, but the event lists cannot be
;;;1683   	updated. */
;;;1684   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1685   	{
;;;1686   		/* See if data was added to the queue while it was locked. */
;;;1687   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
000008  e011              B        |L5.46|
                  |L5.10|
;;;1688   		{
;;;1689   			/* Data was posted while the queue was locked.  Are any tasks
;;;1690   			blocked waiting for data to become available? */
;;;1691   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1692   			{
;;;1693   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1694   				{
;;;1695   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1696   					{
;;;1697   						/* The queue is a member of a queue set, and posting to
;;;1698   						the queue set caused a higher priority task to unblock.
;;;1699   						A context switch is required. */
;;;1700   						vTaskMissedYield();
;;;1701   					}
;;;1702   					else
;;;1703   					{
;;;1704   						mtCOVERAGE_TEST_MARKER();
;;;1705   					}
;;;1706   				}
;;;1707   				else
;;;1708   				{
;;;1709   					/* Tasks that are removed from the event list will get added to
;;;1710   					the pending ready list as the scheduler is still suspended. */
;;;1711   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1712   					{
;;;1713   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1714   						{
;;;1715   							/* The task waiting has a higher priority so record that a
;;;1716   							context	switch is required. */
;;;1717   							vTaskMissedYield();
;;;1718   						}
;;;1719   						else
;;;1720   						{
;;;1721   							mtCOVERAGE_TEST_MARKER();
;;;1722   						}
;;;1723   					}
;;;1724   					else
;;;1725   					{
;;;1726   						break;
;;;1727   					}
;;;1728   				}
;;;1729   			}
;;;1730   			#else /* configUSE_QUEUE_SETS */
;;;1731   			{
;;;1732   				/* Tasks that are removed from the event list will get added to
;;;1733   				the pending ready list as the scheduler is still suspended. */
;;;1734   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000a  6a60              LDR      r0,[r4,#0x24]
00000c  b908              CBNZ     r0,|L5.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L5.20|
                  |L5.18|
000012  2000              MOVS     r0,#0
                  |L5.20|
000014  b938              CBNZ     r0,|L5.38|
;;;1735   				{
;;;1736   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000016  f1040024          ADD      r0,r4,#0x24
00001a  f7fffffe          BL       xTaskRemoveFromEventList
00001e  b118              CBZ      r0,|L5.40|
;;;1737   					{
;;;1738   						/* The task waiting has a higher priority so record that a
;;;1739   						context	switch is required. */
;;;1740   						vTaskMissedYield();
000020  f7fffffe          BL       vTaskMissedYield
000024  e000              B        |L5.40|
                  |L5.38|
;;;1741   					}
;;;1742   					else
;;;1743   					{
;;;1744   						mtCOVERAGE_TEST_MARKER();
;;;1745   					}
;;;1746   				}
;;;1747   				else
;;;1748   				{
;;;1749   					break;
000026  e005              B        |L5.52|
                  |L5.40|
;;;1750   				}
;;;1751   			}
;;;1752   			#endif /* configUSE_QUEUE_SETS */
;;;1753   
;;;1754   			--( pxQueue->xTxLock );
000028  6ca0              LDR      r0,[r4,#0x48]
00002a  1e40              SUBS     r0,r0,#1
00002c  64a0              STR      r0,[r4,#0x48]
                  |L5.46|
00002e  6ca0              LDR      r0,[r4,#0x48]         ;1687
000030  2800              CMP      r0,#0                 ;1687
000032  dcea              BGT      |L5.10|
                  |L5.52|
000034  bf00              NOP                            ;1749
;;;1755   		}
;;;1756   
;;;1757   		pxQueue->xTxLock = queueUNLOCKED;
000036  f04f30ff          MOV      r0,#0xffffffff
00003a  64a0              STR      r0,[r4,#0x48]
;;;1758   	}
;;;1759   	taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;1760   
;;;1761   	/* Do the same for the Rx lock. */
;;;1762   	taskENTER_CRITICAL();
000040  f7fffffe          BL       vPortEnterCritical
;;;1763   	{
;;;1764   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
000044  e011              B        |L5.106|
                  |L5.70|
;;;1765   		{
;;;1766   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000046  6920              LDR      r0,[r4,#0x10]
000048  b908              CBNZ     r0,|L5.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L5.80|
                  |L5.78|
00004e  2000              MOVS     r0,#0
                  |L5.80|
000050  b950              CBNZ     r0,|L5.104|
;;;1767   			{
;;;1768   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000052  f1040010          ADD      r0,r4,#0x10
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  b108              CBZ      r0,|L5.96|
;;;1769   				{
;;;1770   					vTaskMissedYield();
00005c  f7fffffe          BL       vTaskMissedYield
                  |L5.96|
;;;1771   				}
;;;1772   				else
;;;1773   				{
;;;1774   					mtCOVERAGE_TEST_MARKER();
;;;1775   				}
;;;1776   
;;;1777   				--( pxQueue->xRxLock );
000060  6c60              LDR      r0,[r4,#0x44]
000062  1e40              SUBS     r0,r0,#1
000064  6460              STR      r0,[r4,#0x44]
000066  e000              B        |L5.106|
                  |L5.104|
;;;1778   			}
;;;1779   			else
;;;1780   			{
;;;1781   				break;
000068  e002              B        |L5.112|
                  |L5.106|
00006a  6c60              LDR      r0,[r4,#0x44]         ;1764
00006c  2800              CMP      r0,#0                 ;1764
00006e  dcea              BGT      |L5.70|
                  |L5.112|
000070  bf00              NOP      
;;;1782   			}
;;;1783   		}
;;;1784   
;;;1785   		pxQueue->xRxLock = queueUNLOCKED;
000072  f04f30ff          MOV      r0,#0xffffffff
000076  6460              STR      r0,[r4,#0x44]
;;;1786   	}
;;;1787   	taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;1788   }
00007c  bd10              POP      {r4,pc}
;;;1789   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1487   
;;;1488   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1489   {
000002  4604              MOV      r4,r0
;;;1490   UBaseType_t uxReturn;
;;;1491   
;;;1492   	configASSERT( xQueue );
000004  b91c              CBNZ     r4,|L6.14|
000006  f7fffffe          BL       ulPortSetInterruptMask
00000a  bf00              NOP      
                  |L6.12|
00000c  e7fe              B        |L6.12|
                  |L6.14|
;;;1493   
;;;1494   	taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1495   	{
;;;1496   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000012  6ba5              LDR      r5,[r4,#0x38]
;;;1497   	}
;;;1498   	taskEXIT_CRITICAL();
000014  f7fffffe          BL       vPortExitCritical
;;;1499   
;;;1500   	return uxReturn;
000018  4628              MOV      r0,r5
;;;1501   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00001a  bd70              POP      {r4-r6,pc}
;;;1502   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1521   
;;;1522   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1523   {
000002  4604              MOV      r4,r0
;;;1524   UBaseType_t uxReturn;
;;;1525   
;;;1526   	configASSERT( xQueue );
000004  b91c              CBNZ     r4,|L7.14|
000006  f7fffffe          BL       ulPortSetInterruptMask
00000a  bf00              NOP      
                  |L7.12|
00000c  e7fe              B        |L7.12|
                  |L7.14|
;;;1527   
;;;1528   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00000e  6ba5              LDR      r5,[r4,#0x38]
;;;1529   
;;;1530   	return uxReturn;
000010  4628              MOV      r0,r5
;;;1531   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000012  bd70              POP      {r4-r6,pc}
;;;1532   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1503   
;;;1504   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1505   {
000002  4604              MOV      r4,r0
;;;1506   UBaseType_t uxReturn;
;;;1507   Queue_t *pxQueue;
;;;1508   
;;;1509   	pxQueue = ( Queue_t * ) xQueue;
000004  4625              MOV      r5,r4
;;;1510   	configASSERT( pxQueue );
000006  b91d              CBNZ     r5,|L8.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L8.14|
00000e  e7fe              B        |L8.14|
                  |L8.16|
;;;1511   
;;;1512   	taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1513   	{
;;;1514   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000014  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000018  1a46              SUBS     r6,r0,r1
;;;1515   	}
;;;1516   	taskEXIT_CRITICAL();
00001a  f7fffffe          BL       vPortExitCritical
;;;1517   
;;;1518   	return uxReturn;
00001e  4630              MOV      r0,r6
;;;1519   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000020  bd70              POP      {r4-r6,pc}
;;;1520   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1533   
;;;1534   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1535   {
000002  4605              MOV      r5,r0
;;;1536   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000004  462c              MOV      r4,r5
;;;1537   
;;;1538   	configASSERT( pxQueue );
000006  b91c              CBNZ     r4,|L9.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L9.14|
00000e  e7fe              B        |L9.14|
                  |L9.16|
;;;1539   
;;;1540   	traceQUEUE_DELETE( pxQueue );
;;;1541   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1542   	{
;;;1543   		vQueueUnregisterQueue( pxQueue );
;;;1544   	}
;;;1545   	#endif
;;;1546   	if( pxQueue->pcHead != NULL )
000010  6820              LDR      r0,[r4,#0]
000012  b110              CBZ      r0,|L9.26|
;;;1547   	{
;;;1548   		vPortFree( pxQueue->pcHead );
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       vPortFree
                  |L9.26|
;;;1549   	}
;;;1550   	vPortFree( pxQueue );
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       vPortFree
;;;1551   }
000020  bd70              POP      {r4-r6,pc}
;;;1552   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;365    
;;;366    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  b570              PUSH     {r4-r6,lr}
;;;367    	{
000002  4605              MOV      r5,r0
;;;368    	Queue_t *pxNewQueue;
;;;369    
;;;370    		/* Prevent compiler warnings about unused parameters if
;;;371    		configUSE_TRACE_FACILITY does not equal 1. */
;;;372    		( void ) ucQueueType;
;;;373    
;;;374    		/* Allocate the new queue structure. */
;;;375    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
000004  204c              MOVS     r0,#0x4c
000006  f7fffffe          BL       pvPortMalloc
00000a  4604              MOV      r4,r0
;;;376    		if( pxNewQueue != NULL )
00000c  b1d4              CBZ      r4,|L10.68|
;;;377    		{
;;;378    			/* Information required for priority inheritance. */
;;;379    			pxNewQueue->pxMutexHolder = NULL;
00000e  2000              MOVS     r0,#0
000010  6060              STR      r0,[r4,#4]
;;;380    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
000012  6020              STR      r0,[r4,#0]
;;;381    
;;;382    			/* Queues used as a mutex no data is actually copied into or out
;;;383    			of the queue. */
;;;384    			pxNewQueue->pcWriteTo = NULL;
000014  60a0              STR      r0,[r4,#8]
;;;385    			pxNewQueue->u.pcReadFrom = NULL;
000016  60e0              STR      r0,[r4,#0xc]
;;;386    
;;;387    			/* Each mutex has a length of 1 (like a binary semaphore) and
;;;388    			an item size of 0 as nothing is actually copied into or out
;;;389    			of the mutex. */
;;;390    			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000018  63a0              STR      r0,[r4,#0x38]
;;;391    			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
00001a  2001              MOVS     r0,#1
00001c  63e0              STR      r0,[r4,#0x3c]
;;;392    			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
00001e  2000              MOVS     r0,#0
000020  6420              STR      r0,[r4,#0x40]
;;;393    			pxNewQueue->xRxLock = queueUNLOCKED;
000022  1e40              SUBS     r0,r0,#1
000024  6460              STR      r0,[r4,#0x44]
;;;394    			pxNewQueue->xTxLock = queueUNLOCKED;
000026  64a0              STR      r0,[r4,#0x48]
;;;395    
;;;396    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;397    			{
;;;398    				pxNewQueue->ucQueueType = ucQueueType;
;;;399    			}
;;;400    			#endif
;;;401    
;;;402    			#if ( configUSE_QUEUE_SETS == 1 )
;;;403    			{
;;;404    				pxNewQueue->pxQueueSetContainer = NULL;
;;;405    			}
;;;406    			#endif
;;;407    
;;;408    			/* Ensure the event queues start with the correct state. */
;;;409    			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
000028  f1040010          ADD      r0,r4,#0x10
00002c  f7fffffe          BL       vListInitialise
;;;410    			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
000030  f1040024          ADD      r0,r4,#0x24
000034  f7fffffe          BL       vListInitialise
;;;411    
;;;412    			traceCREATE_MUTEX( pxNewQueue );
;;;413    
;;;414    			/* Start with the semaphore in the expected state. */
;;;415    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
000038  2300              MOVS     r3,#0
00003a  461a              MOV      r2,r3
00003c  4619              MOV      r1,r3
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       xQueueGenericSend
                  |L10.68|
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			traceCREATE_MUTEX_FAILED();
;;;420    		}
;;;421    
;;;422    		configASSERT( pxNewQueue );
000044  b91c              CBNZ     r4,|L10.78|
000046  f7fffffe          BL       ulPortSetInterruptMask
00004a  bf00              NOP      
                  |L10.76|
00004c  e7fe              B        |L10.76|
                  |L10.78|
;;;423    		return pxNewQueue;
00004e  4620              MOV      r0,r4
;;;424    	}
000050  bd70              POP      {r4-r6,pc}
;;;425    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;297    
;;;298    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;299    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
;;;300    Queue_t *pxNewQueue;
;;;301    size_t xQueueSizeInBytes;
;;;302    QueueHandle_t xReturn = NULL;
00000a  f04f0800          MOV      r8,#0
;;;303    
;;;304    	/* Remove compiler warnings about unused parameters should
;;;305    	configUSE_TRACE_FACILITY not be set to 1. */
;;;306    	( void ) ucQueueType;
;;;307    
;;;308    	/* Allocate the new queue structure. */
;;;309    	if( uxQueueLength > ( UBaseType_t ) 0 )
00000e  b1c5              CBZ      r5,|L11.66|
;;;310    	{
;;;311    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
000010  204c              MOVS     r0,#0x4c
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;312    		if( pxNewQueue != NULL )
000018  b19c              CBZ      r4,|L11.66|
;;;313    		{
;;;314    			/* Create the list of pointers to queue items.  The queue is one byte
;;;315    			longer than asked for to make wrap checking easier/faster. */
;;;316    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001a  fb05f006          MUL      r0,r5,r6
00001e  1c47              ADDS     r7,r0,#1
;;;317    
;;;318    			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       pvPortMalloc
000026  6020              STR      r0,[r4,#0]
;;;319    			if( pxNewQueue->pcHead != NULL )
000028  6820              LDR      r0,[r4,#0]
00002a  b138              CBZ      r0,|L11.60|
;;;320    			{
;;;321    				/* Initialise the queue members as described above where the
;;;322    				queue type is defined. */
;;;323    				pxNewQueue->uxLength = uxQueueLength;
00002c  63e5              STR      r5,[r4,#0x3c]
;;;324    				pxNewQueue->uxItemSize = uxItemSize;
00002e  6426              STR      r6,[r4,#0x40]
;;;325    				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
000030  2101              MOVS     r1,#1
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       xQueueGenericReset
;;;326    
;;;327    				#if ( configUSE_TRACE_FACILITY == 1 )
;;;328    				{
;;;329    					pxNewQueue->ucQueueType = ucQueueType;
;;;330    				}
;;;331    				#endif /* configUSE_TRACE_FACILITY */
;;;332    
;;;333    				#if( configUSE_QUEUE_SETS == 1 )
;;;334    				{
;;;335    					pxNewQueue->pxQueueSetContainer = NULL;
;;;336    				}
;;;337    				#endif /* configUSE_QUEUE_SETS */
;;;338    
;;;339    				traceQUEUE_CREATE( pxNewQueue );
;;;340    				xReturn = pxNewQueue;
000038  46a0              MOV      r8,r4
00003a  e002              B        |L11.66|
                  |L11.60|
;;;341    			}
;;;342    			else
;;;343    			{
;;;344    				traceQUEUE_CREATE_FAILED( ucQueueType );
;;;345    				vPortFree( pxNewQueue );
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       vPortFree
                  |L11.66|
;;;346    			}
;;;347    		}
;;;348    		else
;;;349    		{
;;;350    			mtCOVERAGE_TEST_MARKER();
;;;351    		}
;;;352    	}
;;;353    	else
;;;354    	{
;;;355    		mtCOVERAGE_TEST_MARKER();
;;;356    	}
;;;357    
;;;358    	configASSERT( xReturn );
000042  f1b80f00          CMP      r8,#0
000046  d103              BNE      |L11.80|
000048  f7fffffe          BL       ulPortSetInterruptMask
00004c  bf00              NOP      
                  |L11.78|
00004e  e7fe              B        |L11.78|
                  |L11.80|
;;;359    
;;;360    	return xReturn;
000050  4640              MOV      r0,r8
;;;361    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;362    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericReceive||, CODE, READONLY, ALIGN=1

                  xQueueGenericReceive PROC
;;;1158   
;;;1159   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;1160   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  461f              MOV      r7,r3
;;;1161   BaseType_t xEntryTimeSet = pdFALSE;
00000c  f04f0900          MOV      r9,#0
;;;1162   TimeOut_t xTimeOut;
;;;1163   int8_t *pcOriginalReadPosition;
;;;1164   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  462c              MOV      r4,r5
;;;1165   
;;;1166   	configASSERT( pxQueue );
000012  b91c              CBNZ     r4,|L12.28|
000014  f7fffffe          BL       ulPortSetInterruptMask
000018  bf00              NOP      
                  |L12.26|
00001a  e7fe              B        |L12.26|
                  |L12.28|
;;;1167   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00001c  b90e              CBNZ     r6,|L12.34|
00001e  6c20              LDR      r0,[r4,#0x40]
000020  b908              CBNZ     r0,|L12.38|
                  |L12.34|
000022  2001              MOVS     r0,#1
000024  e000              B        |L12.40|
                  |L12.38|
000026  2000              MOVS     r0,#0
                  |L12.40|
000028  b918              CBNZ     r0,|L12.50|
00002a  f7fffffe          BL       ulPortSetInterruptMask
00002e  bf00              NOP      
                  |L12.48|
000030  e7fe              B        |L12.48|
                  |L12.50|
;;;1168   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1169   	{
;;;1170   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1171   	}
;;;1172   	#endif
;;;1173   
;;;1174   	/* This function relaxes the coding standard somewhat to allow return
;;;1175   	statements within the function itself.  This is done in the interest
;;;1176   	of execution time efficiency. */
;;;1177   
;;;1178   	for( ;; )
000032  bf00              NOP      
                  |L12.52|
;;;1179   	{
;;;1180   		taskENTER_CRITICAL();
000034  f7fffffe          BL       vPortEnterCritical
;;;1181   		{
;;;1182   			/* Is there data in the queue now?  To be running we must be
;;;1183   			the highest priority task wanting to access the queue. */
;;;1184   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000038  6ba0              LDR      r0,[r4,#0x38]
00003a  b390              CBZ      r0,|L12.162|
;;;1185   			{
;;;1186   				/* Remember the read position in case the queue is only being
;;;1187   				peeked. */
;;;1188   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00003c  f8d4800c          LDR      r8,[r4,#0xc]
;;;1189   
;;;1190   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000040  4631              MOV      r1,r6
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       prvCopyDataFromQueue
;;;1191   
;;;1192   				if( xJustPeeking == pdFALSE )
000048  b9b7              CBNZ     r7,|L12.120|
;;;1193   				{
;;;1194   					traceQUEUE_RECEIVE( pxQueue );
;;;1195   
;;;1196   					/* Actually removing data, not just peeking. */
;;;1197   					--( pxQueue->uxMessagesWaiting );
00004a  6ba0              LDR      r0,[r4,#0x38]
00004c  1e40              SUBS     r0,r0,#1
00004e  63a0              STR      r0,[r4,#0x38]
;;;1198   
;;;1199   					#if ( configUSE_MUTEXES == 1 )
;;;1200   					{
;;;1201   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000050  6820              LDR      r0,[r4,#0]
000052  b910              CBNZ     r0,|L12.90|
;;;1202   						{
;;;1203   							/* Record the information required to implement
;;;1204   							priority inheritance should it become necessary. */
;;;1205   							pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
000054  f7fffffe          BL       xTaskGetCurrentTaskHandle
000058  6060              STR      r0,[r4,#4]
                  |L12.90|
;;;1206   						}
;;;1207   						else
;;;1208   						{
;;;1209   							mtCOVERAGE_TEST_MARKER();
;;;1210   						}
;;;1211   					}
;;;1212   					#endif
;;;1213   
;;;1214   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00005a  6920              LDR      r0,[r4,#0x10]
00005c  b908              CBNZ     r0,|L12.98|
00005e  2001              MOVS     r0,#1
000060  e000              B        |L12.100|
                  |L12.98|
000062  2000              MOVS     r0,#0
                  |L12.100|
000064  b9b8              CBNZ     r0,|L12.150|
;;;1215   					{
;;;1216   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000066  f1040010          ADD      r0,r4,#0x10
00006a  f7fffffe          BL       xTaskRemoveFromEventList
00006e  2801              CMP      r0,#1
000070  d111              BNE      |L12.150|
;;;1217   						{
;;;1218   							queueYIELD_IF_USING_PREEMPTION();
000072  f7fffffe          BL       vPortYield
000076  e00e              B        |L12.150|
                  |L12.120|
;;;1219   						}
;;;1220   						else
;;;1221   						{
;;;1222   							mtCOVERAGE_TEST_MARKER();
;;;1223   						}
;;;1224   					}
;;;1225   					else
;;;1226   					{
;;;1227   						mtCOVERAGE_TEST_MARKER();
;;;1228   					}
;;;1229   				}
;;;1230   				else
;;;1231   				{
;;;1232   					traceQUEUE_PEEK( pxQueue );
;;;1233   
;;;1234   					/* The data is not being removed, so reset the read
;;;1235   					pointer. */
;;;1236   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
000078  f8c4800c          STR      r8,[r4,#0xc]
;;;1237   
;;;1238   					/* The data is being left in the queue, so see if there are
;;;1239   					any other tasks waiting for the data. */
;;;1240   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00007c  6a60              LDR      r0,[r4,#0x24]
00007e  b908              CBNZ     r0,|L12.132|
000080  2001              MOVS     r0,#1
000082  e000              B        |L12.134|
                  |L12.132|
000084  2000              MOVS     r0,#0
                  |L12.134|
000086  b930              CBNZ     r0,|L12.150|
;;;1241   					{
;;;1242   						/* Tasks that are removed from the event list will get added to
;;;1243   						the pending ready list as the scheduler is still suspended. */
;;;1244   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000088  f1040024          ADD      r0,r4,#0x24
00008c  f7fffffe          BL       xTaskRemoveFromEventList
000090  b108              CBZ      r0,|L12.150|
;;;1245   						{
;;;1246   							/* The task waiting has a higher priority than this task. */
;;;1247   							queueYIELD_IF_USING_PREEMPTION();
000092  f7fffffe          BL       vPortYield
                  |L12.150|
;;;1248   						}
;;;1249   						else
;;;1250   						{
;;;1251   							mtCOVERAGE_TEST_MARKER();
;;;1252   						}
;;;1253   					}
;;;1254   					else
;;;1255   					{
;;;1256   						mtCOVERAGE_TEST_MARKER();
;;;1257   					}
;;;1258   				}
;;;1259   
;;;1260   				taskEXIT_CRITICAL();
000096  f7fffffe          BL       vPortExitCritical
;;;1261   				return pdPASS;
00009a  2001              MOVS     r0,#1
                  |L12.156|
;;;1262   			}
;;;1263   			else
;;;1264   			{
;;;1265   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1266   				{
;;;1267   					/* The queue was empty and no block time is specified (or
;;;1268   					the block time has expired) so leave now. */
;;;1269   					taskEXIT_CRITICAL();
;;;1270   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1271   					return errQUEUE_EMPTY;
;;;1272   				}
;;;1273   				else if( xEntryTimeSet == pdFALSE )
;;;1274   				{
;;;1275   					/* The queue was empty and a block time was specified so
;;;1276   					configure the timeout structure. */
;;;1277   					vTaskSetTimeOutState( &xTimeOut );
;;;1278   					xEntryTimeSet = pdTRUE;
;;;1279   				}
;;;1280   				else
;;;1281   				{
;;;1282   					/* Entry time was already set. */
;;;1283   					mtCOVERAGE_TEST_MARKER();
;;;1284   				}
;;;1285   			}
;;;1286   		}
;;;1287   		taskEXIT_CRITICAL();
;;;1288   
;;;1289   		/* Interrupts and other tasks can send to and receive from the queue
;;;1290   		now the critical section has been exited. */
;;;1291   
;;;1292   		vTaskSuspendAll();
;;;1293   		prvLockQueue( pxQueue );
;;;1294   
;;;1295   		/* Update the timeout state to see if it has expired yet. */
;;;1296   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1297   		{
;;;1298   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1299   			{
;;;1300   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1301   
;;;1302   				#if ( configUSE_MUTEXES == 1 )
;;;1303   				{
;;;1304   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1305   					{
;;;1306   						taskENTER_CRITICAL();
;;;1307   						{
;;;1308   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1309   						}
;;;1310   						taskEXIT_CRITICAL();
;;;1311   					}
;;;1312   					else
;;;1313   					{
;;;1314   						mtCOVERAGE_TEST_MARKER();
;;;1315   					}
;;;1316   				}
;;;1317   				#endif
;;;1318   
;;;1319   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1320   				prvUnlockQueue( pxQueue );
;;;1321   				if( xTaskResumeAll() == pdFALSE )
;;;1322   				{
;;;1323   					portYIELD_WITHIN_API();
;;;1324   				}
;;;1325   				else
;;;1326   				{
;;;1327   					mtCOVERAGE_TEST_MARKER();
;;;1328   				}
;;;1329   			}
;;;1330   			else
;;;1331   			{
;;;1332   				/* Try again. */
;;;1333   				prvUnlockQueue( pxQueue );
;;;1334   				( void ) xTaskResumeAll();
;;;1335   			}
;;;1336   		}
;;;1337   		else
;;;1338   		{
;;;1339   			prvUnlockQueue( pxQueue );
;;;1340   			( void ) xTaskResumeAll();
;;;1341   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1342   			return errQUEUE_EMPTY;
;;;1343   		}
;;;1344   	}
;;;1345   }
00009c  b007              ADD      sp,sp,#0x1c
00009e  e8bd83f0          POP      {r4-r9,pc}
                  |L12.162|
0000a2  e7ff              B        |L12.164|
                  |L12.164|
0000a4  9805              LDR      r0,[sp,#0x14]         ;1265
0000a6  b918              CBNZ     r0,|L12.176|
0000a8  f7fffffe          BL       vPortExitCritical
0000ac  2000              MOVS     r0,#0                 ;1271
0000ae  e7f5              B        |L12.156|
                  |L12.176|
0000b0  f1b90f00          CMP      r9,#0                 ;1273
0000b4  d104              BNE      |L12.192|
0000b6  a801              ADD      r0,sp,#4              ;1277
0000b8  f7fffffe          BL       vTaskSetTimeOutState
0000bc  f04f0901          MOV      r9,#1                 ;1278
                  |L12.192|
0000c0  f7fffffe          BL       vPortExitCritical
0000c4  f7fffffe          BL       vTaskSuspendAll
0000c8  f7fffffe          BL       vPortEnterCritical
0000cc  6c60              LDR      r0,[r4,#0x44]         ;1293
0000ce  1c40              ADDS     r0,r0,#1              ;1293
0000d0  b908              CBNZ     r0,|L12.214|
0000d2  2000              MOVS     r0,#0                 ;1293
0000d4  6460              STR      r0,[r4,#0x44]         ;1293
                  |L12.214|
0000d6  6ca0              LDR      r0,[r4,#0x48]         ;1293
0000d8  1c40              ADDS     r0,r0,#1              ;1293
0000da  b908              CBNZ     r0,|L12.224|
0000dc  2000              MOVS     r0,#0                 ;1293
0000de  64a0              STR      r0,[r4,#0x48]         ;1293
                  |L12.224|
0000e0  f7fffffe          BL       vPortExitCritical
0000e4  a905              ADD      r1,sp,#0x14           ;1296
0000e6  a801              ADD      r0,sp,#4              ;1296
0000e8  f7fffffe          BL       xTaskCheckForTimeOut
0000ec  bb08              CBNZ     r0,|L12.306|
0000ee  4620              MOV      r0,r4                 ;1298
0000f0  f7fffffe          BL       prvIsQueueEmpty
0000f4  b1b8              CBZ      r0,|L12.294|
0000f6  6820              LDR      r0,[r4,#0]            ;1304
0000f8  b930              CBNZ     r0,|L12.264|
0000fa  f7fffffe          BL       vPortEnterCritical
0000fe  6860              LDR      r0,[r4,#4]            ;1308
000100  f7fffffe          BL       vTaskPriorityInherit
000104  f7fffffe          BL       vPortExitCritical
                  |L12.264|
000108  f1040024          ADD      r0,r4,#0x24           ;1319
00010c  9905              LDR      r1,[sp,#0x14]         ;1319
00010e  f7fffffe          BL       vTaskPlaceOnEventList
000112  4620              MOV      r0,r4                 ;1320
000114  f7fffffe          BL       prvUnlockQueue
000118  f7fffffe          BL       xTaskResumeAll
00011c  2800              CMP      r0,#0                 ;1321
00011e  d189              BNE      |L12.52|
000120  f7fffffe          BL       vPortYield
000124  e786              B        |L12.52|
                  |L12.294|
000126  4620              MOV      r0,r4                 ;1333
000128  f7fffffe          BL       prvUnlockQueue
00012c  f7fffffe          BL       xTaskResumeAll
000130  e780              B        |L12.52|
                  |L12.306|
000132  4620              MOV      r0,r4                 ;1339
000134  f7fffffe          BL       prvUnlockQueue
000138  f7fffffe          BL       xTaskResumeAll
00013c  2000              MOVS     r0,#0                 ;1342
00013e  e7ad              B        |L12.156|
;;;1346   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=1

                  xQueueGenericReset PROC
;;;244    
;;;245    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;246    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;247    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000006  462c              MOV      r4,r5
;;;248    
;;;249    	configASSERT( pxQueue );
000008  b91c              CBNZ     r4,|L13.18|
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  bf00              NOP      
                  |L13.16|
000010  e7fe              B        |L13.16|
                  |L13.18|
;;;250    
;;;251    	taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;252    	{
;;;253    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
000016  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00001a  6820              LDR      r0,[r4,#0]
00001c  fb010002          MLA      r0,r1,r2,r0
000020  6060              STR      r0,[r4,#4]
;;;254    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000022  2000              MOVS     r0,#0
000024  63a0              STR      r0,[r4,#0x38]
;;;255    		pxQueue->pcWriteTo = pxQueue->pcHead;
000026  6820              LDR      r0,[r4,#0]
000028  60a0              STR      r0,[r4,#8]
;;;256    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00002a  6be0              LDR      r0,[r4,#0x3c]
00002c  1e40              SUBS     r0,r0,#1
00002e  6c22              LDR      r2,[r4,#0x40]
000030  6821              LDR      r1,[r4,#0]
000032  fb001002          MLA      r0,r0,r2,r1
000036  60e0              STR      r0,[r4,#0xc]
;;;257    		pxQueue->xRxLock = queueUNLOCKED;
000038  f04f30ff          MOV      r0,#0xffffffff
00003c  6460              STR      r0,[r4,#0x44]
;;;258    		pxQueue->xTxLock = queueUNLOCKED;
00003e  64a0              STR      r0,[r4,#0x48]
;;;259    
;;;260    		if( xNewQueue == pdFALSE )
000040  b976              CBNZ     r6,|L13.96|
;;;261    		{
;;;262    			/* If there are tasks blocked waiting to read from the queue, then
;;;263    			the tasks will remain blocked as after this function exits the queue
;;;264    			will still be empty.  If there are tasks blocked waiting to write to
;;;265    			the queue, then one should be unblocked as after this function exits
;;;266    			it will be possible to write to it. */
;;;267    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000042  6920              LDR      r0,[r4,#0x10]
000044  b908              CBNZ     r0,|L13.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L13.76|
                  |L13.74|
00004a  2000              MOVS     r0,#0
                  |L13.76|
00004c  b980              CBNZ     r0,|L13.112|
;;;268    			{
;;;269    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
00004e  f1040010          ADD      r0,r4,#0x10
000052  f7fffffe          BL       xTaskRemoveFromEventList
000056  2801              CMP      r0,#1
000058  d10a              BNE      |L13.112|
;;;270    				{
;;;271    					queueYIELD_IF_USING_PREEMPTION();
00005a  f7fffffe          BL       vPortYield
00005e  e007              B        |L13.112|
                  |L13.96|
;;;272    				}
;;;273    				else
;;;274    				{
;;;275    					mtCOVERAGE_TEST_MARKER();
;;;276    				}
;;;277    			}
;;;278    			else
;;;279    			{
;;;280    				mtCOVERAGE_TEST_MARKER();
;;;281    			}
;;;282    		}
;;;283    		else
;;;284    		{
;;;285    			/* Ensure the event queues start in the correct state. */
;;;286    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000060  f1040010          ADD      r0,r4,#0x10
000064  f7fffffe          BL       vListInitialise
;;;287    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000068  f1040024          ADD      r0,r4,#0x24
00006c  f7fffffe          BL       vListInitialise
                  |L13.112|
;;;288    		}
;;;289    	}
;;;290    	taskEXIT_CRITICAL();
000070  f7fffffe          BL       vPortExitCritical
;;;291    
;;;292    	/* A value is returned for calling semantic consistency with previous
;;;293    	versions. */
;;;294    	return pdPASS;
000074  2001              MOVS     r0,#1
;;;295    }
000076  bd70              POP      {r4-r6,pc}
;;;296    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=1

                  xQueueGenericSend PROC
;;;582    
;;;583    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;584    {
000004  b082              SUB      sp,sp,#8
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  461d              MOV      r5,r3
;;;585    BaseType_t xEntryTimeSet = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;586    TimeOut_t xTimeOut;
;;;587    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  4634              MOV      r4,r6
;;;588    
;;;589    	configASSERT( pxQueue );
000012  b91c              CBNZ     r4,|L14.28|
000014  f7fffffe          BL       ulPortSetInterruptMask
000018  bf00              NOP      
                  |L14.26|
00001a  e7fe              B        |L14.26|
                  |L14.28|
;;;590    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00001c  b90f              CBNZ     r7,|L14.34|
00001e  6c20              LDR      r0,[r4,#0x40]
000020  b908              CBNZ     r0,|L14.38|
                  |L14.34|
000022  2001              MOVS     r0,#1
000024  e000              B        |L14.40|
                  |L14.38|
000026  2000              MOVS     r0,#0
                  |L14.40|
000028  b918              CBNZ     r0,|L14.50|
00002a  f7fffffe          BL       ulPortSetInterruptMask
00002e  bf00              NOP      
                  |L14.48|
000030  e7fe              B        |L14.48|
                  |L14.50|
;;;591    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000032  2d02              CMP      r5,#2
000034  d102              BNE      |L14.60|
000036  6be0              LDR      r0,[r4,#0x3c]
000038  2801              CMP      r0,#1
00003a  d101              BNE      |L14.64|
                  |L14.60|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L14.66|
                  |L14.64|
000040  2000              MOVS     r0,#0
                  |L14.66|
000042  b918              CBNZ     r0,|L14.76|
000044  f7fffffe          BL       ulPortSetInterruptMask
000048  bf00              NOP      
                  |L14.74|
00004a  e7fe              B        |L14.74|
                  |L14.76|
;;;592    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;593    	{
;;;594    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;595    	}
;;;596    	#endif
;;;597    
;;;598    
;;;599    	/* This function relaxes the coding standard somewhat to allow return
;;;600    	statements within the function itself.  This is done in the interest
;;;601    	of execution time efficiency. */
;;;602    	for( ;; )
00004c  bf00              NOP      
                  |L14.78|
;;;603    	{
;;;604    		taskENTER_CRITICAL();
00004e  f7fffffe          BL       vPortEnterCritical
;;;605    		{
;;;606    			/* Is there room on the queue now?  The running task must be
;;;607    			the highest priority task wanting to access the queue.  If
;;;608    			the head item in the queue is to be overwritten then it does
;;;609    			not matter if the queue is full. */
;;;610    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000052  6ba0              LDR      r0,[r4,#0x38]
000054  6be1              LDR      r1,[r4,#0x3c]
000056  4288              CMP      r0,r1
000058  d301              BCC      |L14.94|
00005a  2d02              CMP      r5,#2
00005c  d118              BNE      |L14.144|
                  |L14.94|
;;;611    			{
;;;612    				traceQUEUE_SEND( pxQueue );
;;;613    				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00005e  462a              MOV      r2,r5
000060  4639              MOV      r1,r7
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       prvCopyDataToQueue
;;;614    
;;;615    				#if ( configUSE_QUEUE_SETS == 1 )
;;;616    				{
;;;617    					if( pxQueue->pxQueueSetContainer != NULL )
;;;618    					{
;;;619    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;620    						{
;;;621    							/* The queue is a member of a queue set, and posting
;;;622    							to the queue set caused a higher priority task to
;;;623    							unblock. A context switch is required. */
;;;624    							queueYIELD_IF_USING_PREEMPTION();
;;;625    						}
;;;626    						else
;;;627    						{
;;;628    							mtCOVERAGE_TEST_MARKER();
;;;629    						}
;;;630    					}
;;;631    					else
;;;632    					{
;;;633    						/* If there was a task waiting for data to arrive on the
;;;634    						queue then unblock it now. */
;;;635    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;636    						{
;;;637    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;638    							{
;;;639    								/* The unblocked task has a priority higher than
;;;640    								our own so yield immediately.  Yes it is ok to
;;;641    								do this from within the critical section - the
;;;642    								kernel takes care of that. */
;;;643    								queueYIELD_IF_USING_PREEMPTION();
;;;644    							}
;;;645    							else
;;;646    							{
;;;647    								mtCOVERAGE_TEST_MARKER();
;;;648    							}
;;;649    						}
;;;650    						else
;;;651    						{
;;;652    							mtCOVERAGE_TEST_MARKER();
;;;653    						}
;;;654    					}
;;;655    				}
;;;656    				#else /* configUSE_QUEUE_SETS */
;;;657    				{
;;;658    					/* If there was a task waiting for data to arrive on the
;;;659    					queue then unblock it now. */
;;;660    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000068  6a60              LDR      r0,[r4,#0x24]
00006a  b908              CBNZ     r0,|L14.112|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L14.114|
                  |L14.112|
000070  2000              MOVS     r0,#0
                  |L14.114|
000072  b938              CBNZ     r0,|L14.132|
;;;661    					{
;;;662    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
000074  f1040024          ADD      r0,r4,#0x24
000078  f7fffffe          BL       xTaskRemoveFromEventList
00007c  2801              CMP      r0,#1
00007e  d101              BNE      |L14.132|
;;;663    						{
;;;664    							/* The unblocked task has a priority higher than
;;;665    							our own so yield immediately.  Yes it is ok to do
;;;666    							this from within the critical section - the kernel
;;;667    							takes care of that. */
;;;668    							queueYIELD_IF_USING_PREEMPTION();
000080  f7fffffe          BL       vPortYield
                  |L14.132|
;;;669    						}
;;;670    						else
;;;671    						{
;;;672    							mtCOVERAGE_TEST_MARKER();
;;;673    						}
;;;674    					}
;;;675    					else
;;;676    					{
;;;677    						mtCOVERAGE_TEST_MARKER();
;;;678    					}
;;;679    				}
;;;680    				#endif /* configUSE_QUEUE_SETS */
;;;681    
;;;682    				taskEXIT_CRITICAL();
000084  f7fffffe          BL       vPortExitCritical
;;;683    
;;;684    				/* Return to the original privilege level before exiting the
;;;685    				function. */
;;;686    				return pdPASS;
000088  2001              MOVS     r0,#1
                  |L14.138|
;;;687    			}
;;;688    			else
;;;689    			{
;;;690    				if( xTicksToWait == ( TickType_t ) 0 )
;;;691    				{
;;;692    					/* The queue was full and no block time is specified (or
;;;693    					the block time has expired) so leave now. */
;;;694    					taskEXIT_CRITICAL();
;;;695    
;;;696    					/* Return to the original privilege level before exiting
;;;697    					the function. */
;;;698    					traceQUEUE_SEND_FAILED( pxQueue );
;;;699    					return errQUEUE_FULL;
;;;700    				}
;;;701    				else if( xEntryTimeSet == pdFALSE )
;;;702    				{
;;;703    					/* The queue was full and a block time was specified so
;;;704    					configure the timeout structure. */
;;;705    					vTaskSetTimeOutState( &xTimeOut );
;;;706    					xEntryTimeSet = pdTRUE;
;;;707    				}
;;;708    				else
;;;709    				{
;;;710    					/* Entry time was already set. */
;;;711    					mtCOVERAGE_TEST_MARKER();
;;;712    				}
;;;713    			}
;;;714    		}
;;;715    		taskEXIT_CRITICAL();
;;;716    
;;;717    		/* Interrupts and other tasks can send to and receive from the queue
;;;718    		now the critical section has been exited. */
;;;719    
;;;720    		vTaskSuspendAll();
;;;721    		prvLockQueue( pxQueue );
;;;722    
;;;723    		/* Update the timeout state to see if it has expired yet. */
;;;724    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;725    		{
;;;726    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;727    			{
;;;728    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;729    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;730    
;;;731    				/* Unlocking the queue means queue events can effect the
;;;732    				event list.  It is possible	that interrupts occurring now
;;;733    				remove this task from the event	list again - but as the
;;;734    				scheduler is suspended the task will go onto the pending
;;;735    				ready last instead of the actual ready list. */
;;;736    				prvUnlockQueue( pxQueue );
;;;737    
;;;738    				/* Resuming the scheduler will move tasks from the pending
;;;739    				ready list into the ready list - so it is feasible that this
;;;740    				task is already in a ready list before it yields - in which
;;;741    				case the yield will not cause a context switch unless there
;;;742    				is also a higher priority task in the pending ready list. */
;;;743    				if( xTaskResumeAll() == pdFALSE )
;;;744    				{
;;;745    					portYIELD_WITHIN_API();
;;;746    				}
;;;747    			}
;;;748    			else
;;;749    			{
;;;750    				/* Try again. */
;;;751    				prvUnlockQueue( pxQueue );
;;;752    				( void ) xTaskResumeAll();
;;;753    			}
;;;754    		}
;;;755    		else
;;;756    		{
;;;757    			/* The timeout has expired. */
;;;758    			prvUnlockQueue( pxQueue );
;;;759    			( void ) xTaskResumeAll();
;;;760    
;;;761    			/* Return to the original privilege level before exiting the
;;;762    			function. */
;;;763    			traceQUEUE_SEND_FAILED( pxQueue );
;;;764    			return errQUEUE_FULL;
;;;765    		}
;;;766    	}
;;;767    }
00008a  b006              ADD      sp,sp,#0x18
00008c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.144|
000090  9804              LDR      r0,[sp,#0x10]         ;690
000092  b918              CBNZ     r0,|L14.156|
000094  f7fffffe          BL       vPortExitCritical
000098  2000              MOVS     r0,#0                 ;699
00009a  e7f6              B        |L14.138|
                  |L14.156|
00009c  f1b80f00          CMP      r8,#0                 ;701
0000a0  d104              BNE      |L14.172|
0000a2  4668              MOV      r0,sp                 ;705
0000a4  f7fffffe          BL       vTaskSetTimeOutState
0000a8  f04f0801          MOV      r8,#1                 ;706
                  |L14.172|
0000ac  f7fffffe          BL       vPortExitCritical
0000b0  f7fffffe          BL       vTaskSuspendAll
0000b4  f7fffffe          BL       vPortEnterCritical
0000b8  6c60              LDR      r0,[r4,#0x44]         ;721
0000ba  1c40              ADDS     r0,r0,#1              ;721
0000bc  b908              CBNZ     r0,|L14.194|
0000be  2000              MOVS     r0,#0                 ;721
0000c0  6460              STR      r0,[r4,#0x44]         ;721
                  |L14.194|
0000c2  6ca0              LDR      r0,[r4,#0x48]         ;721
0000c4  1c40              ADDS     r0,r0,#1              ;721
0000c6  b908              CBNZ     r0,|L14.204|
0000c8  2000              MOVS     r0,#0                 ;721
0000ca  64a0              STR      r0,[r4,#0x48]         ;721
                  |L14.204|
0000cc  f7fffffe          BL       vPortExitCritical
0000d0  a904              ADD      r1,sp,#0x10           ;724
0000d2  4668              MOV      r0,sp                 ;724
0000d4  f7fffffe          BL       xTaskCheckForTimeOut
0000d8  b9c0              CBNZ     r0,|L14.268|
0000da  4620              MOV      r0,r4                 ;726
0000dc  f7fffffe          BL       prvIsQueueFull
0000e0  b170              CBZ      r0,|L14.256|
0000e2  f1040010          ADD      r0,r4,#0x10           ;729
0000e6  9904              LDR      r1,[sp,#0x10]         ;729
0000e8  f7fffffe          BL       vTaskPlaceOnEventList
0000ec  4620              MOV      r0,r4                 ;736
0000ee  f7fffffe          BL       prvUnlockQueue
0000f2  f7fffffe          BL       xTaskResumeAll
0000f6  2800              CMP      r0,#0                 ;743
0000f8  d1a9              BNE      |L14.78|
0000fa  f7fffffe          BL       vPortYield
0000fe  e7a6              B        |L14.78|
                  |L14.256|
000100  4620              MOV      r0,r4                 ;751
000102  f7fffffe          BL       prvUnlockQueue
000106  f7fffffe          BL       xTaskResumeAll
00010a  e7a0              B        |L14.78|
                  |L14.268|
00010c  4620              MOV      r0,r4                 ;758
00010e  f7fffffe          BL       prvUnlockQueue
000112  f7fffffe          BL       xTaskResumeAll
000116  2000              MOVS     r0,#0                 ;764
000118  e7b7              B        |L14.138|
;;;768    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;1014   
;;;1015   BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1016   {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1017   BaseType_t xReturn;
;;;1018   UBaseType_t uxSavedInterruptStatus;
;;;1019   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000c  4634              MOV      r4,r6
;;;1020   
;;;1021   	configASSERT( pxQueue );
00000e  b91c              CBNZ     r4,|L15.24|
000010  f7fffffe          BL       ulPortSetInterruptMask
000014  bf00              NOP      
                  |L15.22|
000016  e7fe              B        |L15.22|
                  |L15.24|
;;;1022   	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000018  f1b90f00          CMP      r9,#0
00001c  d101              BNE      |L15.34|
00001e  6c20              LDR      r0,[r4,#0x40]
000020  b908              CBNZ     r0,|L15.38|
                  |L15.34|
000022  2001              MOVS     r0,#1
000024  e000              B        |L15.40|
                  |L15.38|
000026  2000              MOVS     r0,#0
                  |L15.40|
000028  b918              CBNZ     r0,|L15.50|
00002a  f7fffffe          BL       ulPortSetInterruptMask
00002e  bf00              NOP      
                  |L15.48|
000030  e7fe              B        |L15.48|
                  |L15.50|
;;;1023   	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000032  2d02              CMP      r5,#2
000034  d102              BNE      |L15.60|
000036  6be0              LDR      r0,[r4,#0x3c]
000038  2801              CMP      r0,#1
00003a  d101              BNE      |L15.64|
                  |L15.60|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L15.66|
                  |L15.64|
000040  2000              MOVS     r0,#0
                  |L15.66|
000042  b918              CBNZ     r0,|L15.76|
000044  f7fffffe          BL       ulPortSetInterruptMask
000048  bf00              NOP      
                  |L15.74|
00004a  e7fe              B        |L15.74|
                  |L15.76|
;;;1024   
;;;1025   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1026   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1027   	above the maximum system call priority are kept permanently enabled, even
;;;1028   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1029   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1030   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1031   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1032   	assigned a priority above the configured maximum system call priority.
;;;1033   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1034   	that have been assigned a priority at or (logically) below the maximum
;;;1035   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1036   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1037   	More information (albeit Cortex-M specific) is provided on the following
;;;1038   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1039   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00004c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1040   
;;;1041   	/* Similar to xQueueGenericSend, except we don't block if there is no room
;;;1042   	in the queue.  Also we don't directly wake a task that was blocked on a
;;;1043   	queue read, instead we return a flag to say whether a context switch is
;;;1044   	required or not (i.e. has a task with a higher priority than us been woken
;;;1045   	by this	post). */
;;;1046   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000050  f7fffffe          BL       ulPortSetInterruptMask
000054  4682              MOV      r10,r0
;;;1047   	{
;;;1048   		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000056  6ba0              LDR      r0,[r4,#0x38]
000058  6be1              LDR      r1,[r4,#0x3c]
00005a  4288              CMP      r0,r1
00005c  d301              BCC      |L15.98|
00005e  2d02              CMP      r5,#2
000060  d11c              BNE      |L15.156|
                  |L15.98|
;;;1049   		{
;;;1050   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1051   
;;;1052   			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000062  462a              MOV      r2,r5
000064  4649              MOV      r1,r9
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       prvCopyDataToQueue
;;;1053   
;;;1054   			/* If the queue is locked we do not alter the event list.  This will
;;;1055   			be done when the queue is unlocked later. */
;;;1056   			if( pxQueue->xTxLock == queueUNLOCKED )
00006c  6ca0              LDR      r0,[r4,#0x48]
00006e  1c40              ADDS     r0,r0,#1
000070  b970              CBNZ     r0,|L15.144|
;;;1057   			{
;;;1058   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1059   				{
;;;1060   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1061   					{
;;;1062   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;1063   						{
;;;1064   							/* The queue is a member of a queue set, and posting
;;;1065   							to the queue set caused a higher priority task to
;;;1066   							unblock.  A context switch is required. */
;;;1067   							if( pxHigherPriorityTaskWoken != NULL )
;;;1068   							{
;;;1069   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1070   							}
;;;1071   							else
;;;1072   							{
;;;1073   								mtCOVERAGE_TEST_MARKER();
;;;1074   							}
;;;1075   						}
;;;1076   						else
;;;1077   						{
;;;1078   							mtCOVERAGE_TEST_MARKER();
;;;1079   						}
;;;1080   					}
;;;1081   					else
;;;1082   					{
;;;1083   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1084   						{
;;;1085   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1086   							{
;;;1087   								/* The task waiting has a higher priority so record that a
;;;1088   								context	switch is required. */
;;;1089   								if( pxHigherPriorityTaskWoken != NULL )
;;;1090   								{
;;;1091   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1092   								}
;;;1093   								else
;;;1094   								{
;;;1095   									mtCOVERAGE_TEST_MARKER();
;;;1096   								}
;;;1097   							}
;;;1098   							else
;;;1099   							{
;;;1100   								mtCOVERAGE_TEST_MARKER();
;;;1101   							}
;;;1102   						}
;;;1103   						else
;;;1104   						{
;;;1105   							mtCOVERAGE_TEST_MARKER();
;;;1106   						}
;;;1107   					}
;;;1108   				}
;;;1109   				#else /* configUSE_QUEUE_SETS */
;;;1110   				{
;;;1111   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000072  6a60              LDR      r0,[r4,#0x24]
000074  b908              CBNZ     r0,|L15.122|
000076  2001              MOVS     r0,#1
000078  e000              B        |L15.124|
                  |L15.122|
00007a  2000              MOVS     r0,#0
                  |L15.124|
00007c  b958              CBNZ     r0,|L15.150|
;;;1112   					{
;;;1113   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00007e  f1040024          ADD      r0,r4,#0x24
000082  f7fffffe          BL       xTaskRemoveFromEventList
000086  b130              CBZ      r0,|L15.150|
;;;1114   						{
;;;1115   							/* The task waiting has a higher priority so record that a
;;;1116   							context	switch is required. */
;;;1117   							if( pxHigherPriorityTaskWoken != NULL )
000088  b12f              CBZ      r7,|L15.150|
;;;1118   							{
;;;1119   								*pxHigherPriorityTaskWoken = pdTRUE;
00008a  2001              MOVS     r0,#1
00008c  6038              STR      r0,[r7,#0]
00008e  e002              B        |L15.150|
                  |L15.144|
;;;1120   							}
;;;1121   							else
;;;1122   							{
;;;1123   								mtCOVERAGE_TEST_MARKER();
;;;1124   							}
;;;1125   						}
;;;1126   						else
;;;1127   						{
;;;1128   							mtCOVERAGE_TEST_MARKER();
;;;1129   						}
;;;1130   					}
;;;1131   					else
;;;1132   					{
;;;1133   						mtCOVERAGE_TEST_MARKER();
;;;1134   					}
;;;1135   				}
;;;1136   				#endif /* configUSE_QUEUE_SETS */
;;;1137   			}
;;;1138   			else
;;;1139   			{
;;;1140   				/* Increment the lock count so the task that unlocks the queue
;;;1141   				knows that data was posted while it was locked. */
;;;1142   				++( pxQueue->xTxLock );
000090  6ca0              LDR      r0,[r4,#0x48]
000092  1c40              ADDS     r0,r0,#1
000094  64a0              STR      r0,[r4,#0x48]
                  |L15.150|
;;;1143   			}
;;;1144   
;;;1145   			xReturn = pdPASS;
000096  f04f0801          MOV      r8,#1
00009a  e001              B        |L15.160|
                  |L15.156|
;;;1146   		}
;;;1147   		else
;;;1148   		{
;;;1149   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1150   			xReturn = errQUEUE_FULL;
00009c  f04f0800          MOV      r8,#0
                  |L15.160|
;;;1151   		}
;;;1152   	}
;;;1153   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000a0  4650              MOV      r0,r10
0000a2  f7fffffe          BL       vPortClearInterruptMask
;;;1154   
;;;1155   	return xReturn;
0000a6  4640              MOV      r0,r8
;;;1156   }
0000a8  e8bd87f0          POP      {r4-r10,pc}
;;;1157   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;1811   
;;;1812   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1813   {
000002  4605              MOV      r5,r0
;;;1814   BaseType_t xReturn;
;;;1815   
;;;1816   	configASSERT( xQueue );
000004  b91d              CBNZ     r5,|L16.14|
000006  f7fffffe          BL       ulPortSetInterruptMask
00000a  bf00              NOP      
                  |L16.12|
00000c  e7fe              B        |L16.12|
                  |L16.14|
;;;1817   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
00000e  6ba8              LDR      r0,[r5,#0x38]
000010  b908              CBNZ     r0,|L16.22|
;;;1818   	{
;;;1819   		xReturn = pdTRUE;
000012  2401              MOVS     r4,#1
000014  e000              B        |L16.24|
                  |L16.22|
;;;1820   	}
;;;1821   	else
;;;1822   	{
;;;1823   		xReturn = pdFALSE;
000016  2400              MOVS     r4,#0
                  |L16.24|
;;;1824   	}
;;;1825   
;;;1826   	return xReturn;
000018  4620              MOV      r0,r4
;;;1827   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00001a  bd70              POP      {r4-r6,pc}
;;;1828   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;1850   
;;;1851   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1852   {
000002  4604              MOV      r4,r0
;;;1853   BaseType_t xReturn;
;;;1854   
;;;1855   	configASSERT( xQueue );
000004  b91c              CBNZ     r4,|L17.14|
000006  f7fffffe          BL       ulPortSetInterruptMask
00000a  bf00              NOP      
                  |L17.12|
00000c  e7fe              B        |L17.12|
                  |L17.14|
;;;1856   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  6be1              LDR      r1,[r4,#0x3c]
000012  4288              CMP      r0,r1
000014  d101              BNE      |L17.26|
;;;1857   	{
;;;1858   		xReturn = pdTRUE;
000016  2501              MOVS     r5,#1
000018  e000              B        |L17.28|
                  |L17.26|
;;;1859   	}
;;;1860   	else
;;;1861   	{
;;;1862   		xReturn = pdFALSE;
00001a  2500              MOVS     r5,#0
                  |L17.28|
;;;1863   	}
;;;1864   
;;;1865   	return xReturn;
00001c  4628              MOV      r0,r5
;;;1866   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00001e  bd70              POP      {r4-r6,pc}
;;;1867   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1434   
;;;1435   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1436   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;1437   BaseType_t xReturn;
;;;1438   UBaseType_t uxSavedInterruptStatus;
;;;1439   int8_t *pcOriginalReadPosition;
;;;1440   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000008  462c              MOV      r4,r5
;;;1441   
;;;1442   	configASSERT( pxQueue );
00000a  b91c              CBNZ     r4,|L18.20|
00000c  f7fffffe          BL       ulPortSetInterruptMask
000010  bf00              NOP      
                  |L18.18|
000012  e7fe              B        |L18.18|
                  |L18.20|
;;;1443   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000014  b90f              CBNZ     r7,|L18.26|
000016  6c20              LDR      r0,[r4,#0x40]
000018  b908              CBNZ     r0,|L18.30|
                  |L18.26|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L18.32|
                  |L18.30|
00001e  2000              MOVS     r0,#0
                  |L18.32|
000020  b918              CBNZ     r0,|L18.42|
000022  f7fffffe          BL       ulPortSetInterruptMask
000026  bf00              NOP      
                  |L18.40|
000028  e7fe              B        |L18.40|
                  |L18.42|
;;;1444   
;;;1445   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1446   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1447   	above the maximum system call priority are kept permanently enabled, even
;;;1448   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1449   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1450   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1451   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1452   	assigned a priority above the configured maximum system call priority.
;;;1453   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1454   	that have been assigned a priority at or (logically) below the maximum
;;;1455   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1456   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1457   	More information (albeit Cortex-M specific) is provided on the following
;;;1458   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1459   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00002a  f7fffffe          BL       vPortValidateInterruptPriority
;;;1460   
;;;1461   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00002e  f7fffffe          BL       ulPortSetInterruptMask
000032  4681              MOV      r9,r0
;;;1462   	{
;;;1463   		/* Cannot block in an ISR, so check there is data available. */
;;;1464   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000034  6ba0              LDR      r0,[r4,#0x38]
000036  b148              CBZ      r0,|L18.76|
;;;1465   		{
;;;1466   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1467   
;;;1468   			/* Remember the read position so it can be reset as nothing is
;;;1469   			actually being removed from the queue. */
;;;1470   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000038  f8d4800c          LDR      r8,[r4,#0xc]
;;;1471   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00003c  4639              MOV      r1,r7
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvCopyDataFromQueue
;;;1472   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
000044  f8c4800c          STR      r8,[r4,#0xc]
;;;1473   
;;;1474   			xReturn = pdPASS;
000048  2601              MOVS     r6,#1
00004a  e000              B        |L18.78|
                  |L18.76|
;;;1475   		}
;;;1476   		else
;;;1477   		{
;;;1478   			xReturn = pdFAIL;
00004c  2600              MOVS     r6,#0
                  |L18.78|
;;;1479   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1480   		}
;;;1481   	}
;;;1482   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00004e  4648              MOV      r0,r9
000050  f7fffffe          BL       vPortClearInterruptMask
;;;1483   
;;;1484   	return xReturn;
000054  4630              MOV      r0,r6
;;;1485   }
000056  e8bd87f0          POP      {r4-r10,pc}
;;;1486   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1347   
;;;1348   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1349   {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;1350   BaseType_t xReturn;
;;;1351   UBaseType_t uxSavedInterruptStatus;
;;;1352   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000a  462c              MOV      r4,r5
;;;1353   
;;;1354   	configASSERT( pxQueue );
00000c  b91c              CBNZ     r4,|L19.22|
00000e  f7fffffe          BL       ulPortSetInterruptMask
000012  bf00              NOP      
                  |L19.20|
000014  e7fe              B        |L19.20|
                  |L19.22|
;;;1355   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000016  f1b80f00          CMP      r8,#0
00001a  d101              BNE      |L19.32|
00001c  6c20              LDR      r0,[r4,#0x40]
00001e  b908              CBNZ     r0,|L19.36|
                  |L19.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L19.38|
                  |L19.36|
000024  2000              MOVS     r0,#0
                  |L19.38|
000026  b918              CBNZ     r0,|L19.48|
000028  f7fffffe          BL       ulPortSetInterruptMask
00002c  bf00              NOP      
                  |L19.46|
00002e  e7fe              B        |L19.46|
                  |L19.48|
;;;1356   
;;;1357   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1358   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1359   	above the maximum system call priority are kept permanently enabled, even
;;;1360   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1361   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1362   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1363   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1364   	assigned a priority above the configured maximum system call priority.
;;;1365   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1366   	that have been assigned a priority at or (logically) below the maximum
;;;1367   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1368   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1369   	More information (albeit Cortex-M specific) is provided on the following
;;;1370   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1371   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000030  f7fffffe          BL       vPortValidateInterruptPriority
;;;1372   
;;;1373   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000034  f7fffffe          BL       ulPortSetInterruptMask
000038  4681              MOV      r9,r0
;;;1374   	{
;;;1375   		/* Cannot block in an ISR, so check there is data available. */
;;;1376   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  b1e8              CBZ      r0,|L19.122|
;;;1377   		{
;;;1378   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1379   
;;;1380   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00003e  4641              MOV      r1,r8
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       prvCopyDataFromQueue
;;;1381   			--( pxQueue->uxMessagesWaiting );
000046  6ba0              LDR      r0,[r4,#0x38]
000048  1e40              SUBS     r0,r0,#1
00004a  63a0              STR      r0,[r4,#0x38]
;;;1382   
;;;1383   			/* If the queue is locked the event list will not be modified.
;;;1384   			Instead update the lock count so the task that unlocks the queue
;;;1385   			will know that an ISR has removed data while the queue was
;;;1386   			locked. */
;;;1387   			if( pxQueue->xRxLock == queueUNLOCKED )
00004c  6c60              LDR      r0,[r4,#0x44]
00004e  1c40              ADDS     r0,r0,#1
000050  b970              CBNZ     r0,|L19.112|
;;;1388   			{
;;;1389   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000052  6920              LDR      r0,[r4,#0x10]
000054  b908              CBNZ     r0,|L19.90|
000056  2001              MOVS     r0,#1
000058  e000              B        |L19.92|
                  |L19.90|
00005a  2000              MOVS     r0,#0
                  |L19.92|
00005c  b958              CBNZ     r0,|L19.118|
;;;1390   				{
;;;1391   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00005e  f1040010          ADD      r0,r4,#0x10
000062  f7fffffe          BL       xTaskRemoveFromEventList
000066  b130              CBZ      r0,|L19.118|
;;;1392   					{
;;;1393   						/* The task waiting has a higher priority than us so
;;;1394   						force a context switch. */
;;;1395   						if( pxHigherPriorityTaskWoken != NULL )
000068  b12e              CBZ      r6,|L19.118|
;;;1396   						{
;;;1397   							*pxHigherPriorityTaskWoken = pdTRUE;
00006a  2001              MOVS     r0,#1
00006c  6030              STR      r0,[r6,#0]
00006e  e002              B        |L19.118|
                  |L19.112|
;;;1398   						}
;;;1399   						else
;;;1400   						{
;;;1401   							mtCOVERAGE_TEST_MARKER();
;;;1402   						}
;;;1403   					}
;;;1404   					else
;;;1405   					{
;;;1406   						mtCOVERAGE_TEST_MARKER();
;;;1407   					}
;;;1408   				}
;;;1409   				else
;;;1410   				{
;;;1411   					mtCOVERAGE_TEST_MARKER();
;;;1412   				}
;;;1413   			}
;;;1414   			else
;;;1415   			{
;;;1416   				/* Increment the lock count so the task that unlocks the queue
;;;1417   				knows that data was removed while it was locked. */
;;;1418   				++( pxQueue->xRxLock );
000070  6c60              LDR      r0,[r4,#0x44]
000072  1c40              ADDS     r0,r0,#1
000074  6460              STR      r0,[r4,#0x44]
                  |L19.118|
;;;1419   			}
;;;1420   
;;;1421   			xReturn = pdPASS;
000076  2701              MOVS     r7,#1
000078  e000              B        |L19.124|
                  |L19.122|
;;;1422   		}
;;;1423   		else
;;;1424   		{
;;;1425   			xReturn = pdFAIL;
00007a  2700              MOVS     r7,#0
                  |L19.124|
;;;1426   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1427   		}
;;;1428   	}
;;;1429   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00007c  4648              MOV      r0,r9
00007e  f7fffffe          BL       vPortClearInterruptMask
;;;1430   
;;;1431   	return xReturn;
000082  4638              MOV      r0,r7
;;;1432   }
000084  e8bd87f0          POP      {r4-r10,pc}
;;;1433   /*-----------------------------------------------------------*/
                          ENDP


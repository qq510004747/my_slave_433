; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\bsp_usart.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\bsp_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\BSP_USART2 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I.\RTE\_STM32F10x________2.0.0 -IF:\keil5-22\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -IF:\keil5-22\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\bsp_usart.crf ..\BSP\BSP_USART\BSP_USART.C]
                          THUMB

                          AREA ||i.BSP_USART1_Init||, CODE, READONLY, ALIGN=1

                  BSP_USART1_Init PROC
;;;46     **********************************************/
;;;47     void BSP_USART1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;48     {
;;;49     		USART1_Init();
000002  f7fffffe          BL       USART1_Init
;;;50     }
000006  bd10              POP      {r4,pc}
;;;51     /**********************************************
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;118    **********************************************/ 
;;;119    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;120    {
;;;121    	u8 Res;
;;;122    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000002  f2405125          MOV      r1,#0x525
000006  4821              LDR      r0,|L2.140|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b330              CBZ      r0,|L2.92|
;;;123    	{
;;;124    		Res =USART_ReceiveData(USART1);//(USART1->DR);	//读取接收到的数据
00000e  481f              LDR      r0,|L2.140|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
;;;125    		USART_SendData(USART1, Res);
000016  4621              MOV      r1,r4
000018  481c              LDR      r0,|L2.140|
00001a  f7fffffe          BL       USART_SendData
;;;126    		if((USART_RX_STA&0x8000)==0)//接收未完成
00001e  481c              LDR      r0,|L2.144|
000020  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000022  f4004000          AND      r0,r0,#0x8000
000026  b9c8              CBNZ     r0,|L2.92|
;;;127    		{
;;;128    			if(USART_RX_STA&0x4000)//接收到了0x0d
000028  4819              LDR      r0,|L2.144|
00002a  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00002c  f4004080          AND      r0,r0,#0x4000
000030  b160              CBZ      r0,|L2.76|
;;;129    			{
;;;130    					if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
000032  2c0a              CMP      r4,#0xa
000034  d003              BEQ      |L2.62|
000036  2000              MOVS     r0,#0
000038  4915              LDR      r1,|L2.144|
00003a  8008              STRH     r0,[r1,#0]
00003c  e020              B        |L2.128|
                  |L2.62|
;;;131    					else USART_RX_STA|=0x8000;	//接收完成了 
00003e  4814              LDR      r0,|L2.144|
000040  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000042  f4404000          ORR      r0,r0,#0x8000
000046  4912              LDR      r1,|L2.144|
000048  8008              STRH     r0,[r1,#0]
00004a  e019              B        |L2.128|
                  |L2.76|
;;;132    			}
;;;133    			else //还没收到0X0D
;;;134    			{	
;;;135    				if(Res==0x0d)USART_RX_STA|=0x4000;
00004c  2c0d              CMP      r4,#0xd
00004e  d106              BNE      |L2.94|
000050  480f              LDR      r0,|L2.144|
000052  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000054  f4404080          ORR      r0,r0,#0x4000
000058  490d              LDR      r1,|L2.144|
00005a  8008              STRH     r0,[r1,#0]
                  |L2.92|
00005c  e010              B        |L2.128|
                  |L2.94|
;;;136    				else
;;;137    				{
;;;138    						USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
00005e  480c              LDR      r0,|L2.144|
000060  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000062  f3c0000d          UBFX     r0,r0,#0,#14
000066  490b              LDR      r1,|L2.148|
000068  540c              STRB     r4,[r1,r0]
;;;139    						USART_RX_STA++;
00006a  4809              LDR      r0,|L2.144|
00006c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00006e  1c40              ADDS     r0,r0,#1
000070  4907              LDR      r1,|L2.144|
000072  8008              STRH     r0,[r1,#0]
;;;140    						if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
000074  4608              MOV      r0,r1
000076  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000078  28c7              CMP      r0,#0xc7
00007a  dd01              BLE      |L2.128|
00007c  2000              MOVS     r0,#0
00007e  8008              STRH     r0,[r1,#0]
                  |L2.128|
;;;141    				}		 
;;;142    			}
;;;143    		}   	
;;;144    	}
;;;145    	USART_ClearITPendingBit(USART1, USART_IT_RXNE );
000080  f2405125          MOV      r1,#0x525
000084  4801              LDR      r0,|L2.140|
000086  f7fffffe          BL       USART_ClearITPendingBit
;;;146    }
00008a  bd10              POP      {r4,pc}
;;;147    #endif 
                          ENDP

                  |L2.140|
                          DCD      0x40013800
                  |L2.144|
                          DCD      USART_RX_STA
                  |L2.148|
                          DCD      USART_RX_BUF

                          AREA ||i.USART1_Init||, CODE, READONLY, ALIGN=2

                  USART1_Init PROC
;;;56     **********************************************/ 
;;;57     static void USART1_Init(void)
000000  b500              PUSH     {lr}
;;;58     {
000002  b087              SUB      sp,sp,#0x1c
;;;59     		GPIO_InitTypeDef GPIO_InitStructure;
;;;60     		USART_InitTypeDef USART_InitStructure;
;;;61     		 
;;;62     //		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//使能GPIOA时钟
;;;63     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
000004  2101              MOVS     r1,#1
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;64     		RCC_APB1PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//使能USART1
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;65     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;66     	
;;;67     #if USART1_Rx_INT_ENABLE
;;;68     		NVIC_InitTypeDef NVIC_InitStructure;
;;;69     #endif	 
;;;70     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|USART1_GPIO_CLK, ENABLE);	//使能USART1,USART1_GPIO时钟
00001c  2101              MOVS     r1,#1
00001e  f2440008          MOV      r0,#0x4008
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;71     
;;;72     #if USART1_PinRemap
;;;73     		GPIO_PinRemapConfig(GPIO_Remap_USART1,ENABLE); //开启串口1重映射时钟
000026  2101              MOVS     r1,#1
000028  2004              MOVS     r0,#4
00002a  f7fffffe          BL       GPIO_PinRemapConfig
;;;74     #endif
;;;75     		USART_DeInit(USART1);  //复位串口1
00002e  482c              LDR      r0,|L3.224|
000030  f7fffffe          BL       USART_DeInit
;;;76     //USART1_TX   PA.9 PB.6
;;;77     		GPIO_InitStructure.GPIO_Pin = USART1_PIN_Tx; //PA.9
000034  2040              MOVS     r0,#0x40
000036  f8ad0018          STRH     r0,[sp,#0x18]
;;;78     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  2003              MOVS     r0,#3
00003c  f88d001a          STRB     r0,[sp,#0x1a]
;;;79     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
000040  2018              MOVS     r0,#0x18
000042  f88d001b          STRB     r0,[sp,#0x1b]
;;;80     		GPIO_Init(USART1_GPIO, &GPIO_InitStructure); //初始化PA9
000046  a906              ADD      r1,sp,#0x18
000048  4826              LDR      r0,|L3.228|
00004a  f7fffffe          BL       GPIO_Init
;;;81     //USART1_RX	  PA.10 PB.7
;;;82     		GPIO_InitStructure.GPIO_Pin = USART1_PIN_Rx;
00004e  2080              MOVS     r0,#0x80
000050  f8ad0018          STRH     r0,[sp,#0x18]
;;;83     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000054  2004              MOVS     r0,#4
000056  f88d001b          STRB     r0,[sp,#0x1b]
;;;84     		GPIO_Init(USART1_GPIO, &GPIO_InitStructure);  //初始化
00005a  a906              ADD      r1,sp,#0x18
00005c  4821              LDR      r0,|L3.228|
00005e  f7fffffe          BL       GPIO_Init
;;;85     		
;;;86     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
000062  f44f7080          MOV      r0,#0x100
000066  f8ad0018          STRH     r0,[sp,#0x18]
;;;87     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00006a  2010              MOVS     r0,#0x10
00006c  f88d001b          STRB     r0,[sp,#0x1b]
;;;88     		GPIO_Init(GPIOB, &GPIO_InitStructure);  //初始化PB8
000070  a906              ADD      r1,sp,#0x18
000072  481c              LDR      r0,|L3.228|
000074  f7fffffe          BL       GPIO_Init
;;;89     	
;;;90     //USART 初始化设置
;;;91     		USART_InitStructure.USART_BaudRate = USART1_Baud_Rate;//一般设置为9600;
000078  f44f5016          MOV      r0,#0x2580
00007c  9002              STR      r0,[sp,#8]
;;;92     		USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
00007e  2000              MOVS     r0,#0
000080  f8ad000c          STRH     r0,[sp,#0xc]
;;;93     		USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000084  f8ad000e          STRH     r0,[sp,#0xe]
;;;94     		USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
000088  f8ad0010          STRH     r0,[sp,#0x10]
;;;95     		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00008c  f8ad0014          STRH     r0,[sp,#0x14]
;;;96     		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000090  200c              MOVS     r0,#0xc
000092  f8ad0012          STRH     r0,[sp,#0x12]
;;;97     		USART_Init(USART1, &USART_InitStructure); //初始化串口
000096  a902              ADD      r1,sp,#8
000098  4811              LDR      r0,|L3.224|
00009a  f7fffffe          BL       USART_Init
;;;98     	
;;;99     #if USART1_Rx_INT_ENABLE	//如果使能了接收配置Usart1 NVIC   
;;;100    		NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00009e  2025              MOVS     r0,#0x25
0000a0  f88d0004          STRB     r0,[sp,#4]
;;;101    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=USART1_PreemptionPriority ;//抢占优先级0
0000a4  2000              MOVS     r0,#0
0000a6  f88d0005          STRB     r0,[sp,#5]
;;;102    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = USART1_ChannelSubPriority;		//子优先级3
0000aa  f88d0006          STRB     r0,[sp,#6]
;;;103    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
0000ae  2001              MOVS     r0,#1
0000b0  f88d0007          STRB     r0,[sp,#7]
;;;104    		NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
0000b4  a801              ADD      r0,sp,#4
0000b6  f7fffffe          BL       NVIC_Init
;;;105    		 
;;;106    		USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断
0000ba  2201              MOVS     r2,#1
0000bc  f2405125          MOV      r1,#0x525
0000c0  4807              LDR      r0,|L3.224|
0000c2  f7fffffe          BL       USART_ITConfig
;;;107    		USART_ITConfig(USART1, USART_IT_IDLE , ENABLE);//一定要单独设置，;USART_IT_IDLE空闲中断
0000c6  2201              MOVS     r2,#1
0000c8  f2404124          MOV      r1,#0x424
0000cc  4804              LDR      r0,|L3.224|
0000ce  f7fffffe          BL       USART_ITConfig
;;;108    #endif
;;;109    		USART_Cmd(USART1, ENABLE);                    //使能串口 
0000d2  2101              MOVS     r1,#1
0000d4  4802              LDR      r0,|L3.224|
0000d6  f7fffffe          BL       USART_Cmd
;;;110    }
0000da  b007              ADD      sp,sp,#0x1c
0000dc  bd00              POP      {pc}
;;;111    
                          ENDP

0000de  0000              DCW      0x0000
                  |L3.224|
                          DCD      0x40013800
                  |L3.228|
                          DCD      0x40010c00

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;156     
;;;157     int fgetc(FILE *f) // 接收数据
000000  4601              MOV      r1,r0
;;;158      { 
;;;159          while (!(USART1->SR & USART_FLAG_RXNE));
000002  bf00              NOP      
                  |L4.4|
000004  4805              LDR      r0,|L4.28|
000006  8800              LDRH     r0,[r0,#0]
000008  f0000020          AND      r0,r0,#0x20
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L4.4|
;;;160          return ((int)(USART1->DR & 0x1FF));
000010  4802              LDR      r0,|L4.28|
000012  1d00              ADDS     r0,r0,#4
000014  8800              LDRH     r0,[r0,#0]
000016  f3c00008          UBFX     r0,r0,#0,#9
;;;161       } 
00001a  4770              BX       lr
;;;162    //如果要使用printf函数除了#include<stdio.h>和重定义两个输入输出函数外还应该Target->Code Generation中勾选Use MicroLIB 
                          ENDP

                  |L4.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;149    /*  printf函数的定义与使用-------------------*/
;;;150    int fputc(int ch, FILE *f)//发送数据
000000  b570              PUSH     {r4-r6,lr}
;;;151       {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;152          USART_SendData(USART1, (unsigned char) ch);// USART1 可以换成 USART1 等
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L5.32|
00000a  f7fffffe          BL       USART_SendData
;;;153          while (!(USART1->SR & USART_FLAG_TXE));
00000e  bf00              NOP      
                  |L5.16|
000010  4803              LDR      r0,|L5.32|
000012  8800              LDRH     r0,[r0,#0]
000014  f0000080          AND      r0,r0,#0x80
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L5.16|
;;;154          return (ch);
00001c  4620              MOV      r0,r4
;;;155       }
00001e  bd70              POP      {r4-r6,pc}
;;;156     
                          ENDP

                  |L5.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_STA
000000  0000              DCW      0x0000

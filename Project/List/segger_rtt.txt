; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\segger_rtt.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\segger_rtt.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -IC:\Users\Administrator\Desktop\FreeRTOS¹¤³ÌÃþ°åV2.0.0\Project\RTE -IF:\keil5-22\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -IF:\keil5-22\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\segger_rtt.crf ..\Libraries\J_LINK_RTT\RTT\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;478    */
;;;479    int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, char* pBuffer, int BufferSize, int Flags) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4604              MOV      r4,r0
000004  9d05              LDR      r5,[sp,#0x14]
;;;480      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000006  4819              LDR      r0,|L1.108|
000008  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00000a  42a0              CMP      r0,r4
00000c  d92a              BLS      |L1.100|
;;;481        SEGGER_RTT_LOCK();
;;;482        if (BufferIndex > 0) {
00000e  b304              CBZ      r4,|L1.82|
;;;483          _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000010  eb040644          ADD      r6,r4,r4,LSL #1
000014  4815              LDR      r0,|L1.108|
000016  3048              ADDS     r0,r0,#0x48
000018  f8401036          STR      r1,[r0,r6,LSL #3]
;;;484          _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
00001c  eb040644          ADD      r6,r4,r4,LSL #1
000020  eb0000c6          ADD      r0,r0,r6,LSL #3
000024  6042              STR      r2,[r0,#4]
;;;485          _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000026  eb040644          ADD      r6,r4,r4,LSL #1
00002a  4810              LDR      r0,|L1.108|
00002c  3048              ADDS     r0,r0,#0x48
00002e  eb0000c6          ADD      r0,r0,r6,LSL #3
000032  6083              STR      r3,[r0,#8]
;;;486          _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0;
000034  2600              MOVS     r6,#0
000036  eb040744          ADD      r7,r4,r4,LSL #1
00003a  480c              LDR      r0,|L1.108|
00003c  3048              ADDS     r0,r0,#0x48
00003e  eb0000c7          ADD      r0,r0,r7,LSL #3
000042  6106              STR      r6,[r0,#0x10]
;;;487          _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0;
000044  eb040744          ADD      r7,r4,r4,LSL #1
000048  4808              LDR      r0,|L1.108|
00004a  3048              ADDS     r0,r0,#0x48
00004c  eb0000c7          ADD      r0,r0,r7,LSL #3
000050  60c6              STR      r6,[r0,#0xc]
                  |L1.82|
;;;488        }
;;;489        _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
000052  eb040644          ADD      r6,r4,r4,LSL #1
000056  4805              LDR      r0,|L1.108|
000058  3048              ADDS     r0,r0,#0x48
00005a  eb0000c6          ADD      r0,r0,r6,LSL #3
00005e  6145              STR      r5,[r0,#0x14]
;;;490        SEGGER_RTT_UNLOCK();
;;;491        return 0;
000060  2000              MOVS     r0,#0
                  |L1.98|
;;;492      }
;;;493      return -1;
;;;494    }
000062  bdf0              POP      {r4-r7,pc}
                  |L1.100|
000064  f04f30ff          MOV      r0,#0xffffffff        ;493
000068  e7fb              B        |L1.98|
;;;495    
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;448    */
;;;449    int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, char* pBuffer, int BufferSize, int Flags) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4604              MOV      r4,r0
000004  9d05              LDR      r5,[sp,#0x14]
;;;450      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000006  4819              LDR      r0,|L2.108|
000008  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00000a  42a0              CMP      r0,r4
00000c  d92a              BLS      |L2.100|
;;;451        SEGGER_RTT_LOCK();
;;;452        if (BufferIndex > 0) {
00000e  b304              CBZ      r4,|L2.82|
;;;453          _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000010  eb040644          ADD      r6,r4,r4,LSL #1
000014  4815              LDR      r0,|L2.108|
000016  3018              ADDS     r0,r0,#0x18
000018  f8401036          STR      r1,[r0,r6,LSL #3]
;;;454          _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
00001c  eb040644          ADD      r6,r4,r4,LSL #1
000020  eb0000c6          ADD      r0,r0,r6,LSL #3
000024  6042              STR      r2,[r0,#4]
;;;455          _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000026  eb040644          ADD      r6,r4,r4,LSL #1
00002a  4810              LDR      r0,|L2.108|
00002c  3018              ADDS     r0,r0,#0x18
00002e  eb0000c6          ADD      r0,r0,r6,LSL #3
000032  6083              STR      r3,[r0,#8]
;;;456          _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0;
000034  2600              MOVS     r6,#0
000036  eb040744          ADD      r7,r4,r4,LSL #1
00003a  480c              LDR      r0,|L2.108|
00003c  3018              ADDS     r0,r0,#0x18
00003e  eb0000c7          ADD      r0,r0,r7,LSL #3
000042  6106              STR      r6,[r0,#0x10]
;;;457          _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0;
000044  eb040744          ADD      r7,r4,r4,LSL #1
000048  4808              LDR      r0,|L2.108|
00004a  3018              ADDS     r0,r0,#0x18
00004c  eb0000c7          ADD      r0,r0,r7,LSL #3
000050  60c6              STR      r6,[r0,#0xc]
                  |L2.82|
;;;458        }
;;;459        _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
000052  eb040644          ADD      r6,r4,r4,LSL #1
000056  4805              LDR      r0,|L2.108|
000058  3018              ADDS     r0,r0,#0x18
00005a  eb0000c6          ADD      r0,r0,r6,LSL #3
00005e  6145              STR      r5,[r0,#0x14]
;;;460        SEGGER_RTT_UNLOCK();
;;;461        return 0;
000060  2000              MOVS     r0,#0
                  |L2.98|
;;;462      }
;;;463      return -1;
;;;464    }
000062  bdf0              POP      {r4-r7,pc}
                  |L2.100|
000064  f04f30ff          MOV      r0,#0xffffffff        ;463
000068  e7fb              B        |L2.98|
;;;465    
                          ENDP

00006a  0000              DCW      0x0000
                  |L2.108|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;376    */
;;;377    int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;378      char c;
;;;379      int r;
;;;380    
;;;381      r = SEGGER_RTT_Read(0, &c, 1);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;382      if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L3.24|
;;;383        return (int)(unsigned char)c;
000012  f89d0000          LDRB     r0,[sp,#0]
                  |L3.22|
;;;384      }
;;;385      return -1;
;;;386    }
000016  bd38              POP      {r3-r5,pc}
                  |L3.24|
000018  f04f30ff          MOV      r0,#0xffffffff        ;385
00001c  e7fb              B        |L3.22|
;;;387    
                          ENDP


                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;425    */
;;;426    int SEGGER_RTT_HasKey(void) {
000000  4804              LDR      r0,|L4.20|
;;;427      int RdOff;
;;;428    
;;;429      RdOff = _SEGGER_RTT.aDown[0].RdOff;
000002  6d81              LDR      r1,[r0,#0x58]
;;;430      if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000004  6d40              LDR      r0,[r0,#0x54]
000006  4288              CMP      r0,r1
000008  d001              BEQ      |L4.14|
;;;431        return 1;
00000a  2001              MOVS     r0,#1
                  |L4.12|
;;;432      }
;;;433      return 0;
;;;434    }
00000c  4770              BX       lr
                  |L4.14|
00000e  2000              MOVS     r0,#0                 ;433
000010  e7fc              B        |L4.12|
;;;435    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Read PROC
;;;204    */
;;;205    int SEGGER_RTT_Read(unsigned BufferIndex, char* pBuffer, unsigned BufferSize) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;206      int NumBytesRem;
;;;207      unsigned NumBytesRead;
;;;208      int RdOff;
;;;209      int WrOff;
;;;210    
;;;211      SEGGER_RTT_LOCK();
;;;212      RdOff = _SEGGER_RTT.aDown[BufferIndex].RdOff;
00000a  eb060146          ADD      r1,r6,r6,LSL #1
00000e  482c              LDR      r0,|L5.192|
000010  eb0000c1          ADD      r0,r0,r1,LSL #3
000014  6905              LDR      r5,[r0,#0x10]
;;;213      WrOff = _SEGGER_RTT.aDown[BufferIndex].WrOff;
000016  eb060146          ADD      r1,r6,r6,LSL #1
00001a  4829              LDR      r0,|L5.192|
00001c  eb0000c1          ADD      r0,r0,r1,LSL #3
000020  f8d0a00c          LDR      r10,[r0,#0xc]
;;;214      NumBytesRead = 0;
000024  f04f0900          MOV      r9,#0
;;;215      //
;;;216      // Read from current read position to wrap-around of buffer, first
;;;217      //
;;;218      if (RdOff > WrOff) {
000028  4555              CMP      r5,r10
00002a  dd24              BLE      |L5.118|
;;;219        NumBytesRem = _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer - RdOff;
00002c  eb060146          ADD      r1,r6,r6,LSL #1
000030  4823              LDR      r0,|L5.192|
000032  eb0000c1          ADD      r0,r0,r1,LSL #3
000036  6880              LDR      r0,[r0,#8]
000038  1b44              SUBS     r4,r0,r5
;;;220        NumBytesRem = MIN(NumBytesRem, (int)BufferSize);
00003a  42bc              CMP      r4,r7
00003c  da01              BGE      |L5.66|
00003e  4620              MOV      r0,r4
000040  e000              B        |L5.68|
                  |L5.66|
000042  4638              MOV      r0,r7
                  |L5.68|
000044  4604              MOV      r4,r0
;;;221        MEMCPY(pBuffer, _SEGGER_RTT.aDown[BufferIndex].pBuffer + RdOff, NumBytesRem);
000046  eb060246          ADD      r2,r6,r6,LSL #1
00004a  481d              LDR      r0,|L5.192|
00004c  eb0000c2          ADD      r0,r0,r2,LSL #3
000050  6840              LDR      r0,[r0,#4]
000052  1941              ADDS     r1,r0,r5
000054  4622              MOV      r2,r4
000056  4640              MOV      r0,r8
000058  f7fffffe          BL       __aeabi_memcpy
;;;222        NumBytesRead += NumBytesRem;
00005c  44a1              ADD      r9,r9,r4
;;;223        pBuffer      += NumBytesRem;
00005e  44a0              ADD      r8,r8,r4
;;;224        BufferSize   -= NumBytesRem;
000060  1b3f              SUBS     r7,r7,r4
;;;225        RdOff        += NumBytesRem;
000062  4425              ADD      r5,r5,r4
;;;226        //
;;;227        // Handle wrap-around of buffer
;;;228        //
;;;229        if (RdOff == _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer) {
000064  eb060146          ADD      r1,r6,r6,LSL #1
000068  4815              LDR      r0,|L5.192|
00006a  eb0000c1          ADD      r0,r0,r1,LSL #3
00006e  6880              LDR      r0,[r0,#8]
000070  42a8              CMP      r0,r5
000072  d100              BNE      |L5.118|
;;;230          RdOff = 0;
000074  2500              MOVS     r5,#0
                  |L5.118|
;;;231        }
;;;232      }
;;;233      //
;;;234      // Read remaining items of buffer
;;;235      //
;;;236      NumBytesRem = WrOff - RdOff;
000076  ebaa0405          SUB      r4,r10,r5
;;;237      NumBytesRem = MIN(NumBytesRem, (int)BufferSize);
00007a  42bc              CMP      r4,r7
00007c  da01              BGE      |L5.130|
00007e  4620              MOV      r0,r4
000080  e000              B        |L5.132|
                  |L5.130|
000082  4638              MOV      r0,r7
                  |L5.132|
000084  4604              MOV      r4,r0
;;;238      if (NumBytesRem > 0) {
000086  2c00              CMP      r4,#0
000088  dd0e              BLE      |L5.168|
;;;239        MEMCPY(pBuffer, _SEGGER_RTT.aDown[BufferIndex].pBuffer + RdOff, NumBytesRem);
00008a  eb060246          ADD      r2,r6,r6,LSL #1
00008e  480c              LDR      r0,|L5.192|
000090  eb0000c2          ADD      r0,r0,r2,LSL #3
000094  6840              LDR      r0,[r0,#4]
000096  1941              ADDS     r1,r0,r5
000098  4622              MOV      r2,r4
00009a  4640              MOV      r0,r8
00009c  f7fffffe          BL       __aeabi_memcpy
;;;240        NumBytesRead += NumBytesRem;
0000a0  44a1              ADD      r9,r9,r4
;;;241        pBuffer      += NumBytesRem;
0000a2  44a0              ADD      r8,r8,r4
;;;242        BufferSize   -= NumBytesRem;
0000a4  1b3f              SUBS     r7,r7,r4
;;;243        RdOff        += NumBytesRem;
0000a6  4425              ADD      r5,r5,r4
                  |L5.168|
;;;244      }
;;;245      if (NumBytesRead) {
0000a8  f1b90f00          CMP      r9,#0
0000ac  d005              BEQ      |L5.186|
;;;246        _SEGGER_RTT.aDown[BufferIndex].RdOff = RdOff;
0000ae  eb060146          ADD      r1,r6,r6,LSL #1
0000b2  4803              LDR      r0,|L5.192|
0000b4  eb0000c1          ADD      r0,r0,r1,LSL #3
0000b8  6105              STR      r5,[r0,#0x10]
                  |L5.186|
;;;247      }
;;;248      SEGGER_RTT_UNLOCK();
;;;249      return NumBytesRead;
0000ba  4648              MOV      r0,r9
;;;250    }
0000bc  e8bd87f0          POP      {r4-r10,pc}
;;;251    
                          ENDP

                  |L5.192|
                          DCD      _SEGGER_RTT+0x48

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;402    */
;;;403    int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;404      int r;
;;;405    
;;;406      do {
000002  bf00              NOP      
                  |L6.4|
;;;407        r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;408      } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L6.4|
;;;409      return r;
;;;410    }
00000c  bd10              POP      {r4,pc}
;;;411    
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;270    */
;;;271    int SEGGER_RTT_Write(unsigned BufferIndex, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;272      int NumBytesToWrite;
;;;273      unsigned NumBytesWritten;
;;;274      int RdOff;
;;;275      //
;;;276      // Target is not allowed to perform other RTT operations while string still has not been stored completely.
;;;277      // Otherwise we would probably end up with a mixed string in the buffer.
;;;278      //
;;;279      SEGGER_RTT_LOCK();
;;;280      //
;;;281      // In case we are not in blocking mode,
;;;282      // we need to calculate, how many bytes we can put into the buffer at all.
;;;283      //
;;;284      if ((_SEGGER_RTT.aUp[BufferIndex].Flags & SEGGER_RTT_MODE_MASK) != SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00000a  eb040144          ADD      r1,r4,r4,LSL #1
00000e  4856              LDR      r0,|L7.360|
000010  eb0000c1          ADD      r0,r0,r1,LSL #3
000014  7d00              LDRB     r0,[r0,#0x14]
000016  f0000003          AND      r0,r0,#3
00001a  2802              CMP      r0,#2
00001c  d027              BEQ      |L7.110|
;;;285        RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
00001e  eb040144          ADD      r1,r4,r4,LSL #1
000022  4851              LDR      r0,|L7.360|
000024  eb0000c1          ADD      r0,r0,r1,LSL #3
000028  f8d08010          LDR      r8,[r0,#0x10]
;;;286        NumBytesToWrite =  RdOff - _SEGGER_RTT.aUp[BufferIndex].WrOff - 1;
00002c  eb040144          ADD      r1,r4,r4,LSL #1
000030  484d              LDR      r0,|L7.360|
000032  eb0000c1          ADD      r0,r0,r1,LSL #3
000036  68c0              LDR      r0,[r0,#0xc]
000038  eba80000          SUB      r0,r8,r0
00003c  1e45              SUBS     r5,r0,#1
;;;287        if (NumBytesToWrite < 0) {
00003e  2d00              CMP      r5,#0
000040  da06              BGE      |L7.80|
;;;288          NumBytesToWrite += _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer;
000042  eb040144          ADD      r1,r4,r4,LSL #1
000046  4848              LDR      r0,|L7.360|
000048  eb0000c1          ADD      r0,r0,r1,LSL #3
00004c  6880              LDR      r0,[r0,#8]
00004e  4405              ADD      r5,r5,r0
                  |L7.80|
;;;289        }
;;;290        //
;;;291        // If the complete data does not fit in the buffer, check if we have to skip it completely or trim the data
;;;292        //
;;;293        if ((int)NumBytes > NumBytesToWrite) {
000050  42ae              CMP      r6,r5
000052  dd0c              BLE      |L7.110|
;;;294          if ((_SEGGER_RTT.aUp[BufferIndex].Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_NO_BLOCK_SKIP) {
000054  eb040144          ADD      r1,r4,r4,LSL #1
000058  4843              LDR      r0,|L7.360|
00005a  eb0000c1          ADD      r0,r0,r1,LSL #3
00005e  7d00              LDRB     r0,[r0,#0x14]
000060  f0000003          AND      r0,r0,#3
000064  b910              CBNZ     r0,|L7.108|
;;;295            SEGGER_RTT_UNLOCK();
;;;296            return 0;
000066  2000              MOVS     r0,#0
                  |L7.104|
;;;297          } else {
;;;298            NumBytes = NumBytesToWrite;
;;;299          }
;;;300        }
;;;301      }
;;;302      //
;;;303      // Early out if nothing is to do
;;;304      //
;;;305      if (NumBytes == 0) {
;;;306        SEGGER_RTT_UNLOCK();
;;;307        return 0;
;;;308      }
;;;309      //
;;;310      // Write data to buffer and handle wrap-around if necessary
;;;311      //
;;;312      NumBytesWritten = 0;
;;;313      do {
;;;314        RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;                          // May be changed by host (debug probe) in the meantime
;;;315        NumBytesToWrite = RdOff - _SEGGER_RTT.aUp[BufferIndex].WrOff - 1;
;;;316        if (NumBytesToWrite < 0) {
;;;317          NumBytesToWrite += _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer;
;;;318        }
;;;319        NumBytesToWrite = MIN(NumBytesToWrite, (_SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - _SEGGER_RTT.aUp[BufferIndex].WrOff));    // Number of bytes that can be written until buffer wrap-around
;;;320        NumBytesToWrite = MIN(NumBytesToWrite, (int)NumBytes);
;;;321        MEMCPY(_SEGGER_RTT.aUp[BufferIndex].pBuffer + _SEGGER_RTT.aUp[BufferIndex].WrOff, pBuffer, NumBytesToWrite);
;;;322        NumBytesWritten     += NumBytesToWrite;
;;;323        pBuffer             += NumBytesToWrite;
;;;324        NumBytes            -= NumBytesToWrite;
;;;325        _SEGGER_RTT.aUp[BufferIndex].WrOff += NumBytesToWrite;
;;;326        if (_SEGGER_RTT.aUp[BufferIndex].WrOff == _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer) {
;;;327          _SEGGER_RTT.aUp[BufferIndex].WrOff = 0;
;;;328        }
;;;329      } while (NumBytes);
;;;330      SEGGER_RTT_UNLOCK();
;;;331      return NumBytesWritten;
;;;332    }
000068  e8bd87f0          POP      {r4-r10,pc}
                  |L7.108|
00006c  462e              MOV      r6,r5                 ;298
                  |L7.110|
00006e  b90e              CBNZ     r6,|L7.116|
000070  2000              MOVS     r0,#0                 ;307
000072  e7f9              B        |L7.104|
                  |L7.116|
000074  2700              MOVS     r7,#0                 ;312
000076  bf00              NOP                            ;313
                  |L7.120|
000078  eb040144          ADD      r1,r4,r4,LSL #1       ;314
00007c  483a              LDR      r0,|L7.360|
00007e  eb0000c1          ADD      r0,r0,r1,LSL #3       ;314
000082  f8d08010          LDR      r8,[r0,#0x10]         ;314
000086  eb040144          ADD      r1,r4,r4,LSL #1       ;315
00008a  4837              LDR      r0,|L7.360|
00008c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;315
000090  68c0              LDR      r0,[r0,#0xc]          ;315
000092  eba80000          SUB      r0,r8,r0              ;315
000096  1e45              SUBS     r5,r0,#1              ;315
000098  2d00              CMP      r5,#0                 ;316
00009a  da06              BGE      |L7.170|
00009c  eb040144          ADD      r1,r4,r4,LSL #1       ;317
0000a0  4831              LDR      r0,|L7.360|
0000a2  eb0000c1          ADD      r0,r0,r1,LSL #3       ;317
0000a6  6880              LDR      r0,[r0,#8]            ;317
0000a8  4405              ADD      r5,r5,r0              ;317
                  |L7.170|
0000aa  eb040144          ADD      r1,r4,r4,LSL #1       ;319
0000ae  482e              LDR      r0,|L7.360|
0000b0  eb0000c1          ADD      r0,r0,r1,LSL #3       ;319
0000b4  eb040244          ADD      r2,r4,r4,LSL #1       ;319
0000b8  6881              LDR      r1,[r0,#8]            ;319
0000ba  482b              LDR      r0,|L7.360|
0000bc  eb0000c2          ADD      r0,r0,r2,LSL #3       ;319
0000c0  68c0              LDR      r0,[r0,#0xc]          ;319
0000c2  1a08              SUBS     r0,r1,r0              ;319
0000c4  42a8              CMP      r0,r5                 ;319
0000c6  dd01              BLE      |L7.204|
0000c8  4628              MOV      r0,r5                 ;319
0000ca  e00c              B        |L7.230|
                  |L7.204|
0000cc  eb040144          ADD      r1,r4,r4,LSL #1       ;319
0000d0  4825              LDR      r0,|L7.360|
0000d2  eb0000c1          ADD      r0,r0,r1,LSL #3       ;319
0000d6  eb040244          ADD      r2,r4,r4,LSL #1       ;319
0000da  6881              LDR      r1,[r0,#8]            ;319
0000dc  4822              LDR      r0,|L7.360|
0000de  eb0000c2          ADD      r0,r0,r2,LSL #3       ;319
0000e2  68c0              LDR      r0,[r0,#0xc]          ;319
0000e4  1a08              SUBS     r0,r1,r0              ;319
                  |L7.230|
0000e6  4605              MOV      r5,r0                 ;319
0000e8  42b5              CMP      r5,r6                 ;320
0000ea  da01              BGE      |L7.240|
0000ec  4628              MOV      r0,r5                 ;320
0000ee  e000              B        |L7.242|
                  |L7.240|
0000f0  4630              MOV      r0,r6                 ;320
                  |L7.242|
0000f2  4605              MOV      r5,r0                 ;320
0000f4  eb040244          ADD      r2,r4,r4,LSL #1       ;321
0000f8  491b              LDR      r1,|L7.360|
0000fa  eb0101c2          ADD      r1,r1,r2,LSL #3       ;321
0000fe  eb040344          ADD      r3,r4,r4,LSL #1       ;321
000102  684a              LDR      r2,[r1,#4]            ;321
000104  4918              LDR      r1,|L7.360|
000106  eb0101c3          ADD      r1,r1,r3,LSL #3       ;321
00010a  68c9              LDR      r1,[r1,#0xc]          ;321
00010c  1850              ADDS     r0,r2,r1              ;321
00010e  462a              MOV      r2,r5                 ;321
000110  4649              MOV      r1,r9                 ;321
000112  f7fffffe          BL       __aeabi_memcpy
000116  442f              ADD      r7,r7,r5              ;322
000118  44a9              ADD      r9,r9,r5              ;323
00011a  1b76              SUBS     r6,r6,r5              ;324
00011c  eb040144          ADD      r1,r4,r4,LSL #1       ;325
000120  4811              LDR      r0,|L7.360|
000122  eb0000c1          ADD      r0,r0,r1,LSL #3       ;325
000126  68c0              LDR      r0,[r0,#0xc]          ;325
000128  1941              ADDS     r1,r0,r5              ;325
00012a  eb040244          ADD      r2,r4,r4,LSL #1       ;325
00012e  480e              LDR      r0,|L7.360|
000130  eb0000c2          ADD      r0,r0,r2,LSL #3       ;325
000134  60c1              STR      r1,[r0,#0xc]          ;325
000136  eb040144          ADD      r1,r4,r4,LSL #1       ;326
00013a  480b              LDR      r0,|L7.360|
00013c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;326
000140  68c1              LDR      r1,[r0,#0xc]          ;326
000142  eb040244          ADD      r2,r4,r4,LSL #1       ;326
000146  4808              LDR      r0,|L7.360|
000148  eb0000c2          ADD      r0,r0,r2,LSL #3       ;326
00014c  6880              LDR      r0,[r0,#8]            ;326
00014e  4281              CMP      r1,r0                 ;326
000150  d106              BNE      |L7.352|
000152  2100              MOVS     r1,#0                 ;327
000154  eb040244          ADD      r2,r4,r4,LSL #1       ;327
000158  4803              LDR      r0,|L7.360|
00015a  eb0000c2          ADD      r0,r0,r2,LSL #3       ;327
00015e  60c1              STR      r1,[r0,#0xc]          ;327
                  |L7.352|
000160  2e00              CMP      r6,#0                 ;329
000162  d189              BNE      |L7.120|
000164  4638              MOV      r0,r7                 ;331
000166  e77f              B        |L7.104|
;;;333    
                          ENDP

                  |L7.360|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;354    */
;;;355    int SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;356      int Len;
;;;357    
;;;358      Len = _strlen(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       _strlen
00000c  4606              MOV      r6,r0
;;;359      return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;360    }
000018  bd70              POP      {r4-r6,pc}
;;;361    
                          ENDP


                          AREA ||i._strlen||, CODE, READONLY, ALIGN=1

                  _strlen PROC
;;;165    */
;;;166    static int _strlen(const char* s) {
000000  4601              MOV      r1,r0
;;;167      int Len;
;;;168    
;;;169      Len = 0;
000002  2200              MOVS     r2,#0
;;;170      if (s == NULL) {
000004  b909              CBNZ     r1,|L9.10|
;;;171        return 0;
000006  2000              MOVS     r0,#0
                  |L9.8|
;;;172      }
;;;173      do {
;;;174        if (*s == 0) {
;;;175          break;
;;;176        }
;;;177        Len++;
;;;178        s++;
;;;179      } while (1);
;;;180      return Len;
;;;181    }
000008  4770              BX       lr
                  |L9.10|
00000a  bf00              NOP                            ;173
                  |L9.12|
00000c  7808              LDRB     r0,[r1,#0]            ;174
00000e  b900              CBNZ     r0,|L9.18|
000010  e002              B        |L9.24|
                  |L9.18|
000012  1c52              ADDS     r2,r2,#1              ;177
000014  1c49              ADDS     r1,r1,#1              ;178
000016  e7f9              B        |L9.12|
                  |L9.24|
000018  bf00              NOP                            ;175
00001a  4610              MOV      r0,r2                 ;180
00001c  e7f4              B        |L9.8|
;;;182    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16
                  _acUpBuffer1
                          %        1024
                  _acDownBuffer1
                          %        16

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5465726d          DCB      "Terminal",0
000004  696e616c
000008  00      
000009  00                DCB      0
00000a  00                DCB      0
00000b  00                DCB      0
00000c  4c6f6700          DCB      "Log",0

                          AREA ||.data||, DATA, ALIGN=2

                  _SEGGER_RTT
000000  53454747          DCB      0x53,0x45,0x47,0x47
000004  45522052          DCB      0x45,0x52,0x20,0x52
000008  54540000          DCB      0x54,0x54,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000002
                          DCD      ||.conststring||
                          DCD      _acUpBuffer
                          DCD      0x00000400
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ||.conststring||+0xc
                          DCD      _acUpBuffer1
                          DCD      0x00000400
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ||.conststring||
                          DCD      _acDownBuffer
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ||.conststring||+0xc
                          DCD      _acDownBuffer1
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\rf.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\rf.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\rf.crf ..\BSP\apps\RF.c]
                          THUMB

                          AREA ||i.askForDataPeriod||, CODE, READONLY, ALIGN=2

                  askForDataPeriod PROC
;;;1416   
;;;1417   void askForDataPeriod(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1418   {
;;;1419   	static uint8_t canCheckCnt = 0;
;;;1420   	static uint8_t node_cycle = 1;
;;;1421   	uint8_t i;
;;;1422   	uint8_t result = 0;
000002  2500              MOVS     r5,#0
;;;1423   	bool flag = false;
000004  2600              MOVS     r6,#0
;;;1424   	static volatile TickType_t currentTime;	
;;;1425   	
;;;1426   	if (xTaskGetTickCount() - currentTime >= TRAVERSE_PERIOD) {//定时轮询
000006  f7fffffe          BL       xTaskGetTickCount
00000a  4920              LDR      r1,|L1.140|
00000c  6809              LDR      r1,[r1,#0]  ; currentTime
00000e  1a40              SUBS     r0,r0,r1
000010  281e              CMP      r0,#0x1e
000012  d304              BCC      |L1.30|
;;;1427   		currentTime = xTaskGetTickCount();
000014  f7fffffe          BL       xTaskGetTickCount
000018  491c              LDR      r1,|L1.140|
00001a  6008              STR      r0,[r1,#0]  ; currentTime
;;;1428   		flag = true;
00001c  2601              MOVS     r6,#1
                  |L1.30|
;;;1429   	}	
;;;1430   	
;;;1431   	if (node_cycle >= /*gNodesOnLine*/NODE_ID_NUM_MAX) {//超过节点数  
00001e  481c              LDR      r0,|L1.144|
000020  7800              LDRB     r0,[r0,#0]  ; node_cycle
000022  280a              CMP      r0,#0xa
000024  db1f              BLT      |L1.102|
;;;1432   		if (canCheckCnt++ > 1) {//初始时为0  ???
000026  481b              LDR      r0,|L1.148|
000028  7801              LDRB     r1,[r0,#0]  ; canCheckCnt
00002a  7800              LDRB     r0,[r0,#0]  ; canCheckCnt
00002c  1c40              ADDS     r0,r0,#1
00002e  4a19              LDR      r2,|L1.148|
000030  7010              STRB     r0,[r2,#0]
000032  2901              CMP      r1,#1
000034  dd17              BLE      |L1.102|
;;;1433   			for (i = 1; i < /*gNodesOnLine*/NODE_ID_NUM_MAX; i++) {
000036  2401              MOVS     r4,#1
000038  e009              B        |L1.78|
                  |L1.58|
;;;1434   				result = result + node[i].state;//node[i].state为每个节点的状态 
00003a  eb041004          ADD      r0,r4,r4,LSL #4
00003e  4916              LDR      r1,|L1.152|
000040  eb010040          ADD      r0,r1,r0,LSL #1
000044  7840              LDRB     r0,[r0,#1]
000046  4428              ADD      r0,r0,r5
000048  b2c5              UXTB     r5,r0
00004a  1c60              ADDS     r0,r4,#1              ;1433
00004c  b2c4              UXTB     r4,r0                 ;1433
                  |L1.78|
00004e  2c0a              CMP      r4,#0xa               ;1433
000050  dbf3              BLT      |L1.58|
;;;1435   			}
;;;1436   
;;;1437   			if (result == 0) { //! no node online, start a new mesh
000052  b92d              CBNZ     r5,|L1.96|
;;;1438   				node_cycle = 1;
000054  2001              MOVS     r0,#1
000056  490e              LDR      r1,|L1.144|
000058  7008              STRB     r0,[r1,#0]
;;;1439   				meshMode = MESH_MODE_START_MESH;//开始组网
00005a  2002              MOVS     r0,#2
00005c  490f              LDR      r1,|L1.156|
00005e  7008              STRB     r0,[r1,#0]
                  |L1.96|
;;;1440   			}
;;;1441   			canCheckCnt = 0;
000060  2000              MOVS     r0,#0
000062  490c              LDR      r1,|L1.148|
000064  7008              STRB     r0,[r1,#0]
                  |L1.102|
;;;1442   		}
;;;1443   	}	
;;;1444   		
;;;1445   	if (flag == true) {			
000066  2e01              CMP      r6,#1
000068  d10f              BNE      |L1.138|
;;;1446   		if (node_cycle >= /*(gNodesOnLine+1)*/NODE_ID_NUM_MAX) {//超过最大节点数
00006a  4809              LDR      r0,|L1.144|
00006c  7800              LDRB     r0,[r0,#0]  ; node_cycle
00006e  280a              CMP      r0,#0xa
000070  db02              BLT      |L1.120|
;;;1447   			node_cycle = 1;
000072  2001              MOVS     r0,#1
000074  4906              LDR      r1,|L1.144|
000076  7008              STRB     r0,[r1,#0]
                  |L1.120|
;;;1448   		}
;;;1449   		
;;;1450   		msg_ask_for_data_send(node_cycle); //对节点轮询
000078  4805              LDR      r0,|L1.144|
00007a  7800              LDRB     r0,[r0,#0]  ; node_cycle
00007c  f7fffffe          BL       msg_ask_for_data_send
;;;1451   		node_cycle++;
000080  4803              LDR      r0,|L1.144|
000082  7800              LDRB     r0,[r0,#0]  ; node_cycle
000084  1c40              ADDS     r0,r0,#1
000086  4902              LDR      r1,|L1.144|
000088  7008              STRB     r0,[r1,#0]
                  |L1.138|
;;;1452   		
;;;1453   	} else {
;;;1454   
;;;1455   	}		
;;;1456   }
00008a  bd70              POP      {r4-r6,pc}
;;;1457   //从机网络运行任务
                          ENDP

                  |L1.140|
                          DCD      |symbol_number.91|
                  |L1.144|
                          DCD      node_cycle
                  |L1.148|
                          DCD      canCheckCnt
                  |L1.152|
                          DCD      node
                  |L1.156|
                          DCD      meshMode

                          AREA ||i.checkNodesStatePeriod||, CODE, READONLY, ALIGN=2

                  checkNodesStatePeriod PROC
;;;1391   }
;;;1392   void checkNodesStatePeriod(void) //检查从机状态阶段
000000  b570              PUSH     {r4-r6,lr}
;;;1393   {
;;;1394   	uint8_t i;
;;;1395   	bool flag = false;
000002  2500              MOVS     r5,#0
;;;1396   	static volatile TickType_t currentTime;	
;;;1397   	
;;;1398   	if (xTaskGetTickCount() - currentTime >= TRAVERSE_PERIOD) {
000004  f7fffffe          BL       xTaskGetTickCount
000008  491d              LDR      r1,|L2.128|
00000a  6809              LDR      r1,[r1,#0]  ; currentTime
00000c  1a40              SUBS     r0,r0,r1
00000e  281e              CMP      r0,#0x1e
000010  d304              BCC      |L2.28|
;;;1399   		currentTime = xTaskGetTickCount();
000012  f7fffffe          BL       xTaskGetTickCount
000016  491a              LDR      r1,|L2.128|
000018  6008              STR      r0,[r1,#0]  ; currentTime
;;;1400   		flag = true;
00001a  2501              MOVS     r5,#1
                  |L2.28|
;;;1401   	}
;;;1402   
;;;1403   	if (flag == true) {
00001c  2d01              CMP      r5,#1
00001e  d12d              BNE      |L2.124|
;;;1404   		gNodesOnLine = 0;
000020  2000              MOVS     r0,#0
000022  4918              LDR      r1,|L2.132|
000024  7008              STRB     r0,[r1,#0]
;;;1405   		for (i = 1; i < NODE_ID_NUM_MAX; i++) { //! check all the nodes 
000026  2401              MOVS     r4,#1
000028  e026              B        |L2.120|
                  |L2.42|
;;;1406   			if (node[i].bad_cnt >= NODE_BAD_CNT_MAX) {
00002a  eb041004          ADD      r0,r4,r4,LSL #4
00002e  4916              LDR      r1,|L2.136|
000030  eb010040          ADD      r0,r1,r0,LSL #1
000034  7880              LDRB     r0,[r0,#2]
000036  2805              CMP      r0,#5
000038  db11              BLT      |L2.94|
;;;1407   				memset(&node[i], 0, sizeof(node_t));	//! node[i].state = NODE_STATE_OFFLINE;	
00003a  eb041104          ADD      r1,r4,r4,LSL #4
00003e  4a12              LDR      r2,|L2.136|
000040  eb020041          ADD      r0,r2,r1,LSL #1
000044  2122              MOVS     r1,#0x22
000046  f7fffffe          BL       __aeabi_memclr
;;;1408   				memset(&gITASMsg.payload.node[i-1], 0, sizeof(node_t));
00004a  1e61              SUBS     r1,r4,#1
00004c  eb011201          ADD      r2,r1,r1,LSL #4
000050  490e              LDR      r1,|L2.140|
000052  eb010042          ADD      r0,r1,r2,LSL #1
000056  2122              MOVS     r1,#0x22
000058  f7fffffe          BL       __aeabi_memclr
00005c  e00a              B        |L2.116|
                  |L2.94|
;;;1409   				
;;;1410   			} else if (node[i].id != 0) {
00005e  eb041004          ADD      r0,r4,r4,LSL #4
000062  4909              LDR      r1,|L2.136|
000064  f8110010          LDRB     r0,[r1,r0,LSL #1]
000068  b120              CBZ      r0,|L2.116|
;;;1411   				gNodesOnLine++;// 
00006a  4806              LDR      r0,|L2.132|
00006c  7800              LDRB     r0,[r0,#0]  ; gNodesOnLine
00006e  1c40              ADDS     r0,r0,#1
000070  4904              LDR      r1,|L2.132|
000072  7008              STRB     r0,[r1,#0]
                  |L2.116|
000074  1c60              ADDS     r0,r4,#1              ;1405
000076  b2c4              UXTB     r4,r0                 ;1405
                  |L2.120|
000078  2c0a              CMP      r4,#0xa               ;1405
00007a  dbd6              BLT      |L2.42|
                  |L2.124|
;;;1412   			}
;;;1413   		}
;;;1414   	}
;;;1415   }
00007c  bd70              POP      {r4-r6,pc}
;;;1416   
                          ENDP

00007e  0000              DCW      0x0000
                  |L2.128|
                          DCD      currentTime
                  |L2.132|
                          DCD      gNodesOnLine
                  |L2.136|
                          DCD      node
                  |L2.140|
                          DCD      gITASMsg+0xf

                          AREA ||i.handleMessage||, CODE, READONLY, ALIGN=1

                  handleMessage PROC
;;;1835   /*该节点作为从机  SLAVE*/
;;;1836   void handleMessage(message_t *msg)
000000  b510              PUSH     {r4,lr}
;;;1837   {
000002  4604              MOV      r4,r0
;;;1838   	switch(msg->msg_id)
000004  78e0              LDRB     r0,[r4,#3]
000006  2851              CMP      r0,#0x51
000008  d004              BEQ      |L3.20|
00000a  2854              CMP      r0,#0x54
00000c  d006              BEQ      |L3.28|
00000e  2856              CMP      r0,#0x56
000010  d10c              BNE      |L3.44|
000012  e007              B        |L3.36|
                  |L3.20|
;;;1839   	{
;;;1840   		case MSG_ID_ASK_FOR_DATA://由主机发送给从机 从机处理主机发送的轮询指令
;;;1841   			handle_msg_ask_for_data(msg);	
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       handle_msg_ask_for_data
;;;1842   			break;
00001a  e008              B        |L3.46|
                  |L3.28|
;;;1843   	
;;;1844   ////		case MSG_ID_ACK_FOR_DATA://由从机向主机回复的数据  主机可用
;;;1845   ////			handle_msg_ack_for_data(msg);
;;;1846   ////			break;	
;;;1847   
;;;1848   ////		case MSG_ID_ASK_FOR_ID://由从机向主机回复的数据  主机处理
;;;1849   ////			handle_msg_ask_for_id(msg);
;;;1850   ////			break;	
;;;1851   
;;;1852   ////		case MSG_ID_ACK_FOR_ID:/，由从机发送给主机的ID确认命令，主机若收到该命令则认为ID分配成功，
;;;1853   ////									//	否则会连续发送三次分配ID命令，若均没收到该消息则不再给该节点分配ID
;;;1854   ////			handle_msg_ack_for_id(msg);
;;;1855   ////			break;
;;;1856   
;;;1857   		case MSG_ID_ASSIGN_ID://从机接收到主机的分配ID指令之后，写入自己的current_node
;;;1858   			handle_msg_assign_id(msg);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       handle_msg_assign_id
;;;1859   			break;
000022  e004              B        |L3.46|
                  |L3.36|
;;;1860   
;;;1861   		case MSG_ID_START_MESH: //从机处理主机发送的重新请求id指令
;;;1862   			handle_msg_start_mesh(msg);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       handle_msg_start_mesh
;;;1863   			break;
00002a  e000              B        |L3.46|
                  |L3.44|
;;;1864   		
;;;1865   		default: 
;;;1866   			break;
00002c  bf00              NOP      
                  |L3.46|
00002e  bf00              NOP                            ;1842
;;;1867   	}
;;;1868   }
000030  bd10              POP      {r4,pc}
;;;1869   
                          ENDP


                          AREA ||i.handle_msg_ack_for_data||, CODE, READONLY, ALIGN=2

                  handle_msg_ack_for_data PROC
;;;1606   //! slaver -> master
;;;1607   static void handle_msg_ack_for_data(const message_t *msg)
000000  b53e              PUSH     {r1-r5,lr}
;;;1608   {
000002  4605              MOV      r5,r0
;;;1609   	uint8_t i;
;;;1610   	msg_ack_for_data_t message;
;;;1611   	memcpy(&message, &msg->payload[0], sizeof(message));
000004  6868              LDR      r0,[r5,#4]
000006  9000              STR      r0,[sp,#0]
000008  68a8              LDR      r0,[r5,#8]
00000a  9001              STR      r0,[sp,#4]
00000c  68e8              LDR      r0,[r5,#0xc]
00000e  9002              STR      r0,[sp,#8]
;;;1612   	for (i = 1; i < NODE_ID_NUM_MAX; i++) {	//! traverse the entire array which saves all the nodes 
000010  2401              MOVS     r4,#1
000012  e04f              B        |L4.180|
                  |L4.20|
;;;1613   		if (node[i].id == message.slave_addr2) {
000014  eb041004          ADD      r0,r4,r4,LSL #4
000018  4928              LDR      r1,|L4.188|
00001a  f8110010          LDRB     r0,[r1,r0,LSL #1]
00001e  f89d1002          LDRB     r1,[sp,#2]
000022  4288              CMP      r0,r1
000024  d143              BNE      |L4.174|
;;;1614   			
;;;1615   
;;;1616   			
;;;1617   			node[i].state 	  		= NODE_STATE_ONLINE;
000026  2001              MOVS     r0,#1
000028  eb041104          ADD      r1,r4,r4,LSL #4
00002c  4a23              LDR      r2,|L4.188|
00002e  eb020141          ADD      r1,r2,r1,LSL #1
000032  7048              STRB     r0,[r1,#1]
;;;1618   			node[i].bad_cnt	  		= 0;//! if the data ack ok, then the bad_cnt will be reset to 0, which means this slaver(node) is ok.
000034  2000              MOVS     r0,#0
000036  eb041104          ADD      r1,r4,r4,LSL #4
00003a  eb020141          ADD      r1,r2,r1,LSL #1
00003e  7088              STRB     r0,[r1,#2]
;;;1619   //			node[i].dev_type  		= message.dev_type; 	
;;;1620   			
;;;1621   			node[i].location2 		= message.location2; 
000040  f89d0004          LDRB     r0,[sp,#4]
000044  eb041104          ADD      r1,r4,r4,LSL #4
000048  eb020141          ADD      r1,r2,r1,LSL #1
00004c  71c8              STRB     r0,[r1,#7]
;;;1622   			
;;;1623   			node[i].trigger_num		= message.trigger_num;
00004e  f89d0005          LDRB     r0,[sp,#5]
000052  eb041104          ADD      r1,r4,r4,LSL #4
000056  eb020141          ADD      r1,r2,r1,LSL #1
00005a  7288              STRB     r0,[r1,#0xa]
;;;1624   			node[i].trigger_vehicle1	= message.trigger_vehicle1;
00005c  f89d0006          LDRB     r0,[sp,#6]
000060  eb041104          ADD      r1,r4,r4,LSL #4
000064  eb020141          ADD      r1,r2,r1,LSL #1
000068  72c8              STRB     r0,[r1,#0xb]
;;;1625   			node[i].trigger_video2	= message.trigger_video2;
00006a  f89d0007          LDRB     r0,[sp,#7]
00006e  eb041104          ADD      r1,r4,r4,LSL #4
000072  eb020141          ADD      r1,r2,r1,LSL #1
000076  7308              STRB     r0,[r1,#0xc]
;;;1626   			node[i].trigger_microwave3	= message.trigger_microwave3;
000078  f89d0008          LDRB     r0,[sp,#8]
00007c  eb041104          ADD      r1,r4,r4,LSL #4
000080  eb020141          ADD      r1,r2,r1,LSL #1
000084  7348              STRB     r0,[r1,#0xd]
;;;1627   //			trigger_reserve1;
;;;1628   //			uint16_t reserved_2;
;;;1629   
;;;1630   			gITASMsg.payload.nodeOnlineNum		= gNodesOnLine;
000086  480e              LDR      r0,|L4.192|
000088  7801              LDRB     r1,[r0,#0]  ; gNodesOnLine
00008a  480e              LDR      r0,|L4.196|
00008c  7381              STRB     r1,[r0,#0xe]
;;;1631   			memcpy(&gITASMsg.payload.node[i-1], &node[i], sizeof(node_t));
00008e  eb041204          ADD      r2,r4,r4,LSL #4
000092  4b0a              LDR      r3,|L4.188|
000094  eb030142          ADD      r1,r3,r2,LSL #1
000098  1e62              SUBS     r2,r4,#1
00009a  eb021302          ADD      r3,r2,r2,LSL #4
00009e  f100020f          ADD      r2,r0,#0xf
0000a2  eb020043          ADD      r0,r2,r3,LSL #1
0000a6  2222              MOVS     r2,#0x22
0000a8  f7fffffe          BL       __aeabi_memcpy
;;;1632   			break;
0000ac  e004              B        |L4.184|
                  |L4.174|
;;;1633   			
;;;1634   		} else if (i >= NODE_ID_NUM_MAX - 1) {
0000ae  bf00              NOP      
0000b0  1c60              ADDS     r0,r4,#1              ;1612
0000b2  b2c4              UXTB     r4,r0                 ;1612
                  |L4.180|
0000b4  2c0a              CMP      r4,#0xa               ;1612
0000b6  dbad              BLT      |L4.20|
                  |L4.184|
0000b8  bf00              NOP                            ;1632
;;;1635   //			msg_start_mesh_send();
;;;1636   		}			
;;;1637   	}
;;;1638   //	ledFlashSet(LED_MESH, 1, 5, 1);
;;;1639   }
0000ba  bd3e              POP      {r1-r5,pc}
;;;1640   
                          ENDP

                  |L4.188|
                          DCD      node
                  |L4.192|
                          DCD      gNodesOnLine
                  |L4.196|
                          DCD      gITASMsg

                          AREA ||i.handle_msg_ack_for_id||, CODE, READONLY, ALIGN=1

                  handle_msg_ack_for_id PROC
;;;1698   //主机处理 查询从机ID的指令 
;;;1699   static void handle_msg_ack_for_id(const message_t *msg)
000000  4770              BX       lr
;;;1700   {
;;;1701   //	msg_ack_for_id_t message;
;;;1702   //	memcpy(&message, &msg->payload[0], sizeof(message));
;;;1703   	return;	
;;;1704   }
;;;1705   
                          ENDP


                          AREA ||i.handle_msg_ask_for_data||, CODE, READONLY, ALIGN=2

                  handle_msg_ask_for_data PROC
;;;1553   uint16_t gRadioNoDataCnt = 0;
;;;1554   static void handle_msg_ask_for_data(const message_t *msg)
000000  b530              PUSH     {r4,r5,lr}
;;;1555   {		
000002  b08d              SUB      sp,sp,#0x34
000004  4604              MOV      r4,r0
;;;1556   	msg_ask_for_data_t message;
;;;1557   	memcpy(&message, &msg->payload[0], sizeof(message));
000006  220d              MOVS     r2,#0xd
000008  1d21              ADDS     r1,r4,#4
00000a  a809              ADD      r0,sp,#0x24
00000c  f7fffffe          BL       __aeabi_memcpy
;;;1558   	
;;;1559   	gRadioNoDataCnt = 0;	//! when received a msg, this value will be reset to 0.
000010  2000              MOVS     r0,#0
000012  4927              LDR      r1,|L6.176|
000014  8008              STRH     r0,[r1,#0]
;;;1560   	gNetworkRunning = true;	//! means the net is in running mode
000016  2001              MOVS     r0,#1
000018  4926              LDR      r1,|L6.180|
00001a  7008              STRB     r0,[r1,#0]
;;;1561   	
;;;1562   	if (message.slave_addr2 == 0) {
00001c  f89d0026          LDRB     r0,[sp,#0x26]
000020  b908              CBNZ     r0,|L6.38|
                  |L6.34|
;;;1563   		return;	//! there must be something wrong with master, just give no ack
;;;1564   	}
;;;1565    
;;;1566   	if ((message.slave_addr2 == current_node.slave_addr2)||(message.slave_addr2 == current_node.id)){
;;;1567   
;;;1568   		gMeshFinished = 1;
;;;1569   		
;;;1570   //		printf("slave_addr2 %d:  \n",current_node.slave_addr2);
;;;1571   		current_node.bad_cnt = 0;     //! can receive this msg means communication is OK!
;;;1572   		
;;;1573   		current_node.spikelamp_switch1 = message.spikelamp_switch1;
;;;1574   		current_node.voice_switch2     = message.voice_switch2;
;;;1575   		current_node.led_switch3       = message.led_switch3;
;;;1576   		current_node.reserve1_switch   = message.reserve1_switch;
;;;1577   		current_node.reserve2_switch   = message.reserve2_switch;
;;;1578   		current_node.reserve3_switch   = message.reserve3_switch;
;;;1579   		
;;;1580   //		KM_spikelamp_switch1 = message.spikelamp_switch1;
;;;1581   //		KM_voice_switch2     = message.voice_switch2;
;;;1582   //		KM_led_switch3       = message.led_switch3;
;;;1583   //		KM_reserve1_switch   = message.reserve1_switch;
;;;1584   //		KM_reserve2_switch   = message.reserve2_switch;
;;;1585   //		KM_reserve3_switch   = message.reserve3_switch;
;;;1586   	
;;;1587   		msg_ack_for_data_send(  current_node.master_addr,
;;;1588   								current_node.slave_addr1,
;;;1589   								current_node.slave_addr2,
;;;1590   								current_node.location1,
;;;1591   								current_node.location2,
;;;1592   								current_node.trigger_num,
;;;1593   								current_node.trigger_vehicle1,
;;;1594   								current_node.trigger_video2,
;;;1595   								current_node.trigger_microwave3,
;;;1596   								current_node.trigger_reserve1,
;;;1597   								current_node.reserve1,
;;;1598   								current_node.reserve2
;;;1599   							 );
;;;1600   //		printf("ack for data my id : %d \n", current_node.slave_addr2);
;;;1601   //		ledFlashSet(1, 200, 5);
;;;1602   	}
;;;1603   	else
;;;1604   	{};	
;;;1605   }
000022  b00d              ADD      sp,sp,#0x34
000024  bd30              POP      {r4,r5,pc}
                  |L6.38|
000026  f89d0026          LDRB     r0,[sp,#0x26]         ;1566
00002a  4923              LDR      r1,|L6.184|
00002c  7949              LDRB     r1,[r1,#5]            ;1566  ; current_node
00002e  4288              CMP      r0,r1                 ;1566
000030  d005              BEQ      |L6.62|
000032  f89d0026          LDRB     r0,[sp,#0x26]         ;1566
000036  4920              LDR      r1,|L6.184|
000038  7809              LDRB     r1,[r1,#0]            ;1566  ; current_node
00003a  4288              CMP      r0,r1                 ;1566
00003c  d135              BNE      |L6.170|
                  |L6.62|
00003e  2001              MOVS     r0,#1                 ;1568
000040  491e              LDR      r1,|L6.188|
000042  7008              STRB     r0,[r1,#0]            ;1568
000044  2000              MOVS     r0,#0                 ;1571
000046  491c              LDR      r1,|L6.184|
000048  7088              STRB     r0,[r1,#2]            ;1571
00004a  f89d0029          LDRB     r0,[sp,#0x29]         ;1573
00004e  73c8              STRB     r0,[r1,#0xf]          ;1573
000050  f89d002a          LDRB     r0,[sp,#0x2a]         ;1574
000054  7408              STRB     r0,[r1,#0x10]         ;1574
000056  f89d002b          LDRB     r0,[sp,#0x2b]         ;1575
00005a  7448              STRB     r0,[r1,#0x11]         ;1575
00005c  f89d002c          LDRB     r0,[sp,#0x2c]         ;1576
000060  7488              STRB     r0,[r1,#0x12]         ;1576
000062  f89d002d          LDRB     r0,[sp,#0x2d]         ;1577
000066  74c8              STRB     r0,[r1,#0x13]         ;1577
000068  f89d002e          LDRB     r0,[sp,#0x2e]         ;1578
00006c  7508              STRB     r0,[r1,#0x14]         ;1578
00006e  4608              MOV      r0,r1                 ;1587
000070  7a40              LDRB     r0,[r0,#9]            ;1587  ; current_node
000072  7a09              LDRB     r1,[r1,#8]            ;1587  ; current_node
000074  4a10              LDR      r2,|L6.184|
000076  7b92              LDRB     r2,[r2,#0xe]          ;1587  ; current_node
000078  4b0f              LDR      r3,|L6.184|
00007a  7b5b              LDRB     r3,[r3,#0xd]          ;1587  ; current_node
00007c  e9cd3204          STRD     r3,r2,[sp,#0x10]      ;1587
000080  e9cd1006          STRD     r1,r0,[sp,#0x18]      ;1587
000084  480c              LDR      r0,|L6.184|
000086  7b00              LDRB     r0,[r0,#0xc]          ;1587  ; current_node
000088  490b              LDR      r1,|L6.184|
00008a  7ac9              LDRB     r1,[r1,#0xb]          ;1587  ; current_node
00008c  4a0a              LDR      r2,|L6.184|
00008e  7a92              LDRB     r2,[r2,#0xa]          ;1587  ; current_node
000090  4b09              LDR      r3,|L6.184|
000092  79db              LDRB     r3,[r3,#7]            ;1587  ; current_node
000094  4d08              LDR      r5,|L6.184|
000096  e9cd3200          STRD     r3,r2,[sp,#0]         ;1587
00009a  e9cd1002          STRD     r1,r0,[sp,#8]         ;1587
00009e  79ab              LDRB     r3,[r5,#6]            ;1587  ; current_node
0000a0  796a              LDRB     r2,[r5,#5]            ;1587  ; current_node
0000a2  7929              LDRB     r1,[r5,#4]            ;1587  ; current_node
0000a4  78e8              LDRB     r0,[r5,#3]            ;1587  ; current_node
0000a6  f7fffffe          BL       msg_ack_for_data_send
                  |L6.170|
0000aa  bf00              NOP      
0000ac  e7b9              B        |L6.34|
;;;1606   //! slaver -> master
                          ENDP

0000ae  0000              DCW      0x0000
                  |L6.176|
                          DCD      gRadioNoDataCnt
                  |L6.180|
                          DCD      gNetworkRunning
                  |L6.184|
                          DCD      current_node
                  |L6.188|
                          DCD      gMeshFinished

                          AREA ||i.handle_msg_ask_for_id||, CODE, READONLY, ALIGN=1

                  handle_msg_ask_for_id PROC
;;;1641   //! slaver -> master
;;;1642   static void handle_msg_ask_for_id(const message_t *msg)
000000  4770              BX       lr
;;;1643   {
;;;1644   //	uint8_t i;
;;;1645   //	bool need_trav_ids = false;
;;;1646   //	msg_ask_for_id_t message;
;;;1647   //	memcpy(&message, &msg->payload[0], sizeof(message));
;;;1648   //	gGetStartNewMeshAck = true;
;;;1649   //	gMeshFinished = false; //! there still some nodes want to join into the net, mesh not finished 
;;;1650   //	gNoneAskForCnt = 0;
;;;1651   //	//! traverse the entire array which saves all the nodes. i prefer to traverse mac first, if this mac has been existed, then assign the corresponding id to the node 
;;;1652   //	//! if can not find this mac, then traverse the id from 1 to max, assign the seq as id till the corresponding id is zero.
;;;1653   //	for (i = 1; i < NODE_ID_NUM_MAX; i++) {
;;;1654   //		if ((node[i].mac[0] == message.mac[0]) && (node[i].mac[1] == message.mac[1]) && (node[i].mac[2] == message.mac[2])) {
;;;1655   //			node[i].bad_cnt = 0; //! another place always check this value, if this node down less than n times, and here assign the same id again, we should reset the bad_cnt in case be reseted again 
;;;1656   //			node[i].c_base_red		= message.c_base_red;
;;;1657   //			node[i].c_base_yellow	= message.c_base_yellow;
;;;1658   //			node[i].c_base_green	= message.c_base_green;
;;;1659   //			need_trav_ids = false;
;;;1660   //			msg_assign_id_send(i, message.mac[0], message.mac[1], message.mac[2], NODE_BAD_CNT_MAX*NODE_ID_NUM_MAX*TRAVERSE_PERIOD/1000);
;;;1661   //			break;
;;;1662   //		
;;;1663   //		} else if (i >= NODE_ID_NUM_MAX-1) {
;;;1664   //			need_trav_ids = true;
;;;1665   //		}
;;;1666   //	}
;;;1667   
;;;1668   //	//! if need, traverse the ids
;;;1669   //	if (need_trav_ids == true) {
;;;1670   //		need_trav_ids = false;
;;;1671   //		
;;;1672   //		for (i = 1; i < NODE_ID_NUM_MAX; i++) { 
;;;1673   //			if (node[i].id == 0) {				 
;;;1674   //				node[i].id     = i;
;;;1675   //				node[i].mac[0] = message.mac[0];
;;;1676   //				node[i].mac[1] = message.mac[1];
;;;1677   //				node[i].mac[2] = message.mac[2];
;;;1678   //				node[i].c_base_red		= message.c_base_red;
;;;1679   //				node[i].c_base_yellow	= message.c_base_yellow;
;;;1680   //				node[i].c_base_green	= message.c_base_green;
;;;1681   //				
;;;1682   //				msg_assign_id_send(i, message.mac[0], message.mac[1], message.mac[2], NODE_BAD_CNT_MAX * NODE_ID_NUM_MAX * TRAVERSE_PERIOD /1000);
;;;1683   //				break; //! must quit out otherwise will assign all the idle nodes
;;;1684   //		
;;;1685   //			} else if (i >= NODE_ID_NUM_MAX-1) { //! it means the active nodes up to MAX, then reject this node mesh
;;;1686   //				msg_assign_id_send(255, message.mac[0], message.mac[1], message.mac[2],  NODE_BAD_CNT_MAX * NODE_ID_NUM_MAX * TRAVERSE_PERIOD /1000);
;;;1687   //				
;;;1688   //			} else {
;;;1689   //				//! normal
;;;1690   //			}				
;;;1691   //		}
;;;1692   //		
;;;1693   //	}
;;;1694   }
;;;1695   
                          ENDP


                          AREA ||i.handle_msg_assign_id||, CODE, READONLY, ALIGN=2

                  handle_msg_assign_id PROC
;;;1707   //从机处理主机的分配ID指令
;;;1708   static void handle_msg_assign_id(const message_t *msg)//0X54
000000  b51f              PUSH     {r0-r4,lr}
;;;1709   {
000002  4604              MOV      r4,r0
;;;1710   	msg_assign_id_t message;
;;;1711   	memcpy(&message, &msg->payload[0], sizeof(message));	
000004  2210              MOVS     r2,#0x10
000006  1d21              ADDS     r1,r4,#4
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy
;;;1712   	
;;;1713   	if ((message.mac[0] != current_node.mac[0])||(message.mac[1] != current_node.mac[1])||(message.mac[2] != current_node.mac[2])) {
00000e  f8dd0001          LDR      r0,[sp,#1]
000012  4917              LDR      r1,|L8.112|
000014  f8d11016          LDR      r1,[r1,#0x16]  ; current_node
000018  4288              CMP      r0,r1
00001a  d10d              BNE      |L8.56|
00001c  f8dd1005          LDR      r1,[sp,#5]
000020  4813              LDR      r0,|L8.112|
000022  f8d0001a          LDR      r0,[r0,#0x1a]
000026  4281              CMP      r1,r0
000028  d106              BNE      |L8.56|
00002a  f8dd1009          LDR      r1,[sp,#9]
00002e  4810              LDR      r0,|L8.112|
000030  f8d0001e          LDR      r0,[r0,#0x1e]
000034  4281              CMP      r1,r0
000036  d00f              BEQ      |L8.88|
                  |L8.56|
;;;1714   //		printf("this is not my mac! \n");
;;;1715   		if ((message.node_id == current_node.slave_addr2)||(message.node_id == current_node.slave_addr2)) { //! my id is reassigned to other nodes, i have to apply for a new id 
000038  f89d0000          LDRB     r0,[sp,#0]
00003c  490c              LDR      r1,|L8.112|
00003e  7949              LDRB     r1,[r1,#5]  ; current_node
000040  4288              CMP      r0,r1
000042  d005              BEQ      |L8.80|
000044  f89d0000          LDRB     r0,[sp,#0]
000048  4909              LDR      r1,|L8.112|
00004a  7949              LDRB     r1,[r1,#5]  ; current_node
00004c  4288              CMP      r0,r1
00004e  d10d              BNE      |L8.108|
                  |L8.80|
;;;1716   			current_node.slave_addr2 = 0;
000050  2000              MOVS     r0,#0
000052  4907              LDR      r1,|L8.112|
000054  7148              STRB     r0,[r1,#5]
000056  e009              B        |L8.108|
                  |L8.88|
;;;1717   //			printf("i have to re apply for my id \n");
;;;1718   		}
;;;1719   		
;;;1720   	} else {
;;;1721   		current_node.slave_addr2 = message.node_id;
000058  f89d0000          LDRB     r0,[sp,#0]
00005c  4904              LDR      r1,|L8.112|
00005e  7148              STRB     r0,[r1,#5]
;;;1722   		current_node.id          = message.node_id;
000060  f89d0000          LDRB     r0,[sp,#0]
000064  7008              STRB     r0,[r1,#0]
;;;1723   		current_node.cfdt		 = message.cfdt;
000066  f89d000d          LDRB     r0,[sp,#0xd]
00006a  7548              STRB     r0,[r1,#0x15]
                  |L8.108|
;;;1724   	}
;;;1725   }
00006c  bd1f              POP      {r0-r4,pc}
;;;1726   
                          ENDP

00006e  0000              DCW      0x0000
                  |L8.112|
                          DCD      current_node

                          AREA ||i.handle_msg_start_mesh||, CODE, READONLY, ALIGN=2

                  handle_msg_start_mesh PROC
;;;1727   //重新组网指令
;;;1728   static void handle_msg_start_mesh(const message_t *msg)
000000  2100              MOVS     r1,#0
;;;1729   {
;;;1730   	current_node.slave_addr2 = 0;			//! start to mesh again
000002  4a02              LDR      r2,|L9.12|
000004  7151              STRB     r1,[r2,#5]
;;;1731   	gNetworkRunning = false;	//! means the net is in meshing mode
000006  4a02              LDR      r2,|L9.16|
000008  7011              STRB     r1,[r2,#0]
;;;1732   //	printf("start a new mesh \n");
;;;1733   }
00000a  4770              BX       lr
;;;1734   
                          ENDP

                  |L9.12|
                          DCD      current_node
                  |L9.16|
                          DCD      gNetworkRunning

                          AREA ||i.msg_ack_for_data_send||, CODE, READONLY, ALIGN=2

                  msg_ack_for_data_send PROC
;;;1195   //从机 回复主机 轮询指令
;;;1196   void msg_ack_for_data_send(
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1197   							uint8_t  master_addr,
;;;1198   							uint8_t  slave_addr1,
;;;1199   							uint8_t  slave_addr2,
;;;1200   							uint8_t  location1,
;;;1201   							uint8_t  location2,
;;;1202   							uint8_t  trigger_num,
;;;1203   							uint8_t	 trigger_vehicle1,//车检器触发
;;;1204   							uint8_t  trigger_video2,//视频触发
;;;1205   							uint8_t  trigger_microwave3,//微波触发
;;;1206   							uint8_t  trigger_reserve1,//预留触发
;;;1207   							uint8_t  reserve1,
;;;1208   							uint8_t  reserve2/*预留四个字节*/
;;;1209   							)
;;;1210   {	
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;1211   	static uint8_t			   msg[MSG_ACK_FOR_DATA_PAYLOAD_LEN + MSG_PAYLOAD_OFFSET];
;;;1212   	static msg_head_t	       msg_head;
;;;1213   	static msg_ack_for_data_t  payload;
;;;1214   
;;;1215   	msg_head.stx          = STX;
000014  20fe              MOVS     r0,#0xfe
000016  4921              LDR      r1,|L10.156|
000018  7008              STRB     r0,[r1,#0]
;;;1216   	msg_head.len          = MSG_ACK_FOR_DATA_PAYLOAD_LEN;
00001a  200c              MOVS     r0,#0xc
00001c  7048              STRB     r0,[r1,#1]
;;;1217   	msg_head.seq	      = MSG_RESERVE;
00001e  20ff              MOVS     r0,#0xff
000020  7088              STRB     r0,[r1,#2]
;;;1218   	msg_head.msg_id       = MSG_ID_ACK_FOR_DATA;
000022  2052              MOVS     r0,#0x52
000024  70c8              STRB     r0,[r1,#3]
;;;1219   
;;;1220   	payload.master_addr  = master_addr;
000026  481e              LDR      r0,|L10.160|
000028  7004              STRB     r4,[r0,#0]
;;;1221   	payload.slave_addr1  = slave_addr1;
00002a  7045              STRB     r5,[r0,#1]
;;;1222   	payload.slave_addr2  = slave_addr2;
00002c  7086              STRB     r6,[r0,#2]
;;;1223   	payload.location1    = location1;
00002e  70c7              STRB     r7,[r0,#3]
;;;1224   	payload.location2    = location2;
000030  f8808004          STRB     r8,[r0,#4]
;;;1225   
;;;1226   	payload.trigger_num	       = trigger_num;
000034  f8809005          STRB     r9,[r0,#5]
;;;1227   	payload.trigger_vehicle1   = trigger_vehicle1;
000038  f880a006          STRB     r10,[r0,#6]
;;;1228   	payload.trigger_video2     = trigger_video2;
00003c  f880b007          STRB     r11,[r0,#7]
;;;1229   	payload.trigger_microwave3 = trigger_microwave3;
000040  4917              LDR      r1,|L10.160|
000042  980e              LDR      r0,[sp,#0x38]
000044  7208              STRB     r0,[r1,#8]
;;;1230   	payload.trigger_reserve1   = trigger_reserve1;
000046  980f              LDR      r0,[sp,#0x3c]
000048  7248              STRB     r0,[r1,#9]
;;;1231   	payload.reserve1           = reserve1;
00004a  9810              LDR      r0,[sp,#0x40]
00004c  7288              STRB     r0,[r1,#0xa]
;;;1232   	payload.reserve2	       = reserve2;
00004e  9811              LDR      r0,[sp,#0x44]
000050  72c8              STRB     r0,[r1,#0xb]
;;;1233   	 
;;;1234   	memcpy(&msg, &msg_head, sizeof(msg_head));				   	//head 4字节
000052  4814              LDR      r0,|L10.164|
000054  4911              LDR      r1,|L10.156|
000056  6809              LDR      r1,[r1,#0]  ; msg_head
000058  6001              STR      r1,[r0,#0]  ; msg
;;;1235   	memcpy(&msg[sizeof(msg_head)], &payload, sizeof(payload));  //msg_ack_for_data_send payload 12字节
00005a  4911              LDR      r1,|L10.160|
00005c  680a              LDR      r2,[r1,#0]  ; payload
00005e  6042              STR      r2,[r0,#4]  ; msg
000060  684a              LDR      r2,[r1,#4]  ; payload
000062  6082              STR      r2,[r0,#8]  ; msg
000064  6889              LDR      r1,[r1,#8]  ; payload
000066  60c1              STR      r1,[r0,#0xc]  ; msg
;;;1236   	
;;;1237   	msg[sizeof(msg_head)+sizeof(payload)]   = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)) >> 8);	//! crc MSB  19
000068  210c              MOVS     r1,#0xc
00006a  1d00              ADDS     r0,r0,#4
00006c  f7fffffe          BL       crc16
000070  1200              ASRS     r0,r0,#8
000072  490c              LDR      r1,|L10.164|
000074  7408              STRB     r0,[r1,#0x10]
;;;1238   	msg[sizeof(msg_head)+sizeof(payload)+1] = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)));		//! crc LSB  18++
000076  210c              MOVS     r1,#0xc
000078  480a              LDR      r0,|L10.164|
00007a  1d00              ADDS     r0,r0,#4
00007c  f7fffffe          BL       crc16
000080  4908              LDR      r1,|L10.164|
000082  7448              STRB     r0,[r1,#0x11]
;;;1239   	msg[sizeof(msg_head)+sizeof(payload)+2] = END;  //20
000084  20ef              MOVS     r0,#0xef
000086  7488              STRB     r0,[r1,#0x12]
;;;1240   
;;;1241   	current_node.bad_cnt = 0;
000088  2000              MOVS     r0,#0
00008a  4907              LDR      r1,|L10.168|
00008c  7088              STRB     r0,[r1,#2]
;;;1242   	
;;;1243       MSG_SEND_USART_BYTES(msg, sizeof(msg));
00008e  2113              MOVS     r1,#0x13
000090  4804              LDR      r0,|L10.164|
000092  f7fffffe          BL       UART1_Send_char
;;;1244   //printf("slave_addr2 %d\r\n",slave_addr2);
;;;1245   }
000096  e8bd9ff0          POP      {r4-r12,pc}
;;;1246   /****************************************************************/
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
                          DCD      |symbol_number.82|
                  |L10.160|
                          DCD      |symbol_number.69|
                  |L10.164|
                          DCD      |symbol_number.68|
                  |L10.168|
                          DCD      current_node

                          AREA ||i.msg_ack_for_id_send||, CODE, READONLY, ALIGN=2

                  msg_ack_for_id_send PROC
;;;1331   
;;;1332   void msg_ack_for_id_send(uint8_t node_id, uint32_t mac_0, uint32_t mac_1, uint32_t mac_2) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1333   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1334   	static uint8_t msg[MSG_ACK_FOR_ID_PAYLOAD_LEN + MSG_PAYLOAD_OFFSET];
;;;1335   	static msg_head_t	     msg_head;
;;;1336   	static msg_ack_for_id_t  payload;
;;;1337   	
;;;1338   	msg_head.stx       = STX;//
00000c  20fe              MOVS     r0,#0xfe
00000e  491a              LDR      r1,|L11.120|
000010  7008              STRB     r0,[r1,#0]
;;;1339   	msg_head.len       = MSG_ACK_FOR_ID_PAYLOAD_LEN;//
000012  200f              MOVS     r0,#0xf
000014  7048              STRB     r0,[r1,#1]
;;;1340   	msg_head.seq	   = 0;//
000016  2000              MOVS     r0,#0
000018  7088              STRB     r0,[r1,#2]
;;;1341   	msg_head.msg_id    = MSG_ID_ACK_FOR_ID;//
00001a  2055              MOVS     r0,#0x55
00001c  70c8              STRB     r0,[r1,#3]
;;;1342   	
;;;1343   	payload.node_id    = node_id;//
00001e  4817              LDR      r0,|L11.124|
000020  7004              STRB     r4,[r0,#0]
;;;1344   	payload.mac[0]     = mac_0;//
000022  f8c05001          STR      r5,[r0,#1]  ; payload
;;;1345   	payload.mac[1]     = mac_1;//
000026  f8c06005          STR      r6,[r0,#5]
;;;1346   	payload.mac[2]     = mac_2;//
00002a  f8c07009          STR      r7,[r0,#9]
;;;1347       payload.reserve1   = 0;//
00002e  2000              MOVS     r0,#0
000030  4912              LDR      r1,|L11.124|
000032  7348              STRB     r0,[r1,#0xd]
;;;1348   	payload.reserve2   = 0;//
000034  7388              STRB     r0,[r1,#0xe]
;;;1349   	
;;;1350   	memcpy(&msg, &msg_head, sizeof(msg_head));
000036  4812              LDR      r0,|L11.128|
000038  490f              LDR      r1,|L11.120|
00003a  6809              LDR      r1,[r1,#0]  ; msg_head
00003c  6001              STR      r1,[r0,#0]  ; msg
;;;1351   	memcpy(&msg[sizeof(msg_head)], &payload, sizeof(payload)); //! payload
00003e  220f              MOVS     r2,#0xf
000040  490e              LDR      r1,|L11.124|
000042  1d00              ADDS     r0,r0,#4
000044  f7fffffe          BL       __aeabi_memcpy
;;;1352   
;;;1353   	msg[sizeof(msg_head)+sizeof(payload)]   = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)) >> 8);	//! crc MSB  19
000048  210f              MOVS     r1,#0xf
00004a  480d              LDR      r0,|L11.128|
00004c  1d00              ADDS     r0,r0,#4
00004e  f7fffffe          BL       crc16
000052  1200              ASRS     r0,r0,#8
000054  490a              LDR      r1,|L11.128|
000056  74c8              STRB     r0,[r1,#0x13]
;;;1354   	msg[sizeof(msg_head)+sizeof(payload)+1] = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)));		//! crc LSB  18++
000058  210f              MOVS     r1,#0xf
00005a  4809              LDR      r0,|L11.128|
00005c  1d00              ADDS     r0,r0,#4
00005e  f7fffffe          BL       crc16
000062  4907              LDR      r1,|L11.128|
000064  7508              STRB     r0,[r1,#0x14]
;;;1355   	msg[sizeof(msg_head)+sizeof(payload)+2] = END;  //20
000066  20ef              MOVS     r0,#0xef
000068  7548              STRB     r0,[r1,#0x15]
;;;1356   	
;;;1357       MSG_SEND_USART_BYTES(msg, sizeof(msg));
00006a  2116              MOVS     r1,#0x16
00006c  4804              LDR      r0,|L11.128|
00006e  f7fffffe          BL       UART1_Send_char
;;;1358   }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;1359   
                          ENDP

000076  0000              DCW      0x0000
                  |L11.120|
                          DCD      |symbol_number.85|
                  |L11.124|
                          DCD      |symbol_number.75|
                  |L11.128|
                          DCD      |symbol_number.74|

                          AREA ||i.msg_ask_for_data_send||, CODE, READONLY, ALIGN=2

                  msg_ask_for_data_send PROC
;;;1102   //主机轮询从机指令
;;;1103   void msg_ask_for_data_send(uint8_t node_id)
000000  b510              PUSH     {r4,lr}
;;;1104   {
000002  4604              MOV      r4,r0
;;;1105   	static uint8_t msg[MSG_ASK_FOR_DATA_PAYLOAD_LEN + MSG_PAYLOAD_OFFSET];//13 + 7 = 20
;;;1106   	static msg_head_t          msg_head;					//! msg head
;;;1107   	static msg_ask_for_data_t  payload;						//! msg payload
;;;1108   
;;;1109   	msg_head.stx     = STX;//1
000004  20fe              MOVS     r0,#0xfe
000006  4966              LDR      r1,|L12.416|
000008  7008              STRB     r0,[r1,#0]
;;;1110   	msg_head.len     = MSG_ASK_FOR_DATA_PAYLOAD_LEN;
00000a  200d              MOVS     r0,#0xd
00000c  7048              STRB     r0,[r1,#1]
;;;1111   	msg_head.seq     = MSG_RESERVE;
00000e  20ff              MOVS     r0,#0xff
000010  7088              STRB     r0,[r1,#2]
;;;1112   	msg_head.msg_id  = MSG_ID_ASK_FOR_DATA;//4
000012  2051              MOVS     r0,#0x51
000014  70c8              STRB     r0,[r1,#3]
;;;1113   	
;;;1114   	payload.master_addr  = MSG_MASTER_ADDR;//5
000016  2001              MOVS     r0,#1
000018  4962              LDR      r1,|L12.420|
00001a  7008              STRB     r0,[r1,#0]
;;;1115   	payload.slave_addr1  = MSG_RESERVE;
00001c  20ff              MOVS     r0,#0xff
00001e  7048              STRB     r0,[r1,#1]
;;;1116   	payload.slave_addr2  = node[node_id].slave_addr2;
000020  eb041004          ADD      r0,r4,r4,LSL #4
000024  4960              LDR      r1,|L12.424|
000026  eb010040          ADD      r0,r1,r0,LSL #1
00002a  7940              LDRB     r0,[r0,#5]
00002c  495d              LDR      r1,|L12.420|
00002e  7088              STRB     r0,[r1,#2]
;;;1117   	payload.location1 	 = MSG_RESERVE;
000030  20ff              MOVS     r0,#0xff
000032  70c8              STRB     r0,[r1,#3]
;;;1118   	payload.location2 	 = node[node_id].location2;//9
000034  eb041004          ADD      r0,r4,r4,LSL #4
000038  495b              LDR      r1,|L12.424|
00003a  eb010040          ADD      r0,r1,r0,LSL #1
00003e  79c0              LDRB     r0,[r0,#7]
000040  4958              LDR      r1,|L12.420|
000042  7108              STRB     r0,[r1,#4]
;;;1119   
;;;1120   //	location_control_t  east1_control_t;//东
;;;1121   //	location_control_t  south2_control_t;//南
;;;1122   //	location_control_t  west3_control_t;//西
;;;1123   //	location_control_t  north4_control_t;//北
;;;1124   	memcpy(&gITASMsg.payload.node[node_id-1], &node[node_id], sizeof(node_t));
000044  eb041204          ADD      r2,r4,r4,LSL #4
000048  4b57              LDR      r3,|L12.424|
00004a  eb030142          ADD      r1,r3,r2,LSL #1
00004e  1e62              SUBS     r2,r4,#1
000050  eb021302          ADD      r3,r2,r2,LSL #4
000054  4a55              LDR      r2,|L12.428|
000056  eb020043          ADD      r0,r2,r3,LSL #1
00005a  2222              MOVS     r2,#0x22
00005c  f7fffffe          BL       __aeabi_memcpy
;;;1125   //	switch(gITASMsg.payload.node[node_id-1].location2)
;;;1126   	switch(node[node_id].location2)
000060  eb041004          ADD      r0,r4,r4,LSL #4
000064  4950              LDR      r1,|L12.424|
000066  eb010040          ADD      r0,r1,r0,LSL #1
00006a  79c0              LDRB     r0,[r0,#7]
00006c  b130              CBZ      r0,|L12.124|
00006e  2801              CMP      r0,#1
000070  d018              BEQ      |L12.164|
000072  2802              CMP      r0,#2
000074  d02a              BEQ      |L12.204|
000076  2803              CMP      r0,#3
000078  d150              BNE      |L12.284|
00007a  e03b              B        |L12.244|
                  |L12.124|
;;;1127   	{ 
;;;1128   		case Location_East1:	 /*		东	*/
;;;1129   			{
;;;1130   			payload.spikelamp_switch1  = east1_control_t.spikelamp_switch1;//10
00007c  484c              LDR      r0,|L12.432|
00007e  7940              LDRB     r0,[r0,#5]  ; east1_control_t
000080  4948              LDR      r1,|L12.420|
000082  7148              STRB     r0,[r1,#5]
;;;1131   			payload.voice_switch2 	   = east1_control_t.voice_switch2;
000084  484a              LDR      r0,|L12.432|
000086  7980              LDRB     r0,[r0,#6]  ; east1_control_t
000088  7188              STRB     r0,[r1,#6]
;;;1132   			payload.led_switch3		   = east1_control_t.led_switch3;
00008a  4849              LDR      r0,|L12.432|
00008c  79c0              LDRB     r0,[r0,#7]  ; east1_control_t
00008e  71c8              STRB     r0,[r1,#7]
;;;1133   			payload.reserve1_switch    = east1_control_t.reserve1_switch;
000090  4847              LDR      r0,|L12.432|
000092  7a00              LDRB     r0,[r0,#8]  ; east1_control_t
000094  7208              STRB     r0,[r1,#8]
;;;1134   			payload.reserve2_switch    = east1_control_t.reserve2_switch;
000096  4846              LDR      r0,|L12.432|
000098  7a40              LDRB     r0,[r0,#9]  ; east1_control_t
00009a  7248              STRB     r0,[r1,#9]
;;;1135   			payload.reserve3_switch    = east1_control_t.reserve3_switch;//15
00009c  4844              LDR      r0,|L12.432|
00009e  7a80              LDRB     r0,[r0,#0xa]  ; east1_control_t
0000a0  7288              STRB     r0,[r1,#0xa]
;;;1136   			}
;;;1137   			break;
0000a2  e03c              B        |L12.286|
                  |L12.164|
;;;1138   		
;;;1139   		case Location_South2: 			    /*	南	*/
;;;1140   			{
;;;1141   			payload.spikelamp_switch1  = south2_control_t.spikelamp_switch1;
0000a4  4843              LDR      r0,|L12.436|
0000a6  7940              LDRB     r0,[r0,#5]  ; south2_control_t
0000a8  493e              LDR      r1,|L12.420|
0000aa  7148              STRB     r0,[r1,#5]
;;;1142   			payload.voice_switch2 	   = south2_control_t.voice_switch2;
0000ac  4841              LDR      r0,|L12.436|
0000ae  7980              LDRB     r0,[r0,#6]  ; south2_control_t
0000b0  7188              STRB     r0,[r1,#6]
;;;1143   			payload.led_switch3		   = south2_control_t.led_switch3;
0000b2  4840              LDR      r0,|L12.436|
0000b4  79c0              LDRB     r0,[r0,#7]  ; south2_control_t
0000b6  71c8              STRB     r0,[r1,#7]
;;;1144   			payload.reserve1_switch    = south2_control_t.reserve1_switch;
0000b8  483e              LDR      r0,|L12.436|
0000ba  7a00              LDRB     r0,[r0,#8]  ; south2_control_t
0000bc  7208              STRB     r0,[r1,#8]
;;;1145   			payload.reserve2_switch    = south2_control_t.reserve2_switch;
0000be  483d              LDR      r0,|L12.436|
0000c0  7a40              LDRB     r0,[r0,#9]  ; south2_control_t
0000c2  7248              STRB     r0,[r1,#9]
;;;1146   			payload.reserve3_switch    = south2_control_t.reserve3_switch;
0000c4  483b              LDR      r0,|L12.436|
0000c6  7a80              LDRB     r0,[r0,#0xa]  ; south2_control_t
0000c8  7288              STRB     r0,[r1,#0xa]
;;;1147   			}
;;;1148   			break;
0000ca  e028              B        |L12.286|
                  |L12.204|
;;;1149   		case Location_West3:			   /*	西	*/
;;;1150   			{
;;;1151   			payload.spikelamp_switch1  = west3_control_t.spikelamp_switch1;
0000cc  483a              LDR      r0,|L12.440|
0000ce  7940              LDRB     r0,[r0,#5]  ; west3_control_t
0000d0  4934              LDR      r1,|L12.420|
0000d2  7148              STRB     r0,[r1,#5]
;;;1152   			payload.voice_switch2 	   = west3_control_t.voice_switch2;
0000d4  4838              LDR      r0,|L12.440|
0000d6  7980              LDRB     r0,[r0,#6]  ; west3_control_t
0000d8  7188              STRB     r0,[r1,#6]
;;;1153   			payload.led_switch3		   = west3_control_t.led_switch3;
0000da  4837              LDR      r0,|L12.440|
0000dc  79c0              LDRB     r0,[r0,#7]  ; west3_control_t
0000de  71c8              STRB     r0,[r1,#7]
;;;1154   			payload.reserve1_switch    = west3_control_t.reserve1_switch;
0000e0  4835              LDR      r0,|L12.440|
0000e2  7a00              LDRB     r0,[r0,#8]  ; west3_control_t
0000e4  7208              STRB     r0,[r1,#8]
;;;1155   			payload.reserve2_switch    = west3_control_t.reserve2_switch;
0000e6  4834              LDR      r0,|L12.440|
0000e8  7a40              LDRB     r0,[r0,#9]  ; west3_control_t
0000ea  7248              STRB     r0,[r1,#9]
;;;1156   			payload.reserve3_switch    = west3_control_t.reserve3_switch;
0000ec  4832              LDR      r0,|L12.440|
0000ee  7a80              LDRB     r0,[r0,#0xa]  ; west3_control_t
0000f0  7288              STRB     r0,[r1,#0xa]
;;;1157   			}
;;;1158   			break;
0000f2  e014              B        |L12.286|
                  |L12.244|
;;;1159   		case Location_North4: 			    /*	北	*/
;;;1160   			{
;;;1161   			payload.spikelamp_switch1  = north4_control_t.spikelamp_switch1;
0000f4  4831              LDR      r0,|L12.444|
0000f6  7940              LDRB     r0,[r0,#5]  ; north4_control_t
0000f8  492a              LDR      r1,|L12.420|
0000fa  7148              STRB     r0,[r1,#5]
;;;1162   			payload.voice_switch2 	   = north4_control_t.voice_switch2;
0000fc  482f              LDR      r0,|L12.444|
0000fe  7980              LDRB     r0,[r0,#6]  ; north4_control_t
000100  7188              STRB     r0,[r1,#6]
;;;1163   			payload.led_switch3		   = north4_control_t.led_switch3;
000102  482e              LDR      r0,|L12.444|
000104  79c0              LDRB     r0,[r0,#7]  ; north4_control_t
000106  71c8              STRB     r0,[r1,#7]
;;;1164   			payload.reserve1_switch    = north4_control_t.reserve1_switch;
000108  482c              LDR      r0,|L12.444|
00010a  7a00              LDRB     r0,[r0,#8]  ; north4_control_t
00010c  7208              STRB     r0,[r1,#8]
;;;1165   			payload.reserve2_switch    = north4_control_t.reserve2_switch;
00010e  482b              LDR      r0,|L12.444|
000110  7a40              LDRB     r0,[r0,#9]  ; north4_control_t
000112  7248              STRB     r0,[r1,#9]
;;;1166   			payload.reserve3_switch    = north4_control_t.reserve3_switch;
000114  4829              LDR      r0,|L12.444|
000116  7a80              LDRB     r0,[r0,#0xa]  ; north4_control_t
000118  7288              STRB     r0,[r1,#0xa]
;;;1167   			}
;;;1168   			break;
00011a  e000              B        |L12.286|
                  |L12.284|
;;;1169   		default:
;;;1170   			break;
00011c  bf00              NOP      
                  |L12.286|
00011e  bf00              NOP                            ;1137
;;;1171   	}
;;;1172   
;;;1173   	payload.reserve1 = 0;//16
000120  2000              MOVS     r0,#0
000122  4920              LDR      r1,|L12.420|
000124  72c8              STRB     r0,[r1,#0xb]
;;;1174   	payload.reserve2 = 0;//17
000126  7308              STRB     r0,[r1,#0xc]
;;;1175   
;;;1176   	memcpy(&msg, &msg_head, sizeof(msg_head));
000128  4825              LDR      r0,|L12.448|
00012a  491d              LDR      r1,|L12.416|
00012c  6809              LDR      r1,[r1,#0]  ; msg_head
00012e  6001              STR      r1,[r0,#0]  ; msg
;;;1177   	memcpy(&msg[sizeof(msg_head)], &payload, sizeof(payload)); //! payload
000130  220d              MOVS     r2,#0xd
000132  491c              LDR      r1,|L12.420|
000134  1d00              ADDS     r0,r0,#4
000136  f7fffffe          BL       __aeabi_memcpy
;;;1178   
;;;1179   	msg[sizeof(msg_head)+sizeof(payload)]   = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)) >> 8);	//! crc MSB  19
00013a  210d              MOVS     r1,#0xd
00013c  4820              LDR      r0,|L12.448|
00013e  1d00              ADDS     r0,r0,#4
000140  f7fffffe          BL       crc16
000144  1200              ASRS     r0,r0,#8
000146  491e              LDR      r1,|L12.448|
000148  7448              STRB     r0,[r1,#0x11]
;;;1180   	msg[sizeof(msg_head)+sizeof(payload)+1] = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)));		//! crc LSB  18++
00014a  210d              MOVS     r1,#0xd
00014c  481c              LDR      r0,|L12.448|
00014e  1d00              ADDS     r0,r0,#4
000150  f7fffffe          BL       crc16
000154  491a              LDR      r1,|L12.448|
000156  7488              STRB     r0,[r1,#0x12]
;;;1181   	msg[sizeof(msg_head)+sizeof(payload)+2] = END;  //20
000158  20ef              MOVS     r0,#0xef
00015a  74c8              STRB     r0,[r1,#0x13]
;;;1182   	
;;;1183   	node[node_id].bad_cnt++; //! bigger means the slaver(node) bad and bad and bad....... !
00015c  eb041004          ADD      r0,r4,r4,LSL #4
000160  4911              LDR      r1,|L12.424|
000162  eb010040          ADD      r0,r1,r0,LSL #1
000166  7880              LDRB     r0,[r0,#2]
000168  1c40              ADDS     r0,r0,#1
00016a  eb041104          ADD      r1,r4,r4,LSL #4
00016e  4a0e              LDR      r2,|L12.424|
000170  eb020141          ADD      r1,r2,r1,LSL #1
000174  7088              STRB     r0,[r1,#2]
;;;1184   	gITASMsg.payload.node[node_id-1].bad_cnt++;
000176  1e60              SUBS     r0,r4,#1
000178  eb001100          ADD      r1,r0,r0,LSL #4
00017c  480b              LDR      r0,|L12.428|
00017e  eb000041          ADD      r0,r0,r1,LSL #1
000182  7880              LDRB     r0,[r0,#2]
000184  1c40              ADDS     r0,r0,#1
000186  b2c1              UXTB     r1,r0
000188  1e60              SUBS     r0,r4,#1
00018a  eb001200          ADD      r2,r0,r0,LSL #4
00018e  4807              LDR      r0,|L12.428|
000190  eb000042          ADD      r0,r0,r2,LSL #1
000194  7081              STRB     r1,[r0,#2]
;;;1185       MSG_SEND_USART_BYTES(msg, sizeof(msg));
000196  2114              MOVS     r1,#0x14
000198  4809              LDR      r0,|L12.448|
00019a  f7fffffe          BL       UART1_Send_char
;;;1186   }
00019e  bd10              POP      {r4,pc}
;;;1187   
                          ENDP

                  |L12.416|
                          DCD      msg_head
                  |L12.420|
                          DCD      payload
                  |L12.424|
                          DCD      node
                  |L12.428|
                          DCD      gITASMsg+0xf
                  |L12.432|
                          DCD      east1_control_t
                  |L12.436|
                          DCD      south2_control_t
                  |L12.440|
                          DCD      west3_control_t
                  |L12.444|
                          DCD      north4_control_t
                  |L12.448|
                          DCD      |symbol_number.66|

                          AREA ||i.msg_ask_for_id_send||, CODE, READONLY, ALIGN=2

                  msg_ask_for_id_send PROC
;;;1250    //主机处理 从机发送
;;;1251   void msg_ask_for_id_send(uint32_t mac_0, uint32_t mac_1, uint32_t mac_2, uint8_t master_addr, uint8_t slave_addr2, uint8_t location2) 
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1252   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;1253   	static uint8_t msg[MSG_ASK_FOR_ID_PAYLOAD_LEN + MSG_PAYLOAD_OFFSET];//7 + 15 = 22
;;;1254   	static msg_head_t	     msg_head;
;;;1255   	static msg_ask_for_id_send_t  payload;
;;;1256   
;;;1257   	msg_head.stx        = STX;//1
000010  20fe              MOVS     r0,#0xfe
000012  4922              LDR      r1,|L13.156|
000014  7008              STRB     r0,[r1,#0]
;;;1258   	msg_head.len        = MSG_ASK_FOR_ID_PAYLOAD_LEN;//2
000016  2014              MOVS     r0,#0x14
000018  7048              STRB     r0,[r1,#1]
;;;1259   	msg_head.seq	    = 0;//3
00001a  2000              MOVS     r0,#0
00001c  7088              STRB     r0,[r1,#2]
;;;1260   	msg_head.msg_id     = MSG_ID_ASK_FOR_ID;//4
00001e  2053              MOVS     r0,#0x53
000020  70c8              STRB     r0,[r1,#3]
;;;1261   	
;;;1262   	payload.node_id     = slave_addr2;	//5
000022  481f              LDR      r0,|L13.160|
000024  f8808000          STRB     r8,[r0,#0]
;;;1263   	payload.mac[0]	    = mac_0;//9
000028  f8c04001          STR      r4,[r0,#1]  ; payload
;;;1264   	payload.mac[1]      = mac_1;//13
00002c  f8c05005          STR      r5,[r0,#5]
;;;1265   	payload.mac[2]      = mac_2;//17
000030  f8c06009          STR      r6,[r0,#9]
;;;1266   	
;;;1267   	payload.master_addr	= master_addr;//18
000034  7347              STRB     r7,[r0,#0xd]
;;;1268   	payload.slave_addr1	= 0;//19	
000036  2000              MOVS     r0,#0
000038  4919              LDR      r1,|L13.160|
00003a  7388              STRB     r0,[r1,#0xe]
;;;1269   	payload.slave_addr2	= slave_addr2;//19
00003c  4608              MOV      r0,r1
00003e  f880800f          STRB     r8,[r0,#0xf]
;;;1270   	payload.location1	= 0;//20
000042  2000              MOVS     r0,#0
000044  7408              STRB     r0,[r1,#0x10]
;;;1271   	payload.location2	= location2;//20 
000046  4608              MOV      r0,r1
000048  f8809011          STRB     r9,[r0,#0x11]
;;;1272   
;;;1273       payload.reserve1    = 0;//21
00004c  2000              MOVS     r0,#0
00004e  7488              STRB     r0,[r1,#0x12]
;;;1274   	payload.reserve2    = 0;//22
000050  74c8              STRB     r0,[r1,#0x13]
;;;1275   	 
;;;1276   	memcpy(&msg, &msg_head.stx, sizeof(msg_head));
000052  4814              LDR      r0,|L13.164|
000054  4911              LDR      r1,|L13.156|
000056  6809              LDR      r1,[r1,#0]  ; msg_head
000058  6001              STR      r1,[r0,#0]  ; msg
;;;1277   	memcpy(&msg[sizeof(msg_head)], &payload.node_id, sizeof(payload));//! payload
00005a  2214              MOVS     r2,#0x14
00005c  4910              LDR      r1,|L13.160|
00005e  1d00              ADDS     r0,r0,#4
000060  f7fffffe          BL       __aeabi_memcpy
;;;1278   
;;;1279   	msg[sizeof(msg_head)+sizeof(payload)]   = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)) >> 8);	//! crc MSB  19
000064  2114              MOVS     r1,#0x14
000066  480f              LDR      r0,|L13.164|
000068  1d00              ADDS     r0,r0,#4
00006a  f7fffffe          BL       crc16
00006e  1200              ASRS     r0,r0,#8
000070  490c              LDR      r1,|L13.164|
000072  7608              STRB     r0,[r1,#0x18]
;;;1280   	msg[sizeof(msg_head)+sizeof(payload)+1] = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)));		//! crc LSB  18++
000074  2114              MOVS     r1,#0x14
000076  480b              LDR      r0,|L13.164|
000078  1d00              ADDS     r0,r0,#4
00007a  f7fffffe          BL       crc16
00007e  4909              LDR      r1,|L13.164|
000080  7648              STRB     r0,[r1,#0x19]
;;;1281   	msg[sizeof(msg_head)+sizeof(payload)+2] = END;  //20
000082  20ef              MOVS     r0,#0xef
000084  7688              STRB     r0,[r1,#0x1a]
;;;1282   
;;;1283   	current_node.bad_cnt = 0;
000086  2000              MOVS     r0,#0
000088  4907              LDR      r1,|L13.168|
00008a  7088              STRB     r0,[r1,#2]
;;;1284   	current_node.slave_addr2 = 0;
00008c  7148              STRB     r0,[r1,#5]
;;;1285   	
;;;1286       MSG_SEND_USART_BYTES(msg, sizeof(msg));
00008e  211b              MOVS     r1,#0x1b
000090  4804              LDR      r0,|L13.164|
000092  f7fffffe          BL       UART1_Send_char
;;;1287   }
000096  e8bd87f0          POP      {r4-r10,pc}
;;;1288   
                          ENDP

00009a  0000              DCW      0x0000
                  |L13.156|
                          DCD      |symbol_number.83|
                  |L13.160|
                          DCD      |symbol_number.71|
                  |L13.164|
                          DCD      |symbol_number.70|
                  |L13.168|
                          DCD      current_node

                          AREA ||i.msg_assign_id_send||, CODE, READONLY, ALIGN=2

                  msg_assign_id_send PROC
;;;1295   
;;;1296   void msg_assign_id_send(uint8_t node_id, uint32_t mac_0, uint32_t mac_1, uint32_t mac_2, uint8_t cfdt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1297   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1298   	static uint8_t msg[MSG_ASSIGN_ID_PAYLOAD_LEN + MSG_PAYLOAD_OFFSET];
;;;1299   	static msg_head_t	    msg_head;
;;;1300   	static msg_assign_id_t  payload;
;;;1301   	
;;;1302   	msg_head.stx       = STX;
000010  20fe              MOVS     r0,#0xfe
000012  491b              LDR      r1,|L14.128|
000014  7008              STRB     r0,[r1,#0]
;;;1303   	msg_head.len       = MSG_ASSIGN_ID_PAYLOAD_LEN;
000016  2010              MOVS     r0,#0x10
000018  7048              STRB     r0,[r1,#1]
;;;1304   	msg_head.seq	   = 0;
00001a  2000              MOVS     r0,#0
00001c  7088              STRB     r0,[r1,#2]
;;;1305   	msg_head.msg_id    = MSG_ID_ASSIGN_ID;
00001e  2054              MOVS     r0,#0x54
000020  70c8              STRB     r0,[r1,#3]
;;;1306   	
;;;1307   	payload.node_id    = node_id;
000022  4818              LDR      r0,|L14.132|
000024  7004              STRB     r4,[r0,#0]
;;;1308   	payload.mac[0]     = mac_0;
000026  f8c05001          STR      r5,[r0,#1]  ; payload
;;;1309   	payload.mac[1]     = mac_1;
00002a  f8c06005          STR      r6,[r0,#5]
;;;1310   	payload.mac[2]     = mac_2;
00002e  f8c07009          STR      r7,[r0,#9]
;;;1311   	payload.cfdt	   = cfdt;
000032  f880800d          STRB     r8,[r0,#0xd]
;;;1312       payload.reserve1   = 0;
000036  2000              MOVS     r0,#0
000038  4912              LDR      r1,|L14.132|
00003a  7388              STRB     r0,[r1,#0xe]
;;;1313   	payload.reserve2   = 0;
00003c  73c8              STRB     r0,[r1,#0xf]
;;;1314   	
;;;1315   	memcpy(&msg, &msg_head, sizeof(msg_head));
00003e  4812              LDR      r0,|L14.136|
000040  490f              LDR      r1,|L14.128|
000042  6809              LDR      r1,[r1,#0]  ; msg_head
000044  6001              STR      r1,[r0,#0]  ; msg
;;;1316   	memcpy(&msg[sizeof(msg_head)], &payload, sizeof(payload)); //! payload
000046  2210              MOVS     r2,#0x10
000048  490e              LDR      r1,|L14.132|
00004a  1d00              ADDS     r0,r0,#4
00004c  f7fffffe          BL       __aeabi_memcpy
;;;1317    
;;;1318   	msg[sizeof(msg_head)+sizeof(payload)]   = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)) >> 8);	//! crc MSB  19
000050  2110              MOVS     r1,#0x10
000052  480d              LDR      r0,|L14.136|
000054  1d00              ADDS     r0,r0,#4
000056  f7fffffe          BL       crc16
00005a  1200              ASRS     r0,r0,#8
00005c  490a              LDR      r1,|L14.136|
00005e  7508              STRB     r0,[r1,#0x14]
;;;1319   	msg[sizeof(msg_head)+sizeof(payload)+1] = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)));		//! crc LSB  18++
000060  2110              MOVS     r1,#0x10
000062  4809              LDR      r0,|L14.136|
000064  1d00              ADDS     r0,r0,#4
000066  f7fffffe          BL       crc16
00006a  4907              LDR      r1,|L14.136|
00006c  7548              STRB     r0,[r1,#0x15]
;;;1320   	msg[sizeof(msg_head)+sizeof(payload)+2] = END;  //20
00006e  20ef              MOVS     r0,#0xef
000070  7588              STRB     r0,[r1,#0x16]
;;;1321     
;;;1322       MSG_SEND_USART_BYTES(msg, sizeof(msg));
000072  2117              MOVS     r1,#0x17
000074  4804              LDR      r0,|L14.136|
000076  f7fffffe          BL       UART1_Send_char
;;;1323   }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;1324   
                          ENDP

00007e  0000              DCW      0x0000
                  |L14.128|
                          DCD      |symbol_number.84|
                  |L14.132|
                          DCD      |symbol_number.73|
                  |L14.136|
                          DCD      |symbol_number.72|

                          AREA ||i.msg_parse_char||, CODE, READONLY, ALIGN=2

                  msg_parse_char PROC
;;;1759   	bool parse_flag = false;
;;;1760   bool msg_parse_char(message_t *rxmsg, uint8_t c)
000000  b570              PUSH     {r4-r6,lr}
;;;1761   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1762   
;;;1763   	parse_flag = false;
000006  2000              MOVS     r0,#0
000008  4939              LDR      r1,|L15.240|
00000a  7008              STRB     r0,[r1,#0]
;;;1764   
;;;1765   	static message_t rxmsg_t;	
;;;1766   	static uint16_t bufferIndex;
;;;1767   	static msg_parse_state_t status;
;;;1768   	
;;;1769   	switch (status)
00000c  4839              LDR      r0,|L15.244|
00000e  7800              LDRB     r0,[r0,#0]  ; status
000010  280e              CMP      r0,#0xe
000012  d263              BCS      |L15.220|
000014  e8dff000          TBB      [pc,r0]
000018  07081016          DCB      0x07,0x08,0x10,0x16
00001c  1c226262          DCB      0x1c,0x22,0x62,0x62
000020  62626235          DCB      0x62,0x62,0x62,0x35
000024  3c45              DCB      0x3c,0x45
;;;1770   	{
;;;1771   	case MSG_PARSE_STATE_UNINIT:
;;;1772   		
;;;1773   	case MSG_PARSE_STATE_IDLE:
000026  bf00              NOP      
;;;1774   		if (c == STX) {
000028  2cfe              CMP      r4,#0xfe
00002a  d104              BNE      |L15.54|
;;;1775   			rxmsg_t.stx = c;
00002c  4832              LDR      r0,|L15.248|
00002e  7004              STRB     r4,[r0,#0]
;;;1776   			status = MSG_PARSE_STATE_GOT_STX; 
000030  2002              MOVS     r0,#2
000032  4930              LDR      r1,|L15.244|
000034  7008              STRB     r0,[r1,#0]
                  |L15.54|
;;;1777   		} 
;;;1778   		break;
000036  e057              B        |L15.232|
;;;1779   
;;;1780   	case MSG_PARSE_STATE_GOT_STX:
;;;1781   		rxmsg_t.len = c;
000038  482f              LDR      r0,|L15.248|
00003a  7044              STRB     r4,[r0,#1]
;;;1782   		status = MSG_PARSE_STATE_GOT_LENGTH; 
00003c  2003              MOVS     r0,#3
00003e  492d              LDR      r1,|L15.244|
000040  7008              STRB     r0,[r1,#0]
;;;1783   		break;
000042  e051              B        |L15.232|
;;;1784   
;;;1785   	case MSG_PARSE_STATE_GOT_LENGTH:
;;;1786   		rxmsg_t.seq = c;
000044  482c              LDR      r0,|L15.248|
000046  7084              STRB     r4,[r0,#2]
;;;1787   		status = MSG_PARSE_STATE_GOT_SEQ;
000048  2004              MOVS     r0,#4
00004a  492a              LDR      r1,|L15.244|
00004c  7008              STRB     r0,[r1,#0]
;;;1788   		break;
00004e  e04b              B        |L15.232|
;;;1789   	
;;;1790   	case MSG_PARSE_STATE_GOT_SEQ:
;;;1791   		rxmsg_t.msg_id = c;
000050  4829              LDR      r0,|L15.248|
000052  70c4              STRB     r4,[r0,#3]
;;;1792   		status = MSG_PARSE_STATE_GOT_MSGID;
000054  2005              MOVS     r0,#5
000056  4927              LDR      r1,|L15.244|
000058  7008              STRB     r0,[r1,#0]
;;;1793   		break;
00005a  e045              B        |L15.232|
;;;1794   
;;;1795   	case MSG_PARSE_STATE_GOT_MSGID:
;;;1796   
;;;1797   		rxmsg_t.payload[bufferIndex++] = c;
00005c  4827              LDR      r0,|L15.252|
00005e  8801              LDRH     r1,[r0,#0]  ; bufferIndex
000060  8800              LDRH     r0,[r0,#0]  ; bufferIndex
000062  1c40              ADDS     r0,r0,#1
000064  4a25              LDR      r2,|L15.252|
000066  8010              STRH     r0,[r2,#0]
000068  4823              LDR      r0,|L15.248|
00006a  1d00              ADDS     r0,r0,#4
00006c  5444              STRB     r4,[r0,r1]
;;;1798   		if (bufferIndex == rxmsg_t.len) {
00006e  1f00              SUBS     r0,r0,#4
000070  7840              LDRB     r0,[r0,#1]  ; rxmsg_t
000072  4611              MOV      r1,r2
000074  8809              LDRH     r1,[r1,#0]  ; bufferIndex
000076  4288              CMP      r0,r1
000078  d102              BNE      |L15.128|
;;;1799   			status = MSG_PARSE_STATE_GOT_PAYLOAD;
00007a  200b              MOVS     r0,#0xb
00007c  491d              LDR      r1,|L15.244|
00007e  7008              STRB     r0,[r1,#0]
                  |L15.128|
;;;1800   		}
;;;1801   		break;
000080  e032              B        |L15.232|
;;;1802   
;;;1803   	case MSG_PARSE_STATE_GOT_PAYLOAD:
;;;1804   			rxmsg_t.checksum =  (uint16_t)(c << 8);//高位	          
000082  0220              LSLS     r0,r4,#8
000084  491c              LDR      r1,|L15.248|
000086  8588              STRH     r0,[r1,#0x2c]
;;;1805   			status = MSG_PARSE_STATE_GOT_CRC1;
000088  200c              MOVS     r0,#0xc
00008a  491a              LDR      r1,|L15.244|
00008c  7008              STRB     r0,[r1,#0]
;;;1806   		break;
00008e  e02b              B        |L15.232|
;;;1807   
;;;1808   	case MSG_PARSE_STATE_GOT_CRC1:
;;;1809   			rxmsg_t.checksum |= (uint16_t)c;       //低位
000090  4819              LDR      r0,|L15.248|
000092  8d80              LDRH     r0,[r0,#0x2c]  ; rxmsg_t
000094  4320              ORRS     r0,r0,r4
000096  4918              LDR      r1,|L15.248|
000098  8588              STRH     r0,[r1,#0x2c]
;;;1810   			status = MSG_PARSE_STATE_GOT_CRC2;		
00009a  200d              MOVS     r0,#0xd
00009c  4915              LDR      r1,|L15.244|
00009e  7008              STRB     r0,[r1,#0]
;;;1811   		break;
0000a0  e022              B        |L15.232|
;;;1812   	
;;;1813   	case MSG_PARSE_STATE_GOT_CRC2:
;;;1814   //				printf("rxmsg_t.checksum %x\n",rxmsg_t.checksum);
;;;1815   //				printf("crc16(&rxmsg_t.payload[0], bufferIndex) : %x\n",crc16(&rxmsg_t.payload[0], bufferIndex));
;;;1816   			if ((crc16(&rxmsg_t.payload[0], bufferIndex) == rxmsg_t.checksum) && (c == END)) {
0000a2  4816              LDR      r0,|L15.252|
0000a4  8801              LDRH     r1,[r0,#0]  ; bufferIndex
0000a6  4814              LDR      r0,|L15.248|
0000a8  1d00              ADDS     r0,r0,#4
0000aa  f7fffffe          BL       crc16
0000ae  4912              LDR      r1,|L15.248|
0000b0  8d89              LDRH     r1,[r1,#0x2c]  ; rxmsg_t
0000b2  4288              CMP      r0,r1
0000b4  d10c              BNE      |L15.208|
0000b6  2cef              CMP      r4,#0xef
0000b8  d10a              BNE      |L15.208|
;;;1817   //				printf("rxmsg_t.checksum %x\n",rxmsg_t.checksum);
;;;1818   				memcpy(rxmsg, &rxmsg_t, sizeof(rxmsg_t));
0000ba  222e              MOVS     r2,#0x2e
0000bc  490e              LDR      r1,|L15.248|
0000be  4628              MOV      r0,r5
0000c0  f7fffffe          BL       __aeabi_memcpy
;;;1819   				Some_Data_On_Sky = 0;
0000c4  2000              MOVS     r0,#0
0000c6  490e              LDR      r1,|L15.256|
0000c8  7008              STRB     r0,[r1,#0]
;;;1820   				parse_flag = true;
0000ca  2001              MOVS     r0,#1
0000cc  4908              LDR      r1,|L15.240|
0000ce  7008              STRB     r0,[r1,#0]
                  |L15.208|
;;;1821   			}
;;;1822   			bufferIndex = 0;                                   
0000d0  2000              MOVS     r0,#0
0000d2  490a              LDR      r1,|L15.252|
0000d4  8008              STRH     r0,[r1,#0]
;;;1823   			status = MSG_PARSE_STATE_UNINIT;
0000d6  4907              LDR      r1,|L15.244|
0000d8  7008              STRB     r0,[r1,#0]
;;;1824           break;
0000da  e005              B        |L15.232|
                  |L15.220|
;;;1825   			
;;;1826   	default:
;;;1827   		bufferIndex = 0;
0000dc  2000              MOVS     r0,#0
0000de  4907              LDR      r1,|L15.252|
0000e0  8008              STRH     r0,[r1,#0]
;;;1828   		status = MSG_PARSE_STATE_UNINIT;
0000e2  4904              LDR      r1,|L15.244|
0000e4  7008              STRB     r0,[r1,#0]
0000e6  bf00              NOP                            ;1769
                  |L15.232|
0000e8  bf00              NOP                            ;1778
;;;1829   	}
;;;1830   //	printf("parse_flag %d\n",parse_flag);
;;;1831   
;;;1832   	return parse_flag;
0000ea  4801              LDR      r0,|L15.240|
0000ec  7800              LDRB     r0,[r0,#0]  ; parse_flag
;;;1833   			
;;;1834   }
0000ee  bd70              POP      {r4-r6,pc}
;;;1835   /*该节点作为从机  SLAVE*/
                          ENDP

                  |L15.240|
                          DCD      parse_flag
                  |L15.244|
                          DCD      status
                  |L15.248|
                          DCD      rxmsg_t
                  |L15.252|
                          DCD      bufferIndex
                  |L15.256|
                          DCD      Some_Data_On_Sky

                          AREA ||i.msg_start_mesh_send||, CODE, READONLY, ALIGN=2

                  msg_start_mesh_send PROC
;;;1365   
;;;1366   void msg_start_mesh_send(void)
000000  b510              PUSH     {r4,lr}
;;;1367   {
;;;1368   	static uint8_t msg[MSG_START_MESH_PAYLOAD_LEN + MSG_PAYLOAD_OFFSET];
;;;1369   	static msg_head_t	msg_head;
;;;1370   	static msg_start_mesh_t payload;
;;;1371   	
;;;1372   	msg_head.stx	= STX;//1
000002  20fe              MOVS     r0,#0xfe
000004  4913              LDR      r1,|L16.84|
000006  7008              STRB     r0,[r1,#0]
;;;1373   	msg_head.len	= MSG_START_MESH_PAYLOAD_LEN;//2
000008  2002              MOVS     r0,#2
00000a  7048              STRB     r0,[r1,#1]
;;;1374   	msg_head.seq	= 0x00;//3	uint8_t  seq;
00000c  2000              MOVS     r0,#0
00000e  7088              STRB     r0,[r1,#2]
;;;1375   	msg_head.msg_id	= MSG_ID_START_MESH;//4
000010  2056              MOVS     r0,#0x56
000012  70c8              STRB     r0,[r1,#3]
;;;1376   	
;;;1377       payload.reserve1   = 0;//5
000014  2000              MOVS     r0,#0
000016  4910              LDR      r1,|L16.88|
000018  7008              STRB     r0,[r1,#0]
;;;1378   	payload.reserve2   = 0;//6
00001a  7048              STRB     r0,[r1,#1]
;;;1379   	
;;;1380   	memcpy(&msg, &msg_head, sizeof(msg_head));//
00001c  480f              LDR      r0,|L16.92|
00001e  490d              LDR      r1,|L16.84|
000020  6809              LDR      r1,[r1,#0]  ; msg_head
000022  6001              STR      r1,[r0,#0]  ; msg
;;;1381   	memcpy(&msg[sizeof(msg_head)], &payload, sizeof(payload)); //! payload
000024  490c              LDR      r1,|L16.88|
000026  8809              LDRH     r1,[r1,#0]  ; payload
000028  8081              STRH     r1,[r0,#4]
;;;1382   
;;;1383   	msg[sizeof(msg_head)+sizeof(payload)]   = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)) >> 8);	//! crc MSB  19
00002a  2102              MOVS     r1,#2
00002c  1d00              ADDS     r0,r0,#4
00002e  f7fffffe          BL       crc16
000032  1200              ASRS     r0,r0,#8
000034  4909              LDR      r1,|L16.92|
000036  7188              STRB     r0,[r1,#6]
;;;1384   	msg[sizeof(msg_head)+sizeof(payload)+1] = (uint8_t)(crc16(&msg[sizeof(msg_head)], sizeof(payload)));		//! crc LSB  18++
000038  2102              MOVS     r1,#2
00003a  4808              LDR      r0,|L16.92|
00003c  1d00              ADDS     r0,r0,#4
00003e  f7fffffe          BL       crc16
000042  4906              LDR      r1,|L16.92|
000044  71c8              STRB     r0,[r1,#7]
;;;1385   	msg[sizeof(msg_head)+sizeof(payload)+2] = END;  //20
000046  20ef              MOVS     r0,#0xef
000048  7208              STRB     r0,[r1,#8]
;;;1386   	
;;;1387   	
;;;1388   	MSG_SEND_USART_BYTES(msg, sizeof(msg));
00004a  2109              MOVS     r1,#9
00004c  4803              LDR      r0,|L16.92|
00004e  f7fffffe          BL       UART1_Send_char
;;;1389   //	debugLogInfo("start mesh \n");
;;;1390   //	ledFlashSet(LED_MESH, 3, 2, 5);
;;;1391   }
000052  bd10              POP      {r4,pc}
;;;1392   void checkNodesStatePeriod(void) //检查从机状态阶段
                          ENDP

                  |L16.84|
                          DCD      |symbol_number.86|
                  |L16.88|
                          DCD      |symbol_number.87|
                  |L16.92|
                          DCD      |symbol_number.76|

                          AREA ||i.parseRadioData||, CODE, READONLY, ALIGN=2

                  parseRadioData PROC
;;;987    bool gCanAskForIdDurNormMode = false;	//
;;;988    void parseRadioData(void)
000000  b508              PUSH     {r3,lr}
;;;989    {
;;;990    	
;;;991    	uint8_t data;
;;;992    	static message_t msg;
;;;993    	
;;;994    	Rece_Frame_Data_flag = false;
000002  2000              MOVS     r0,#0
000004  490e              LDR      r1,|L17.64|
000006  7008              STRB     r0,[r1,#0]
;;;995    	
;;;996    	while (fifoGetBufDataCount()) {
000008  e015              B        |L17.54|
                  |L17.10|
;;;997               fifoPopBuf(&data, 1);
00000a  2101              MOVS     r1,#1
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       fifoPopBuf
;;;998    		
;;;999    		if (msg_parse_char(&msg, data)) {
000012  f89d1000          LDRB     r1,[sp,#0]
000016  480b              LDR      r0,|L17.68|
000018  f7fffffe          BL       msg_parse_char
00001c  b158              CBZ      r0,|L17.54|
;;;1000   			Rece_Frame_Data_flag = true;
00001e  2001              MOVS     r0,#1
000020  4907              LDR      r1,|L17.64|
000022  7008              STRB     r0,[r1,#0]
;;;1001   			PCout(13) =~ PCout(13);
000024  4808              LDR      r0,|L17.72|
000026  6800              LDR      r0,[r0,#0]
000028  43c0              MVNS     r0,r0
00002a  4908              LDR      r1,|L17.76|
00002c  f8c101b4          STR      r0,[r1,#0x1b4]
;;;1002   			handleMessage(&msg);
000030  4804              LDR      r0,|L17.68|
000032  f7fffffe          BL       handleMessage
                  |L17.54|
000036  f7fffffe          BL       fifoGetBufDataCount
00003a  2800              CMP      r0,#0                 ;996
00003c  d1e5              BNE      |L17.10|
;;;1003   		}
;;;1004   	}
;;;1005   }
00003e  bd08              POP      {r3,pc}
;;;1006   
                          ENDP

                  |L17.64|
                          DCD      Rece_Frame_Data_flag
                  |L17.68|
                          DCD      msg
                  |L17.72|
                          DCD      0x422201b4
                  |L17.76|
                          DCD      0x42220000

                          AREA ||i.startNewMesh||, CODE, READONLY, ALIGN=1

                  startNewMesh PROC
;;;1870   
;;;1871   void startNewMesh(void)
000000  b510              PUSH     {r4,lr}
;;;1872   {
;;;1873   	msg_start_mesh_send();	//! what should do if the slavers miss this msg?
000002  f7fffffe          BL       msg_start_mesh_send
;;;1874   //	PCout(13) = 0;
;;;1875   //	PCout(14) = 1;
;;;1876   	vTaskDelay(1000);		//! i forget why delay this N ms  wait until mesh  finished
000006  f44f707a          MOV      r0,#0x3e8
00000a  f7fffffe          BL       vTaskDelay
;;;1877   }
00000e  bd10              POP      {r4,pc}
;;;1878   
                          ENDP


                          AREA ||i.taskMesh||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  taskMesh PROC
;;;1457   //从机网络运行任务
;;;1458   itas_mode_t taskMesh(void)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1459   {
;;;1460   	static uint8_t askForIdCnt = 0;
;;;1461   	itas_mode_t mode = MESH_MODE_MESH;
000004  2703              MOVS     r7,#3
;;;1462   	u16 m=60,n=400,x=1,y=20;
000006  253c              MOVS     r5,#0x3c
000008  f44f78c8          MOV      r8,#0x190
00000c  f04f0901          MOV      r9,#1
000010  f04f0a14          MOV      r10,#0x14
;;;1463   	u16 p=50,q=160;
000014  2432              MOVS     r4,#0x32
000016  26a0              MOVS     r6,#0xa0
;;;1464   	if (current_node.slave_addr2 == 0) {
000018  485a              LDR      r0,|L19.388|
00001a  7940              LDRB     r0,[r0,#5]  ; current_node
00001c  2800              CMP      r0,#0
00001e  d17d              BNE      |L19.284|
;;;1465   		
;;;1466   		gMeshFinished = 0;
000020  4959              LDR      r1,|L19.392|
000022  7008              STRB     r0,[r1,#0]
;;;1467   		 
;;;1468   		if (gNetworkRunning) {//! the network is running normally  系统内某些主从网络关系已存在
000024  4859              LDR      r0,|L19.396|
000026  7800              LDRB     r0,[r0,#0]  ; gNetworkRunning
000028  2800              CMP      r0,#0
00002a  d03c              BEQ      |L19.166|
;;;1469   //		if (gCanAskForIdDurNormMode) {	//! check if it is the free time that can send ask for id msg
;;;1470   			if(parse_flag){ //已接收完整帧数据 
00002c  4858              LDR      r0,|L19.400|
00002e  7800              LDRB     r0,[r0,#0]  ; parse_flag
000030  2800              CMP      r0,#0
000032  d071              BEQ      |L19.280|
;;;1471   							srand(Get_Adc(ADC_Channel_10));
000034  200a              MOVS     r0,#0xa
000036  f7fffffe          BL       Get_Adc
00003a  4683              MOV      r11,r0
00003c  f7fffffe          BL       srand
;;;1472   							RandvVlue = rand()%(q-p+1)+p;
000040  f7fffffe          BL       rand
000044  1b31              SUBS     r1,r6,r4
000046  1c49              ADDS     r1,r1,#1
000048  fb90f2f1          SDIV     r2,r0,r1
00004c  fb010012          MLS      r0,r1,r2,r0
000050  4420              ADD      r0,r0,r4
000052  4950              LDR      r1,|L19.404|
000054  8008              STRH     r0,[r1,#0]
;;;1473   							vTaskDelay(RandvVlue);
000056  4608              MOV      r0,r1
000058  8800              LDRH     r0,[r0,#0]  ; RandvVlue
00005a  f7fffffe          BL       vTaskDelay
;;;1474   //				if((Rece_Frame_Data_flag)&&(!Some_Data_On_Sky))//帧数据完整，且空中没有字节数据，
;;;1475   				if(parse_flag)
00005e  484c              LDR      r0,|L19.400|
000060  7800              LDRB     r0,[r0,#0]  ; parse_flag
000062  2800              CMP      r0,#0
000064  d058              BEQ      |L19.280|
;;;1476   				{
;;;1477   					gCanAskForIdDurNormMode = false; 
000066  2000              MOVS     r0,#0
000068  494b              LDR      r1,|L19.408|
00006a  7008              STRB     r0,[r1,#0]
;;;1478   					askForIdCnt++;
00006c  484b              LDR      r0,|L19.412|
00006e  7800              LDRB     r0,[r0,#0]  ; askForIdCnt
000070  1c40              ADDS     r0,r0,#1
000072  494a              LDR      r1,|L19.412|
000074  7008              STRB     r0,[r1,#0]
;;;1479   					msg_ask_for_id_send(current_node.mac[0], current_node.mac[1], current_node.mac[2], current_node.master_addr, 
000076  4843              LDR      r0,|L19.388|
000078  79c0              LDRB     r0,[r0,#7]  ; current_node
00007a  4942              LDR      r1,|L19.388|
00007c  7949              LDRB     r1,[r1,#5]  ; current_node
00007e  f8dfc104          LDR      r12,|L19.388|
000082  e9cd1000          STRD     r1,r0,[sp,#0]
000086  f89c3003          LDRB     r3,[r12,#3]  ; current_node
00008a  f8dc201e          LDR      r2,[r12,#0x1e]
00008e  f8dc101a          LDR      r1,[r12,#0x1a]
000092  f8dc0016          LDR      r0,[r12,#0x16]  ; current_node
000096  f7fffffe          BL       msg_ask_for_id_send
;;;1480   										current_node.slave_addr2, current_node.location2);
;;;1481   					printf("normal mode: ask for id times: %d \n", askForIdCnt);
00009a  4840              LDR      r0,|L19.412|
00009c  7801              LDRB     r1,[r0,#0]  ; askForIdCnt
00009e  a040              ADR      r0,|L19.416|
0000a0  f7fffffe          BL       __2printf
0000a4  e038              B        |L19.280|
                  |L19.166|
;;;1482   				}
;;;1483   			} else {
;;;1484   				
;;;1485   				//! to do 
;;;1486   			}
;;;1487   		} else {//! the network is running mesh系统伊始，组网状态
;;;1488   //			if (gCanAskForIdTriger) {
;;;1489   			if(!Some_Data_On_Sky){//空中没有字节数据，
0000a6  4847              LDR      r0,|L19.452|
0000a8  7800              LDRB     r0,[r0,#0]  ; Some_Data_On_Sky
0000aa  2800              CMP      r0,#0
0000ac  d134              BNE      |L19.280|
;;;1490   							srand(Get_Adc(ADC_Channel_10));
0000ae  200a              MOVS     r0,#0xa
0000b0  f7fffffe          BL       Get_Adc
0000b4  4683              MOV      r11,r0
0000b6  f7fffffe          BL       srand
;;;1491   							RandvVlue = rand()%(n-m+1)+m;
0000ba  f7fffffe          BL       rand
0000be  eba80105          SUB      r1,r8,r5
0000c2  1c49              ADDS     r1,r1,#1
0000c4  fb90f2f1          SDIV     r2,r0,r1
0000c8  fb010012          MLS      r0,r1,r2,r0
0000cc  4428              ADD      r0,r0,r5
0000ce  4931              LDR      r1,|L19.404|
0000d0  8008              STRH     r0,[r1,#0]
;;;1492   							vTaskDelay(RandvVlue);
0000d2  4608              MOV      r0,r1
0000d4  8800              LDRH     r0,[r0,#0]  ; RandvVlue
0000d6  f7fffffe          BL       vTaskDelay
;;;1493   				if(!Some_Data_On_Sky)//空中没有字节数据，
0000da  483a              LDR      r0,|L19.452|
0000dc  7800              LDRB     r0,[r0,#0]  ; Some_Data_On_Sky
0000de  b9d8              CBNZ     r0,|L19.280|
;;;1494   				{
;;;1495   					msg_ask_for_id_send(current_node.mac[0], current_node.mac[1], current_node.mac[2], current_node.master_addr, current_node.slave_addr2, current_node.location2);						
0000e0  4828              LDR      r0,|L19.388|
0000e2  79c0              LDRB     r0,[r0,#7]  ; current_node
0000e4  4927              LDR      r1,|L19.388|
0000e6  7949              LDRB     r1,[r1,#5]  ; current_node
0000e8  f8dfc098          LDR      r12,|L19.388|
0000ec  e9cd1000          STRD     r1,r0,[sp,#0]
0000f0  f89c3003          LDRB     r3,[r12,#3]  ; current_node
0000f4  f8dc201e          LDR      r2,[r12,#0x1e]
0000f8  f8dc101a          LDR      r1,[r12,#0x1a]
0000fc  f8dc0016          LDR      r0,[r12,#0x16]  ; current_node
000100  f7fffffe          BL       msg_ask_for_id_send
;;;1496   					askForIdCnt++; 
000104  4825              LDR      r0,|L19.412|
000106  7800              LDRB     r0,[r0,#0]  ; askForIdCnt
000108  1c40              ADDS     r0,r0,#1
00010a  4924              LDR      r1,|L19.412|
00010c  7008              STRB     r0,[r1,#0]
;;;1497   					printf("mesh mode: ask for id times: %d \n", askForIdCnt);
00010e  4608              MOV      r0,r1
000110  7801              LDRB     r1,[r0,#0]  ; askForIdCnt
000112  a02d              ADR      r0,|L19.456|
000114  f7fffffe          BL       __2printf
                  |L19.280|
;;;1498   				}
;;;1499   			} else {
;;;1500   				//! to do
;;;1501   			}
;;;1502   		}			
;;;1503   			
;;;1504   		if (askForIdCnt == ASK_FOR_ID_RETRY_MAX) {//! ask for id more than n times, delay a random time then restart timer
000118  4820              LDR      r0,|L19.412|
00011a  e000              B        |L19.286|
                  |L19.284|
00011c  e01e              B        |L19.348|
                  |L19.286|
00011e  7800              LDRB     r0,[r0,#0]  ; askForIdCnt
000120  2814              CMP      r0,#0x14
000122  d114              BNE      |L19.334|
;;;1505   //			vTaskDelay((current_node.mac[0] + current_node.mac[1] + current_node.mac[2])&0x00000007*20);
;;;1506   //			timer2Init(200);
;;;1507   			srand(Get_Adc(ADC_Channel_10));
000124  200a              MOVS     r0,#0xa
000126  f7fffffe          BL       Get_Adc
00012a  4683              MOV      r11,r0
00012c  f7fffffe          BL       srand
;;;1508   			RandvVlue = rand()%(q-p+1)+p;
000130  f7fffffe          BL       rand
000134  1b31              SUBS     r1,r6,r4
000136  1c49              ADDS     r1,r1,#1
000138  fb90f2f1          SDIV     r2,r0,r1
00013c  fb010012          MLS      r0,r1,r2,r0
000140  4420              ADD      r0,r0,r4
000142  4914              LDR      r1,|L19.404|
000144  8008              STRH     r0,[r1,#0]
;;;1509   			vTaskDelay(RandvVlue);
000146  4608              MOV      r0,r1
000148  8800              LDRH     r0,[r0,#0]  ; RandvVlue
00014a  f7fffffe          BL       vTaskDelay
                  |L19.334|
;;;1510   		}
;;;1511   		
;;;1512   		if (askForIdCnt >= ASK_FOR_ID_RETRY_REBOOT) {//发送一次申请id ++
00014e  4813              LDR      r0,|L19.412|
000150  7800              LDRB     r0,[r0,#0]  ; askForIdCnt
000152  2832              CMP      r0,#0x32
000154  db12              BLT      |L19.380|
;;;1513   			systemReboot(); 
000156  f7fffffe          BL       systemReboot
00015a  e00f              B        |L19.380|
                  |L19.348|
;;;1514   		}
;;;1515   		
;;;1516   	} else if (current_node.slave_addr2 == 255) {//! rejected my mesh request!!!
00015c  4809              LDR      r0,|L19.388|
00015e  7940              LDRB     r0,[r0,#5]  ; current_node
000160  28ff              CMP      r0,#0xff
000162  d107              BNE      |L19.372|
;;;1517   		askForIdCnt = 0;
000164  2000              MOVS     r0,#0
000166  490d              LDR      r1,|L19.412|
000168  7008              STRB     r0,[r1,#0]
;;;1518   //		timer2Init(getAskForIdPeriod());	//! just case of had modified the period
;;;1519   		mode = MESH_MODE_NONE;
00016a  2706              MOVS     r7,#6
;;;1520   		printf("i am ok but rejected ! \n");
00016c  a01f              ADR      r0,|L19.492|
00016e  f7fffffe          BL       __2printf
000172  e003              B        |L19.380|
                  |L19.372|
;;;1521   		
;;;1522   	} else { //! get the id succeed !
;;;1523   		askForIdCnt = 0;
000174  2000              MOVS     r0,#0
000176  4909              LDR      r1,|L19.412|
000178  7008              STRB     r0,[r1,#0]
;;;1524   //		current_node.bad_cnt = 0;???
;;;1525   //		timer2Init(getAskForIdPeriod()); //! just case of had modified the period
;;;1526   		mode = MESH_MODE_NORMAL;
00017a  2704              MOVS     r7,#4
                  |L19.380|
;;;1527   		
;;;1528   //		printf("i get my id = %d \n", current_node.slave_addr2);			
;;;1529   	}
;;;1530   	return mode;
00017c  4638              MOV      r0,r7
;;;1531   }
00017e  e8bd9ffc          POP      {r2-r12,pc}
;;;1532   //正常网络运行任务 
                          ENDP

000182  0000              DCW      0x0000
                  |L19.388|
                          DCD      current_node
                  |L19.392|
                          DCD      gMeshFinished
                  |L19.396|
                          DCD      gNetworkRunning
                  |L19.400|
                          DCD      parse_flag
                  |L19.404|
                          DCD      RandvVlue
                  |L19.408|
                          DCD      gCanAskForIdDurNormMode
                  |L19.412|
                          DCD      askForIdCnt
                  |L19.416|
0001a0  6e6f726d          DCB      "normal mode: ask for id times: %d \n",0
0001a4  616c206d
0001a8  6f64653a
0001ac  2061736b
0001b0  20666f72
0001b4  20696420
0001b8  74696d65
0001bc  733a2025
0001c0  64200a00
                  |L19.452|
                          DCD      Some_Data_On_Sky
                  |L19.456|
0001c8  6d657368          DCB      "mesh mode: ask for id times: %d \n",0
0001cc  206d6f64
0001d0  653a2061
0001d4  736b2066
0001d8  6f722069
0001dc  64207469
0001e0  6d65733a
0001e4  20256420
0001e8  0a00    
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L19.492|
0001ec  6920616d          DCB      "i am ok but rejected ! \n",0
0001f0  206f6b20
0001f4  62757420
0001f8  72656a65
0001fc  63746564
000200  2021200a
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0

                          AREA ||i.taskNormalMission||, CODE, READONLY, ALIGN=2

                  taskNormalMission PROC
;;;1532   //正常网络运行任务 
;;;1533   itas_mode_t taskNormalMission(void)
000000  2004              MOVS     r0,#4
;;;1534   {
;;;1535   	itas_mode_t mode = MESH_MODE_NORMAL;
;;;1536   	
;;;1537   	//! to do normal mission
;;;1538   	if (current_node.slave_addr2 == 0){	//! master start a new mesh, should apply for a new id 
000002  4906              LDR      r1,|L20.28|
000004  7949              LDRB     r1,[r1,#5]  ; current_node
000006  b909              CBNZ     r1,|L20.12|
;;;1539   		mode = MESH_MODE_MESH; 
000008  2003              MOVS     r0,#3
00000a  e006              B        |L20.26|
                  |L20.12|
;;;1540   
;;;1541   	}
;;;1542   	else if (current_node.bad_cnt > CURRENT_BAD_CNT_MAX){ //! communication is bad ! run selfcheck !
00000c  4903              LDR      r1,|L20.28|
00000e  7889              LDRB     r1,[r1,#2]  ; current_node
000010  2914              CMP      r1,#0x14
000012  dd02              BLE      |L20.26|
;;;1543   		current_node.slave_addr2 = 0;
000014  2100              MOVS     r1,#0
000016  4a01              LDR      r2,|L20.28|
000018  7151              STRB     r1,[r2,#5]
                  |L20.26|
;;;1544   		//mode = ITS_MODE_SELF_CHECK;
;;;1545   //		printf("i am running selfcheck! \n");
;;;1546   	}
;;;1547   	return mode;
;;;1548   }
00001a  4770              BX       lr
;;;1549   /********************************************************************************************************************************************************/
                          ENDP

                  |L20.28|
                          DCD      current_node

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  Buffer
                          %        30
                  east1_control_t
                          %        11
                  south2_control_t
                          %        11
                  west3_control_t
                          %        11
                  north4_control_t
                          %        11
                  msg
                          %        46
                  |symbol_number.66|
                          %        20
                  payload
                          %        13
                  |symbol_number.68|
                          %        19
                  |symbol_number.69|
                          %        12
                  |symbol_number.70|
                          %        27
                  |symbol_number.71|
                          %        20
                  |symbol_number.72|
                          %        23
                  |symbol_number.73|
                          %        16
                  |symbol_number.74|
                          %        22
                  |symbol_number.75|
                          %        15
                  |symbol_number.76|
                          %        9
                  rxmsg_t
                          %        46

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  crc16Tab
000000  00001021          DCW      0x0000,0x1021
000004  20423063          DCW      0x2042,0x3063
000008  408450a5          DCW      0x4084,0x50a5
00000c  60c670e7          DCW      0x60c6,0x70e7
000010  81089129          DCW      0x8108,0x9129
000014  a14ab16b          DCW      0xa14a,0xb16b
000018  c18cd1ad          DCW      0xc18c,0xd1ad
00001c  e1cef1ef          DCW      0xe1ce,0xf1ef
000020  12310210          DCW      0x1231,0x0210
000024  32732252          DCW      0x3273,0x2252
000028  52b54294          DCW      0x52b5,0x4294
00002c  72f762d6          DCW      0x72f7,0x62d6
000030  93398318          DCW      0x9339,0x8318
000034  b37ba35a          DCW      0xb37b,0xa35a
000038  d3bdc39c          DCW      0xd3bd,0xc39c
00003c  f3ffe3de          DCW      0xf3ff,0xe3de
000040  24623443          DCW      0x2462,0x3443
000044  04201401          DCW      0x0420,0x1401
000048  64e674c7          DCW      0x64e6,0x74c7
00004c  44a45485          DCW      0x44a4,0x5485
000050  a56ab54b          DCW      0xa56a,0xb54b
000054  85289509          DCW      0x8528,0x9509
000058  e5eef5cf          DCW      0xe5ee,0xf5cf
00005c  c5acd58d          DCW      0xc5ac,0xd58d
000060  36532672          DCW      0x3653,0x2672
000064  16110630          DCW      0x1611,0x0630
000068  76d766f6          DCW      0x76d7,0x66f6
00006c  569546b4          DCW      0x5695,0x46b4
000070  b75ba77a          DCW      0xb75b,0xa77a
000074  97198738          DCW      0x9719,0x8738
000078  f7dfe7fe          DCW      0xf7df,0xe7fe
00007c  d79dc7bc          DCW      0xd79d,0xc7bc
000080  48c458e5          DCW      0x48c4,0x58e5
000084  688678a7          DCW      0x6886,0x78a7
000088  08401861          DCW      0x0840,0x1861
00008c  28023823          DCW      0x2802,0x3823
000090  c9ccd9ed          DCW      0xc9cc,0xd9ed
000094  e98ef9af          DCW      0xe98e,0xf9af
000098  89489969          DCW      0x8948,0x9969
00009c  a90ab92b          DCW      0xa90a,0xb92b
0000a0  5af54ad4          DCW      0x5af5,0x4ad4
0000a4  7ab76a96          DCW      0x7ab7,0x6a96
0000a8  1a710a50          DCW      0x1a71,0x0a50
0000ac  3a332a12          DCW      0x3a33,0x2a12
0000b0  dbfdcbdc          DCW      0xdbfd,0xcbdc
0000b4  fbbfeb9e          DCW      0xfbbf,0xeb9e
0000b8  9b798b58          DCW      0x9b79,0x8b58
0000bc  bb3bab1a          DCW      0xbb3b,0xab1a
0000c0  6ca67c87          DCW      0x6ca6,0x7c87
0000c4  4ce45cc5          DCW      0x4ce4,0x5cc5
0000c8  2c223c03          DCW      0x2c22,0x3c03
0000cc  0c601c41          DCW      0x0c60,0x1c41
0000d0  edaefd8f          DCW      0xedae,0xfd8f
0000d4  cdecddcd          DCW      0xcdec,0xddcd
0000d8  ad2abd0b          DCW      0xad2a,0xbd0b
0000dc  8d689d49          DCW      0x8d68,0x9d49
0000e0  7e976eb6          DCW      0x7e97,0x6eb6
0000e4  5ed54ef4          DCW      0x5ed5,0x4ef4
0000e8  3e132e32          DCW      0x3e13,0x2e32
0000ec  1e510e70          DCW      0x1e51,0x0e70
0000f0  ff9fefbe          DCW      0xff9f,0xefbe
0000f4  dfddcffc          DCW      0xdfdd,0xcffc
0000f8  bf1baf3a          DCW      0xbf1b,0xaf3a
0000fc  9f598f78          DCW      0x9f59,0x8f78
000100  918881a9          DCW      0x9188,0x81a9
000104  b1caa1eb          DCW      0xb1ca,0xa1eb
000108  d10cc12d          DCW      0xd10c,0xc12d
00010c  f14ee16f          DCW      0xf14e,0xe16f
000110  108000a1          DCW      0x1080,0x00a1
000114  30c220e3          DCW      0x30c2,0x20e3
000118  50044025          DCW      0x5004,0x4025
00011c  70466067          DCW      0x7046,0x6067
000120  83b99398          DCW      0x83b9,0x9398
000124  a3fbb3da          DCW      0xa3fb,0xb3da
000128  c33dd31c          DCW      0xc33d,0xd31c
00012c  e37ff35e          DCW      0xe37f,0xf35e
000130  02b11290          DCW      0x02b1,0x1290
000134  22f332d2          DCW      0x22f3,0x32d2
000138  42355214          DCW      0x4235,0x5214
00013c  62777256          DCW      0x6277,0x7256
000140  b5eaa5cb          DCW      0xb5ea,0xa5cb
000144  95a88589          DCW      0x95a8,0x8589
000148  f56ee54f          DCW      0xf56e,0xe54f
00014c  d52cc50d          DCW      0xd52c,0xc50d
000150  34e224c3          DCW      0x34e2,0x24c3
000154  14a00481          DCW      0x14a0,0x0481
000158  74666447          DCW      0x7466,0x6447
00015c  54244405          DCW      0x5424,0x4405
000160  a7dbb7fa          DCW      0xa7db,0xb7fa
000164  879997b8          DCW      0x8799,0x97b8
000168  e75ff77e          DCW      0xe75f,0xf77e
00016c  c71dd73c          DCW      0xc71d,0xd73c
000170  26d336f2          DCW      0x26d3,0x36f2
000174  069116b0          DCW      0x0691,0x16b0
000178  66577676          DCW      0x6657,0x7676
00017c  46155634          DCW      0x4615,0x5634
000180  d94cc96d          DCW      0xd94c,0xc96d
000184  f90ee92f          DCW      0xf90e,0xe92f
000188  99c889e9          DCW      0x99c8,0x89e9
00018c  b98aa9ab          DCW      0xb98a,0xa9ab
000190  58444865          DCW      0x5844,0x4865
000194  78066827          DCW      0x7806,0x6827
000198  18c008e1          DCW      0x18c0,0x08e1
00019c  388228a3          DCW      0x3882,0x28a3
0001a0  cb7ddb5c          DCW      0xcb7d,0xdb5c
0001a4  eb3ffb1e          DCW      0xeb3f,0xfb1e
0001a8  8bf99bd8          DCW      0x8bf9,0x9bd8
0001ac  abbbbb9a          DCW      0xabbb,0xbb9a
0001b0  4a755a54          DCW      0x4a75,0x5a54
0001b4  6a377a16          DCW      0x6a37,0x7a16
0001b8  0af11ad0          DCW      0x0af1,0x1ad0
0001bc  2ab33a92          DCW      0x2ab3,0x3a92
0001c0  fd2eed0f          DCW      0xfd2e,0xed0f
0001c4  dd6ccd4d          DCW      0xdd6c,0xcd4d
0001c8  bdaaad8b          DCW      0xbdaa,0xad8b
0001cc  9de88dc9          DCW      0x9de8,0x8dc9
0001d0  7c266c07          DCW      0x7c26,0x6c07
0001d4  5c644c45          DCW      0x5c64,0x4c45
0001d8  3ca22c83          DCW      0x3ca2,0x2c83
0001dc  1ce00cc1          DCW      0x1ce0,0x0cc1
0001e0  ef1fff3e          DCW      0xef1f,0xff3e
0001e4  cf5ddf7c          DCW      0xcf5d,0xdf7c
0001e8  af9bbfba          DCW      0xaf9b,0xbfba
0001ec  8fd99ff8          DCW      0x8fd9,0x9ff8
0001f0  6e177e36          DCW      0x6e17,0x7e36
0001f4  4e555e74          DCW      0x4e55,0x5e74
0001f8  2e933eb2          DCW      0x2e93,0x3eb2
0001fc  0ed11ef0          DCW      0x0ed1,0x1ef0
                  MY_TEST_Msg
000200  3300              DCB      0x33,0x00
                  Function_TEST_Msg
000202  fe00              DCB      0xfe,0x00
000204  0c0101ff          DCB      0x0c,0x01,0x01,0xff
000208  ff000104          DCB      0xff,0x00,0x01,0x04
00020c  00fc0101          DCB      0x00,0xfc,0x01,0x01
000210  010101ff          DCB      0x01,0x01,0x01,0xff
000214  01ffffff          DCB      0x01,0xff,0xff,0xff
000218  ffffaaff          DCB      0xff,0xff,0xaa,0xff
00021c  ef                DCB      0xef
                  Function_TEST_Msg1
00021d  010000            DCB      0x01,0x00,0x00
000220  00000000          DCB      0x00,0x00,0x00,0x00
000224  00000000          DCB      0x00,0x00,0x00,0x00
000228  00000000          DCB      0x00,0x00,0x00,0x00
00022c  00000000          DCB      0x00,0x00,0x00,0x00
000230  00000000          DCB      0x00,0x00,0x00,0x00
000234  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  BufferSize
000000  001e              DCW      0x001e
                  EnableMaster
000002  01                DCB      0x01
                  Device_Location
000003  00                DCB      0x00
                  LoRa_Frequency_Change
                          DCD      0x19ed92c0
                  Some_Data_On_Sky
000008  00                DCB      0x00
                  Rece_Frame_Data_flag
000009  00                DCB      0x00
                  gNoneAskForCnt
00000a  00                DCB      0x00
                  gNodesOnLine
00000b  00                DCB      0x00
                  RandvVlue
00000c  0000              DCW      0x0000
                  Block_Code
00000e  0000              DCW      0x0000
                  Pay_Load
000010  00                DCB      0x00
                  RF_size
000011  00                DCB      0x00
                  RF_TX_Buff
000012  0000              DCB      0x00,0x00
                  Radio
                          DCD      0x00000000
                  gNetworkRunning
000018  00                DCB      0x00
                  gCanAskForIdTriger
000019  00                DCB      0x00
                  gCanAskForIdDurNormMode
00001a  0000              DCB      0x00,0x00
                  gRadioNoDataCnt
00001c  0000              DCW      0x0000
                  parse_flag
00001e  00                DCB      0x00
                  msg_head
00001f  00                DCB      0x00
000020  000000            DCB      0x00,0x00,0x00
                  |symbol_number.82|
000023  00                DCB      0x00
000024  000000            DCB      0x00,0x00,0x00
                  |symbol_number.83|
000027  00                DCB      0x00
000028  000000            DCB      0x00,0x00,0x00
                  |symbol_number.84|
00002b  00                DCB      0x00
00002c  000000            DCB      0x00,0x00,0x00
                  |symbol_number.85|
00002f  00                DCB      0x00
000030  000000            DCB      0x00,0x00,0x00
                  |symbol_number.86|
000033  00                DCB      0x00
000034  000000            DCB      0x00,0x00,0x00
                  |symbol_number.87|
000037  00                DCB      0x00
000038  00000000          DCB      0x00,0x00,0x00,0x00
                  currentTime
                          DCD      0x00000000
                  canCheckCnt
000040  00                DCB      0x00
                  node_cycle
000041  010000            DCB      0x01,0x00,0x00
                  |symbol_number.91|
                          DCD      0x00000000
                  askForIdCnt
000048  0000              DCB      0x00,0x00
                  bufferIndex
00004a  0000              DCB      0x00,0x00
                  status
00004c  00                DCB      0x00

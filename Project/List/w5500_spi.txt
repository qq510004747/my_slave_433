; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\w5500_spi.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\w5500_spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\w5500_spi.crf ..\BSP\BSP_Internet\W5500\W5500_SPI.c]
                          THUMB

                          AREA ||i.Internet_Init||, CODE, READONLY, ALIGN=2

                  Internet_Init PROC
;;;26     /* Private functions -----------------------------------*/
;;;27     void  Internet_Init(void)
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29         W5500_SPI_Configuration();	         /*初始化MCU相关引脚*/
000002  f7fffffe          BL       W5500_SPI_Configuration
;;;30     	vTaskDelay(2000);
000006  f44f60fa          MOV      r0,#0x7d0
00000a  f7fffffe          BL       vTaskDelay
;;;31     //    /*硬复位W5500*/
;;;32         GPIO_ResetBits(WIZ_RESET_PORT, WIZ_RESET);
00000e  f44f6180          MOV      r1,#0x400
000012  480b              LDR      r0,|L1.64|
000014  f7fffffe          BL       GPIO_ResetBits
;;;33         vTaskDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       vTaskDelay
;;;34         GPIO_SetBits(WIZ_RESET_PORT, WIZ_RESET);
00001e  f44f6180          MOV      r1,#0x400
000022  4807              LDR      r0,|L1.64|
000024  f7fffffe          BL       GPIO_SetBits
;;;35     
;;;36     //	printf("w5500re_initok \n");
;;;37         vTaskDelay(2000);
000028  f44f60fa          MOV      r0,#0x7d0
00002c  f7fffffe          BL       vTaskDelay
;;;38     //    W5500_Set_MAC();			         /*配置MAC地址*/
;;;39         W5500_Set_IP();                      /*配置IP地址*/
000030  f7fffffe          BL       W5500_Set_IP
;;;40         socket_buf_init(txsize, rxsize);     /*初始化8个Socket的发送接收缓存大小*/	
000034  4903              LDR      r1,|L1.68|
000036  4804              LDR      r0,|L1.72|
000038  f7fffffe          BL       socket_buf_init
;;;41     }
00003c  bd10              POP      {r4,pc}
;;;42     /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0x40010800
                  |L1.68|
                          DCD      rxsize
                  |L1.72|
                          DCD      txsize

                          AREA ||i.W5500_SPI_Configuration||, CODE, READONLY, ALIGN=2

                  W5500_SPI_Configuration PROC
;;;45       */
;;;46     void W5500_SPI_Configuration(void)
000000  b500              PUSH     {lr}
;;;47     {
000002  b087              SUB      sp,sp,#0x1c
;;;48      	GPIO_InitTypeDef GPIO_InitStructure;
;;;49     	SPI_InitTypeDef  SPI_InitStructure;
;;;50     
;;;51     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;52     	
;;;53     	RCC_APB2PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;54     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
000014  2101              MOVS     r1,#1
000016  2008              MOVS     r0,#8
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;55     	
;;;56     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  0388              LSLS     r0,r1,#14
000020  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;57     
;;;58         RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
000024  2101              MOVS     r1,#1
000026  0388              LSLS     r0,r1,#14
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;59     	
;;;60         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | WIZ_RESET_RCC | WIZ_SCS_RCC | WIZ_Pwr_RCC, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  200c              MOVS     r0,#0xc
000030  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     	
;;;62     	
;;;63     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
000034  f44f4060          MOV      r0,#0xe000
000038  f8ad0018          STRH     r0,[sp,#0x18]
;;;64     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //PB13/14/15复用推挽输出 
00003c  2018              MOVS     r0,#0x18
00003e  f88d001b          STRB     r0,[sp,#0x1b]
;;;65     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000042  2003              MOVS     r0,#3
000044  f88d001a          STRB     r0,[sp,#0x1a]
;;;66     	GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化GPIOB
000048  a906              ADD      r1,sp,#0x18
00004a  4831              LDR      r0,|L2.272|
00004c  f7fffffe          BL       GPIO_Init
;;;67     
;;;68      	GPIO_SetBits(GPIOB,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);  //PB13/14/15上拉
000050  f44f4160          MOV      r1,#0xe000
000054  482e              LDR      r0,|L2.272|
000056  f7fffffe          BL       GPIO_SetBits
;;;69     	
;;;70     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
00005a  2000              MOVS     r0,#0
00005c  f8ad0004          STRH     r0,[sp,#4]
;;;71     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000060  f44f7082          MOV      r0,#0x104
000064  f8ad0006          STRH     r0,[sp,#6]
;;;72     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
000068  2000              MOVS     r0,#0
00006a  f8ad0008          STRH     r0,[sp,#8]
;;;73     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平
00006e  2002              MOVS     r0,#2
000070  f8ad000a          STRH     r0,[sp,#0xa]
;;;74     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000074  2001              MOVS     r0,#1
000076  f8ad000c          STRH     r0,[sp,#0xc]
;;;75     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
00007a  0240              LSLS     r0,r0,#9
00007c  f8ad000e          STRH     r0,[sp,#0xe]
;;;76     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
000080  2038              MOVS     r0,#0x38
000082  f8ad0010          STRH     r0,[sp,#0x10]
;;;77     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
000086  2000              MOVS     r0,#0
000088  f8ad0012          STRH     r0,[sp,#0x12]
;;;78     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
00008c  2007              MOVS     r0,#7
00008e  f8ad0014          STRH     r0,[sp,#0x14]
;;;79     	SPI_Init(SPI2, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
000092  a901              ADD      r1,sp,#4
000094  481f              LDR      r0,|L2.276|
000096  f7fffffe          BL       SPI_Init
;;;80      
;;;81     	SPI_I2S_ITConfig(SPI1,SPI_I2S_IT_RXNE,ENABLE);
00009a  2201              MOVS     r2,#1
00009c  2160              MOVS     r1,#0x60
00009e  481e              LDR      r0,|L2.280|
0000a0  f7fffffe          BL       SPI_I2S_ITConfig
;;;82     	SPI_Cmd(SPI2, ENABLE); //使能SPI外设
0000a4  2101              MOVS     r1,#1
0000a6  481b              LDR      r0,|L2.276|
0000a8  f7fffffe          BL       SPI_Cmd
;;;83     	
;;;84     	W5500_SPI_SendByte(0xff);//启动传输		
0000ac  20ff              MOVS     r0,#0xff
0000ae  f7fffffe          BL       W5500_SPI_SendByte
;;;85     	
;;;86     	
;;;87         //初始化片电源控制引脚
;;;88     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000b2  2010              MOVS     r0,#0x10
0000b4  f88d001b          STRB     r0,[sp,#0x1b]
;;;89     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
0000b8  2001              MOVS     r0,#1
0000ba  f88d001a          STRB     r0,[sp,#0x1a]
;;;90         GPIO_InitStructure.GPIO_Pin = WIZ_Pwr;
0000be  0240              LSLS     r0,r0,#9
0000c0  f8ad0018          STRH     r0,[sp,#0x18]
;;;91         GPIO_Init(WIZ_Pwr_PORT, &GPIO_InitStructure);
0000c4  a906              ADD      r1,sp,#0x18
0000c6  4815              LDR      r0,|L2.284|
0000c8  f7fffffe          BL       GPIO_Init
;;;92         GPIO_SetBits(WIZ_Pwr_PORT,WIZ_Pwr);
0000cc  f44f7100          MOV      r1,#0x200
0000d0  4812              LDR      r0,|L2.284|
0000d2  f7fffffe          BL       GPIO_SetBits
;;;93     	
;;;94     	//初始化片选输出引脚
;;;95         GPIO_InitStructure.GPIO_Pin = WIZ_SCS;
0000d6  f44f5080          MOV      r0,#0x1000
0000da  f8ad0018          STRH     r0,[sp,#0x18]
;;;96     //    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
;;;97     //    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
;;;98     //    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
;;;99         GPIO_Init(WIZ_SCS_PORT, &GPIO_InitStructure);
0000de  a906              ADD      r1,sp,#0x18
0000e0  480e              LDR      r0,|L2.284|
0000e2  f7fffffe          BL       GPIO_Init
;;;100        GPIO_SetBits(WIZ_SCS_PORT,WIZ_SCS);
0000e6  f44f5180          MOV      r1,#0x1000
0000ea  480c              LDR      r0,|L2.284|
0000ec  f7fffffe          BL       GPIO_SetBits
;;;101    	
;;;102        //初始化复位输出引脚
;;;103        GPIO_InitStructure.GPIO_Pin = WIZ_RESET;
0000f0  f44f6080          MOV      r0,#0x400
0000f4  f8ad0018          STRH     r0,[sp,#0x18]
;;;104    //    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
;;;105    //    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
;;;106    //    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
;;;107        GPIO_Init(WIZ_RESET_PORT, &GPIO_InitStructure);
0000f8  a906              ADD      r1,sp,#0x18
0000fa  4808              LDR      r0,|L2.284|
0000fc  f7fffffe          BL       GPIO_Init
;;;108        GPIO_SetBits(WIZ_RESET_PORT,WIZ_RESET);
000100  f44f6180          MOV      r1,#0x400
000104  4805              LDR      r0,|L2.284|
000106  f7fffffe          BL       GPIO_SetBits
;;;109    
;;;110    }
00010a  b007              ADD      sp,sp,#0x1c
00010c  bd00              POP      {pc}
;;;111    
                          ENDP

00010e  0000              DCW      0x0000
                  |L2.272|
                          DCD      0x40010c00
                  |L2.276|
                          DCD      0x40003800
                  |L2.280|
                          DCD      0x40013000
                  |L2.284|
                          DCD      0x40010800

                          AREA ||i.W5500_SPI_SendByte||, CODE, READONLY, ALIGN=2

                  W5500_SPI_SendByte PROC
;;;116    */
;;;117    uint8_t W5500_SPI_SendByte(uint8_t byte)
000000  b510              PUSH     {r4,lr}
;;;118    {
000002  4604              MOV      r4,r0
;;;119    	/* Loop while DR register in not emplty */
;;;120        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L3.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L3.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L3.6|
;;;121        /* Send byte through the SPI1 peripheral */
;;;122        SPI_I2S_SendData(SPI2, byte);
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L3.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;123    
;;;124        /* Wait to receive a byte */
;;;125        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L3.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L3.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L3.28|
;;;126        /* Return the byte read from the SPI bus */
;;;127        return SPI_I2S_ReceiveData(SPI2);
000028  4802              LDR      r0,|L3.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;128    }
000030  bd10              POP      {r4,pc}
;;;129    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x40003800

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\w5500.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\w5500.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\w5500.crf ..\BSP\BSP_Internet\W5500\w5500.c]
                          THUMB

                          AREA ||i.W5500_Check_Link||, CODE, READONLY, ALIGN=1

                  W5500_Check_Link PROC
;;;409    #define LINK 1
;;;410    unsigned char W5500_Check_Link(void)  //1成功，0失败
000000  b510              PUSH     {r4,lr}
;;;411    {
;;;412    	if((IINCHIP_READ(PHYCFGR) & LINK) == FALSE)//等待以太网连接完成
000002  f44f5038          MOV      r0,#0x2e00
000006  f7fffffe          BL       IINCHIP_READ
00000a  f0000001          AND      r0,r0,#1
00000e  b908              CBNZ     r0,|L1.20|
;;;413    	     return TRUE;
000010  2001              MOVS     r0,#1
                  |L1.18|
;;;414    	return FALSE;
;;;415    }
000012  bd10              POP      {r4,pc}
                  |L1.20|
000014  2000              MOVS     r0,#0                 ;414
000016  e7fc              B        |L1.18|
;;;416    /********** (C) COPYRIGHT DIY嵌入式开发工作室 （END OF FILE ）************************/
                          ENDP


                          AREA ||i.clearIR||, CODE, READONLY, ALIGN=1

                  clearIR PROC
;;;192    */
;;;193    void clearIR(uint8_t mask)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4604              MOV      r4,r0
;;;195        IINCHIP_WRITE(IR, ~mask | getIR() );
000004  f7fffffe          BL       getIR
000008  ea600004          ORN      r0,r0,r4
00000c  b2c5              UXTB     r5,r0
00000e  4629              MOV      r1,r5
000010  f44f50a8          MOV      r0,#0x1500
000014  f7fffffe          BL       IINCHIP_WRITE
;;;196    }
000018  bd70              POP      {r4-r6,pc}
;;;197    
                          ENDP


                          AREA ||i.getGAR||, CODE, READONLY, ALIGN=1

                  getGAR PROC
;;;77     */
;;;78     void getGAR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;79     {
000002  4604              MOV      r4,r0
;;;80         wiz_read_buf(GAR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  0190              LSLS     r0,r2,#6
00000a  f7fffffe          BL       wiz_read_buf
;;;81     }
00000e  bd10              POP      {r4,pc}
;;;82     
                          ENDP


                          AREA ||i.getIINCHIP_RxMAX||, CODE, READONLY, ALIGN=2

                  getIINCHIP_RxMAX PROC
;;;47     */
;;;48     uint16_t getIINCHIP_RxMAX(SOCKET s)
000000  4601              MOV      r1,r0
;;;49     {
;;;50         return RSIZE[s];
000002  4802              LDR      r0,|L4.12|
000004  f8300011          LDRH     r0,[r0,r1,LSL #1]
;;;51     }
000008  4770              BX       lr
;;;52     
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      RSIZE

                          AREA ||i.getIINCHIP_TxMAX||, CODE, READONLY, ALIGN=2

                  getIINCHIP_TxMAX PROC
;;;57     */
;;;58     uint16_t getIINCHIP_TxMAX(SOCKET s)
000000  4601              MOV      r1,r0
;;;59     {
;;;60         return SSIZE[s];
000002  4802              LDR      r0,|L5.12|
000004  f8300011          LDRH     r0,[r0,r1,LSL #1]
;;;61     }
000008  4770              BX       lr
;;;62     
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      SSIZE

                          AREA ||i.getIR||, CODE, READONLY, ALIGN=1

                  getIR PROC
;;;155    */
;;;156    uint8_t getIR( void )
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158        return IINCHIP_READ(IR);
000002  f44f50a8          MOV      r0,#0x1500
000006  f7fffffe          BL       IINCHIP_READ
;;;159    }
00000a  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.getSHAR||, CODE, READONLY, ALIGN=1

                  getSHAR PROC
;;;126    */
;;;127    void getSHAR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;128    {
000002  4604              MOV      r4,r0
;;;129        wiz_read_buf(SHAR0, addr, 6);
000004  2206              MOVS     r2,#6
000006  4621              MOV      r1,r4
000008  f44f6010          MOV      r0,#0x900
00000c  f7fffffe          BL       wiz_read_buf
;;;130    }
000010  bd10              POP      {r4,pc}
;;;131    
                          ENDP


                          AREA ||i.getSIPR||, CODE, READONLY, ALIGN=1

                  getSIPR PROC
;;;136    */
;;;137    void getSIPR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;138    {
000002  4604              MOV      r4,r0
;;;139        wiz_read_buf(SIPR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f6070          MOV      r0,#0xf00
00000c  f7fffffe          BL       wiz_read_buf
;;;140    }
000010  bd10              POP      {r4,pc}
;;;141    /**
                          ENDP


                          AREA ||i.getSUBR||, CODE, READONLY, ALIGN=1

                  getSUBR PROC
;;;116    */
;;;117    void getSUBR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;118    {
000002  4604              MOV      r4,r0
;;;119        wiz_read_buf(SUBR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f60a0          MOV      r0,#0x500
00000c  f7fffffe          BL       wiz_read_buf
;;;120    }
000010  bd10              POP      {r4,pc}
;;;121    
                          ENDP


                          AREA ||i.getSn_IR||, CODE, READONLY, ALIGN=1

                  getSn_IR PROC
;;;225    */
;;;226    uint8_t getSn_IR(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228        return IINCHIP_READ(Sn_IR(s));
000004  f44f7102          MOV      r1,#0x208
000008  eb011044          ADD      r0,r1,r4,LSL #5
00000c  f7fffffe          BL       IINCHIP_READ
;;;229    }
000010  bd10              POP      {r4,pc}
;;;230    
                          ENDP


                          AREA ||i.getSn_RX_RSR||, CODE, READONLY, ALIGN=1

                  getSn_RX_RSR PROC
;;;278    */
;;;279    uint16_t getSn_RX_RSR(SOCKET s)
000000  b570              PUSH     {r4-r6,lr}
;;;280    {
000002  4604              MOV      r4,r0
;;;281        uint16_t val=0,val1=0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;282        do
000008  bf00              NOP      
                  |L11.10|
;;;283        {
;;;284            val1 = IINCHIP_READ(Sn_RX_RSR0(s));
00000a  f2426108          MOV      r1,#0x2608
00000e  eb011044          ADD      r0,r1,r4,LSL #5
000012  f7fffffe          BL       IINCHIP_READ
000016  4606              MOV      r6,r0
;;;285            val1 = (val1 << 8) + IINCHIP_READ(Sn_RX_RSR1(s));
000018  f2427108          MOV      r1,#0x2708
00001c  eb011044          ADD      r0,r1,r4,LSL #5
000020  f7fffffe          BL       IINCHIP_READ
000024  eb002006          ADD      r0,r0,r6,LSL #8
000028  b286              UXTH     r6,r0
;;;286            if(val1 != 0)
00002a  b17e              CBZ      r6,|L11.76|
;;;287            {
;;;288                val = IINCHIP_READ(Sn_RX_RSR0(s));
00002c  f2426108          MOV      r1,#0x2608
000030  eb011044          ADD      r0,r1,r4,LSL #5
000034  f7fffffe          BL       IINCHIP_READ
000038  4605              MOV      r5,r0
;;;289                val = (val << 8) + IINCHIP_READ(Sn_RX_RSR1(s));
00003a  f2427108          MOV      r1,#0x2708
00003e  eb011044          ADD      r0,r1,r4,LSL #5
000042  f7fffffe          BL       IINCHIP_READ
000046  eb002005          ADD      r0,r0,r5,LSL #8
00004a  b285              UXTH     r5,r0
                  |L11.76|
;;;290            }
;;;291    
;;;292        } while (val != val1);
00004c  42b5              CMP      r5,r6
00004e  d1dc              BNE      |L11.10|
;;;293        return val;
000050  4628              MOV      r0,r5
;;;294    }
000052  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP


                          AREA ||i.getSn_SR||, CODE, READONLY, ALIGN=1

                  getSn_SR PROC
;;;245    */
;;;246    uint8_t getSn_SR(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248        return IINCHIP_READ(Sn_SR(s));
000004  f44f7142          MOV      r1,#0x308
000008  eb011044          ADD      r0,r1,r4,LSL #5
00000c  f7fffffe          BL       IINCHIP_READ
;;;249    }
000010  bd10              POP      {r4,pc}
;;;250    
                          ENDP


                          AREA ||i.getSn_TX_FSR||, CODE, READONLY, ALIGN=1

                  getSn_TX_FSR PROC
;;;257    */
;;;258    uint16_t getSn_TX_FSR(SOCKET s)
000000  b570              PUSH     {r4-r6,lr}
;;;259    {
000002  4604              MOV      r4,r0
;;;260        uint16_t val=0,val1=0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;261        do
000008  bf00              NOP      
                  |L13.10|
;;;262        {
;;;263            val1 = IINCHIP_READ(Sn_TX_FSR0(s));
00000a  f2420108          MOV      r1,#0x2008
00000e  eb011044          ADD      r0,r1,r4,LSL #5
000012  f7fffffe          BL       IINCHIP_READ
000016  4606              MOV      r6,r0
;;;264            val1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
000018  f2421108          MOV      r1,#0x2108
00001c  eb011044          ADD      r0,r1,r4,LSL #5
000020  f7fffffe          BL       IINCHIP_READ
000024  eb002006          ADD      r0,r0,r6,LSL #8
000028  b286              UXTH     r6,r0
;;;265            if (val1 != 0)
00002a  b17e              CBZ      r6,|L13.76|
;;;266            {
;;;267                val = IINCHIP_READ(Sn_TX_FSR0(s));
00002c  f2420108          MOV      r1,#0x2008
000030  eb011044          ADD      r0,r1,r4,LSL #5
000034  f7fffffe          BL       IINCHIP_READ
000038  4605              MOV      r5,r0
;;;268                val = (val << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
00003a  f2421108          MOV      r1,#0x2108
00003e  eb011044          ADD      r0,r1,r4,LSL #5
000042  f7fffffe          BL       IINCHIP_READ
000046  eb002005          ADD      r0,r0,r5,LSL #8
00004a  b285              UXTH     r5,r0
                  |L13.76|
;;;269            }
;;;270        } while (val != val1);
00004c  42b5              CMP      r5,r6
00004e  d1dc              BNE      |L13.10|
;;;271        return val;
000050  4628              MOV      r0,r5
;;;272    }
000052  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP


                          AREA ||i.iinchip_init||, CODE, READONLY, ALIGN=1

                  iinchip_init PROC
;;;37     */
;;;38     void iinchip_init(void)
000000  b510              PUSH     {r4,lr}
;;;39     {
;;;40         setMR( MR_RST );
000002  2080              MOVS     r0,#0x80
000004  f7fffffe          BL       setMR
;;;41     }
000008  bd10              POP      {r4,pc}
;;;42     
                          ENDP


                          AREA ||i.recv_data_processing||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  recv_data_processing PROC
;;;336    */
;;;337    void recv_data_processing(SOCKET s, uint8_t *data, uint16_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;338    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;339        uint16_t ptr = 0;
00000a  2500              MOVS     r5,#0
;;;340        uint32_t addrbsb = 0;
00000c  46a8              MOV      r8,r5
;;;341    
;;;342        if(len == 0)
00000e  b92e              CBNZ     r6,|L15.28|
;;;343        {
;;;344            printf("CH: %d Unexpected2 length 0\r\n", s);
000010  4621              MOV      r1,r4
000012  a018              ADR      r0,|L15.116|
000014  f7fffffe          BL       __2printf
                  |L15.24|
;;;345            return;
;;;346        }
;;;347    
;;;348        ptr = IINCHIP_READ( Sn_RX_RD0(s) );
;;;349        ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ( Sn_RX_RD1(s) );
;;;350    
;;;351        addrbsb = (uint32_t)(ptr<<8) + (s<<5) + 0x18;
;;;352        wiz_read_buf(addrbsb, data, len);
;;;353        ptr += len;
;;;354    
;;;355        IINCHIP_WRITE( Sn_RX_RD0(s), (uint8_t)((ptr & 0xff00) >> 8));
;;;356        IINCHIP_WRITE( Sn_RX_RD1(s), (uint8_t)(ptr & 0x00ff));
;;;357    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L15.28|
00001c  f6420108          MOV      r1,#0x2808            ;348
000020  eb011044          ADD      r0,r1,r4,LSL #5       ;348
000024  f7fffffe          BL       IINCHIP_READ
000028  4605              MOV      r5,r0                 ;348
00002a  f6421108          MOV      r1,#0x2908            ;349
00002e  eb011044          ADD      r0,r1,r4,LSL #5       ;349
000032  f7fffffe          BL       IINCHIP_READ
000036  eb002005          ADD      r0,r0,r5,LSL #8       ;349
00003a  b285              UXTH     r5,r0                 ;349
00003c  0228              LSLS     r0,r5,#8              ;351
00003e  eb001044          ADD      r0,r0,r4,LSL #5       ;351
000042  f1000818          ADD      r8,r0,#0x18           ;351
000046  4632              MOV      r2,r6                 ;352
000048  4639              MOV      r1,r7                 ;352
00004a  4640              MOV      r0,r8                 ;352
00004c  f7fffffe          BL       wiz_read_buf
000050  19a8              ADDS     r0,r5,r6              ;353
000052  b285              UXTH     r5,r0                 ;353
000054  0a29              LSRS     r1,r5,#8              ;355
000056  f6420208          MOV      r2,#0x2808            ;355
00005a  eb021044          ADD      r0,r2,r4,LSL #5       ;355
00005e  f7fffffe          BL       IINCHIP_WRITE
000062  b2e9              UXTB     r1,r5                 ;356
000064  f6421208          MOV      r2,#0x2908            ;356
000068  eb021044          ADD      r0,r2,r4,LSL #5       ;356
00006c  f7fffffe          BL       IINCHIP_WRITE
000070  bf00              NOP      
000072  e7d1              B        |L15.24|
;;;358    
                          ENDP

                  |L15.116|
000074  43483a20          DCB      "CH: %d Unexpected2 length 0\r\n",0
000078  25642055
00007c  6e657870
000080  65637465
000084  6432206c
000088  656e6774
00008c  6820300d
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.send_data_processing||, CODE, READONLY, ALIGN=1

                  send_data_processing PROC
;;;305    */
;;;306    void send_data_processing(SOCKET s, uint8_t *data, uint16_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;307    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;308        uint16_t ptr =0;
00000a  2500              MOVS     r5,#0
;;;309        uint32_t addrbsb =0;
00000c  46a8              MOV      r8,r5
;;;310        if(len == 0)
00000e  b90e              CBNZ     r6,|L16.20|
                  |L16.16|
;;;311        {
;;;312    //        printf("CH: %d Unexpected1 length 0\r\n", s);
;;;313            return;
;;;314        }
;;;315    
;;;316        ptr = IINCHIP_READ( Sn_TX_WR0(s) );
;;;317        ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_TX_WR1(s));
;;;318    
;;;319        addrbsb = (uint32_t)(ptr<<8) + (s<<5) + 0x10;
;;;320        wiz_write_buf(addrbsb, data, len);
;;;321    
;;;322        ptr += len;
;;;323        IINCHIP_WRITE( Sn_TX_WR0(s) ,(uint8_t)((ptr & 0xff00) >> 8));
;;;324        IINCHIP_WRITE( Sn_TX_WR1(s),(uint8_t)(ptr & 0x00ff));
;;;325    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L16.20|
000014  f2424108          MOV      r1,#0x2408            ;316
000018  eb011044          ADD      r0,r1,r4,LSL #5       ;316
00001c  f7fffffe          BL       IINCHIP_READ
000020  4605              MOV      r5,r0                 ;316
000022  f2425108          MOV      r1,#0x2508            ;317
000026  eb011044          ADD      r0,r1,r4,LSL #5       ;317
00002a  f7fffffe          BL       IINCHIP_READ
00002e  eb002005          ADD      r0,r0,r5,LSL #8       ;317
000032  b285              UXTH     r5,r0                 ;317
000034  0228              LSLS     r0,r5,#8              ;319
000036  eb001044          ADD      r0,r0,r4,LSL #5       ;319
00003a  f1000810          ADD      r8,r0,#0x10           ;319
00003e  4632              MOV      r2,r6                 ;320
000040  4639              MOV      r1,r7                 ;320
000042  4640              MOV      r0,r8                 ;320
000044  f7fffffe          BL       wiz_write_buf
000048  19a8              ADDS     r0,r5,r6              ;322
00004a  b285              UXTH     r5,r0                 ;322
00004c  0a29              LSRS     r1,r5,#8              ;323
00004e  f2424208          MOV      r2,#0x2408            ;323
000052  eb021044          ADD      r0,r2,r4,LSL #5       ;323
000056  f7fffffe          BL       IINCHIP_WRITE
00005a  b2e9              UXTB     r1,r5                 ;324
00005c  f2425208          MOV      r2,#0x2508            ;324
000060  eb021044          ADD      r0,r2,r4,LSL #5       ;324
000064  f7fffffe          BL       IINCHIP_WRITE
000068  bf00              NOP      
00006a  e7d1              B        |L16.16|
;;;326    
                          ENDP


                          AREA ||i.setGAR||, CODE, READONLY, ALIGN=1

                  setGAR PROC
;;;67     */
;;;68     void setGAR(uint8_t * addr )
000000  b510              PUSH     {r4,lr}
;;;69     {
000002  4604              MOV      r4,r0
;;;70         wiz_write_buf(GAR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  0190              LSLS     r0,r2,#6
00000a  f7fffffe          BL       wiz_write_buf
;;;71     }
00000e  bd10              POP      {r4,pc}
;;;72     
                          ENDP


                          AREA ||i.setMR||, CODE, READONLY, ALIGN=1

                  setMR PROC
;;;145    */
;;;146    void setMR(uint8_t val)
000000  b510              PUSH     {r4,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148        IINCHIP_WRITE(MR,val);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       IINCHIP_WRITE
;;;149    }
00000c  bd10              POP      {r4,pc}
;;;150    
                          ENDP


                          AREA ||i.setRCR||, CODE, READONLY, ALIGN=1

                  setRCR PROC
;;;180    */
;;;181    void setRCR(uint8_t retry)
000000  b510              PUSH     {r4,lr}
;;;182    {
000002  4604              MOV      r4,r0
;;;183        IINCHIP_WRITE(WIZ_RCR,retry);
000004  4621              MOV      r1,r4
000006  f44f50d8          MOV      r0,#0x1b00
00000a  f7fffffe          BL       IINCHIP_WRITE
;;;184    }
00000e  bd10              POP      {r4,pc}
;;;185    
                          ENDP


                          AREA ||i.setRTR||, CODE, READONLY, ALIGN=1

                  setRTR PROC
;;;167    */
;;;168    void setRTR(uint16_t timeout)
000000  b510              PUSH     {r4,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170        IINCHIP_WRITE(RTR0,(uint8_t)((timeout & 0xff00) >> 8));
000004  0a21              LSRS     r1,r4,#8
000006  f44f50c8          MOV      r0,#0x1900
00000a  f7fffffe          BL       IINCHIP_WRITE
;;;171        IINCHIP_WRITE(RTR1,(uint8_t)(timeout & 0x00ff));
00000e  b2e1              UXTB     r1,r4
000010  f44f50d0          MOV      r0,#0x1a00
000014  f7fffffe          BL       IINCHIP_WRITE
;;;172    }
000018  bd10              POP      {r4,pc}
;;;173    
                          ENDP


                          AREA ||i.setSHAR||, CODE, READONLY, ALIGN=1

                  setSHAR PROC
;;;96     */
;;;97     void setSHAR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;98     {
000002  4604              MOV      r4,r0
;;;99         wiz_write_buf(SHAR0, addr, 6);
000004  2206              MOVS     r2,#6
000006  4621              MOV      r1,r4
000008  f44f6010          MOV      r0,#0x900
00000c  f7fffffe          BL       wiz_write_buf
;;;100    }
000010  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.setSIPR||, CODE, READONLY, ALIGN=1

                  setSIPR PROC
;;;106    */
;;;107    void setSIPR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;108    {
000002  4604              MOV      r4,r0
;;;109        wiz_write_buf(SIPR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f6070          MOV      r0,#0xf00
00000c  f7fffffe          BL       wiz_write_buf
;;;110    }
000010  bd10              POP      {r4,pc}
;;;111    
                          ENDP


                          AREA ||i.setSUBR||, CODE, READONLY, ALIGN=1

                  setSUBR PROC
;;;87     */
;;;88     void setSUBR(uint8_t * addr)
000000  b510              PUSH     {r4,lr}
;;;89     {
000002  4604              MOV      r4,r0
;;;90         wiz_write_buf(SUBR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f60a0          MOV      r0,#0x500
00000c  f7fffffe          BL       wiz_write_buf
;;;91     }
000010  bd10              POP      {r4,pc}
;;;92     /**
                          ENDP


                          AREA ||i.setSn_IR||, CODE, READONLY, ALIGN=1

                  setSn_IR PROC
;;;235    */
;;;236    void setSn_IR(uint8_t s, uint8_t val)
000000  b570              PUSH     {r4-r6,lr}
;;;237    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;238        IINCHIP_WRITE(Sn_IR(s), val);
000006  f44f7102          MOV      r1,#0x208
00000a  eb011044          ADD      r0,r1,r4,LSL #5
00000e  4629              MOV      r1,r5
000010  f7fffffe          BL       IINCHIP_WRITE
;;;239    }
000014  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP


                          AREA ||i.setSn_MSS||, CODE, READONLY, ALIGN=1

                  setSn_MSS PROC
;;;203    */
;;;204    void setSn_MSS(SOCKET s, uint16_t Sn_MSSR)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;206        IINCHIP_WRITE( Sn_MSSR0(s), (uint8_t)((Sn_MSSR & 0xff00) >> 8));
000006  0a29              LSRS     r1,r5,#8
000008  f2412208          MOV      r2,#0x1208
00000c  eb021044          ADD      r0,r2,r4,LSL #5
000010  f7fffffe          BL       IINCHIP_WRITE
;;;207        IINCHIP_WRITE( Sn_MSSR1(s), (uint8_t)(Sn_MSSR & 0x00ff));
000014  b2e9              UXTB     r1,r5
000016  f2413208          MOV      r2,#0x1308
00001a  eb021044          ADD      r0,r2,r4,LSL #5
00001e  f7fffffe          BL       IINCHIP_WRITE
;;;208    }
000022  bd70              POP      {r4-r6,pc}
;;;209    
                          ENDP


                          AREA ||i.setSn_TTL||, CODE, READONLY, ALIGN=1

                  setSn_TTL PROC
;;;215    */
;;;216    void setSn_TTL(SOCKET s, uint8_t ttl)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;218        IINCHIP_WRITE( Sn_TTL(s) , ttl);
000006  f2416108          MOV      r1,#0x1608
00000a  eb011044          ADD      r0,r1,r4,LSL #5
00000e  4629              MOV      r1,r5
000010  f7fffffe          BL       IINCHIP_WRITE
;;;219    }
000014  bd70              POP      {r4-r6,pc}
;;;220    
                          ENDP


                          AREA ||i.socket_buf_init||, CODE, READONLY, ALIGN=2

                  socket_buf_init PROC
;;;373    */
;;;374    void socket_buf_init( uint8_t * tx_size, uint8_t * rx_size  )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;375    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;376        int16_t i;
;;;377        int16_t ssum=0,rsum=0;
000008  2700              MOVS     r7,#0
00000a  46b8              MOV      r8,r7
;;;378    
;;;379        for (i = 0 ; i < MAX_SOCK_NUM; i++)       // Set the size, masking and base address of Tx & Rx memory by each channel
00000c  2400              MOVS     r4,#0
00000e  e037              B        |L27.128|
                  |L27.16|
;;;380        {
;;;381            IINCHIP_WRITE( (Sn_TXMEM_SIZE(i)), tx_size[i]);
000010  5d29              LDRB     r1,[r5,r4]
000012  f6417208          MOV      r2,#0x1f08
000016  eb021044          ADD      r0,r2,r4,LSL #5
00001a  f7fffffe          BL       IINCHIP_WRITE
;;;382            IINCHIP_WRITE( (Sn_RXMEM_SIZE(i)), rx_size[i]);
00001e  5d31              LDRB     r1,[r6,r4]
000020  f6416208          MOV      r2,#0x1e08
000024  eb021044          ADD      r0,r2,r4,LSL #5
000028  f7fffffe          BL       IINCHIP_WRITE
;;;383    
;;;384            SSIZE[i] = (int16_t)(0);
00002c  2000              MOVS     r0,#0
00002e  4916              LDR      r1,|L27.136|
000030  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;385            RSIZE[i] = (int16_t)(0);
000034  4915              LDR      r1,|L27.140|
000036  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;386    
;;;387            if (ssum <= 16384)
00003a  f5b74f80          CMP      r7,#0x4000
00003e  dc07              BGT      |L27.80|
;;;388            {
;;;389                SSIZE[i] = (int16_t)tx_size[i]*(1024);
000040  5d28              LDRB     r0,[r5,r4]
000042  f64f71ff          MOV      r1,#0xffff
000046  ea012080          AND      r0,r1,r0,LSL #10
00004a  490f              LDR      r1,|L27.136|
00004c  f8210014          STRH     r0,[r1,r4,LSL #1]
                  |L27.80|
;;;390            }
;;;391    
;;;392            if (rsum <= 16384)
000050  f5b84f80          CMP      r8,#0x4000
000054  dc07              BGT      |L27.102|
;;;393            {
;;;394                RSIZE[i]=(int16_t)rx_size[i]*(1024);
000056  5d30              LDRB     r0,[r6,r4]
000058  f64f71ff          MOV      r1,#0xffff
00005c  ea012080          AND      r0,r1,r0,LSL #10
000060  490a              LDR      r1,|L27.140|
000062  f8210014          STRH     r0,[r1,r4,LSL #1]
                  |L27.102|
;;;395            }
;;;396            ssum += SSIZE[i];
000066  4808              LDR      r0,|L27.136|
000068  f8300014          LDRH     r0,[r0,r4,LSL #1]
00006c  4438              ADD      r0,r0,r7
00006e  b207              SXTH     r7,r0
;;;397            rsum += RSIZE[i];
000070  4806              LDR      r0,|L27.140|
000072  f8300014          LDRH     r0,[r0,r4,LSL #1]
000076  4440              ADD      r0,r0,r8
000078  fa0ff880          SXTH     r8,r0
00007c  1c60              ADDS     r0,r4,#1              ;379
00007e  b204              SXTH     r4,r0                 ;379
                  |L27.128|
000080  2c08              CMP      r4,#8                 ;379
000082  dbc5              BLT      |L27.16|
;;;398    
;;;399        }
;;;400    }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;401    
                          ENDP

                  |L27.136|
                          DCD      SSIZE
                  |L27.140|
                          DCD      RSIZE

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  SSIZE
                          %        16
                  RSIZE
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  txsize
000000  02020202          DCB      0x02,0x02,0x02,0x02
000004  02020202          DCB      0x02,0x02,0x02,0x02
                  rxsize
000008  02020202          DCB      0x02,0x02,0x02,0x02
00000c  02020202          DCB      0x02,0x02,0x02,0x02

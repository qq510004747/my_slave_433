; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\bsp_sst25vf016b.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\bsp_sst25vf016b.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\BSP_USART2 -IC:\Users\Administrator\Desktop\FreeRTOS工程摸板V2.0.0\Project\RTE -IF:\keil5-22\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -IF:\keil5-22\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\bsp_sst25vf016b.crf ..\BSP\BSP_FLASH\bsp_SST25VF016B.c]
                          THUMB

                          AREA ||i.Flash_AutoWritePage||, CODE, READONLY, ALIGN=2

                  Flash_AutoWritePage PROC
;;;303    *********************************************************/ 
;;;304    static uint8_t Flash_AutoWritePage(uint8_t *_ucpSrc, uint32_t _uiWrAddr, uint16_t _usWrLen)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;305    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;306    	uint16_t i;
;;;307    	uint16_t j;					/* 用于延时 */
;;;308    	uint32_t uiFirstAddr;		/* 扇区首址 */
;;;309    	uint8_t ucNeedErase;		/* 1表示需要擦除 */
;;;310    	uint8_t cRet;
;;;311    	/* 长度为0时不继续操作,直接认为成功 */
;;;312    	if (_usWrLen == 0)
00000a  b916              CBNZ     r6,|L1.18|
;;;313    	{
;;;314    		return 1;
00000c  2001              MOVS     r0,#1
                  |L1.14|
;;;315    	}	
;;;316    	/* 如果偏移地址超过芯片容量则退出 */
;;;317    	if (_uiWrAddr >= Flash_TOTAL_SIZE)
;;;318    	{
;;;319    		return 0;
;;;320    	}
;;;321    	/* 如果数据长度大于扇区容量，则退出 */
;;;322    	if (_usWrLen > Flash_PAGE_SIZE)
;;;323    	{
;;;324    		return 0;
;;;325    	}
;;;326    	/* 如果FLASH中的数据没有变化,则不写FLASH */
;;;327    	Flash_ReadBuffer(s_spiBuf, _uiWrAddr, _usWrLen);
;;;328    	if (memcmp(s_spiBuf, _ucpSrc, _usWrLen) == 0)
;;;329    	{
;;;330    		return 1;
;;;331    	}
;;;332    	/* 判断是否需要先擦除扇区 */
;;;333    	/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;334    	ucNeedErase = 0;
;;;335    	if (Flash_NeedErase(s_spiBuf, _ucpSrc, _usWrLen))
;;;336    	{
;;;337    		ucNeedErase = 1;
;;;338    	}
;;;339    	uiFirstAddr = _uiWrAddr & (~(Flash_PAGE_SIZE - 1));
;;;340    
;;;341    	if (_usWrLen == Flash_PAGE_SIZE)		/* 整个扇区都改写 */
;;;342    	{
;;;343    		for	(i = 0; i < Flash_PAGE_SIZE; i++)
;;;344    		{
;;;345    			s_spiBuf[i] = _ucpSrc[i];
;;;346    		}
;;;347    	}
;;;348    	else						/* 改写部分数据 */
;;;349    	{
;;;350    		/* 先将整个扇区的数据读出 */
;;;351    		Flash_ReadBuffer(s_spiBuf, uiFirstAddr, Flash_PAGE_SIZE);
;;;352    
;;;353    		/* 再用新数据覆盖 */
;;;354    		i = _uiWrAddr & (Flash_PAGE_SIZE - 1);
;;;355    		memcpy(&s_spiBuf[i], _ucpSrc, _usWrLen);
;;;356    	}
;;;357    
;;;358    	/* 写完之后进行校验，如果不正确则重写，最多3次 */
;;;359    	cRet = 0;
;;;360    	for (i = 0; i < 3; i++)
;;;361    	{
;;;362    		/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;363    		if (ucNeedErase == 1)
;;;364    		{			
;;;365    			Flash_EraseSector(uiFirstAddr);		/* 擦除1个扇区 */
;;;366    		}
;;;367    		/* 编程一个PAGE */
;;;368    		Flash_PageWrite(s_spiBuf, uiFirstAddr, Flash_PAGE_SIZE);
;;;369    	
;;;370    		if (Flash_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;371    		{
;;;372    			cRet = 1;
;;;373    			break;
;;;374    		}
;;;375    		else
;;;376    		{
;;;377    			if (Flash_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;378    			{
;;;379    				cRet = 1;
;;;380    				break;
;;;381    			}
;;;382    
;;;383    			/* 失败后延迟一段时间再重试 */
;;;384    			for (j = 0; j < 10000; j++);
;;;385    		}
;;;386    	}
;;;387    	return cRet;
;;;388    }
00000e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.18|
000012  f5b51f00          CMP      r5,#0x200000          ;317
000016  d301              BCC      |L1.28|
000018  2000              MOVS     r0,#0                 ;319
00001a  e7f8              B        |L1.14|
                  |L1.28|
00001c  f5b65f80          CMP      r6,#0x1000            ;322
000020  dd01              BLE      |L1.38|
000022  2000              MOVS     r0,#0                 ;324
000024  e7f3              B        |L1.14|
                  |L1.38|
000026  4632              MOV      r2,r6                 ;327
000028  4629              MOV      r1,r5                 ;327
00002a  4834              LDR      r0,|L1.252|
00002c  f7fffffe          BL       Flash_ReadBuffer
000030  4632              MOV      r2,r6                 ;328
000032  4639              MOV      r1,r7                 ;328
000034  4831              LDR      r0,|L1.252|
000036  f7fffffe          BL       memcmp
00003a  b908              CBNZ     r0,|L1.64|
00003c  2001              MOVS     r0,#1                 ;330
00003e  e7e6              B        |L1.14|
                  |L1.64|
000040  f04f0a00          MOV      r10,#0                ;334
000044  4632              MOV      r2,r6                 ;335
000046  4639              MOV      r1,r7                 ;335
000048  482c              LDR      r0,|L1.252|
00004a  f7fffffe          BL       Flash_NeedErase
00004e  b108              CBZ      r0,|L1.84|
000050  f04f0a01          MOV      r10,#1                ;337
                  |L1.84|
000054  ea4f3815          LSR      r8,r5,#12             ;339
000058  ea4f3808          LSL      r8,r8,#12             ;339
00005c  f5b65f80          CMP      r6,#0x1000            ;341
000060  d10a              BNE      |L1.120|
000062  2400              MOVS     r4,#0                 ;343
000064  e004              B        |L1.112|
                  |L1.102|
000066  5d38              LDRB     r0,[r7,r4]            ;345
000068  4924              LDR      r1,|L1.252|
00006a  5508              STRB     r0,[r1,r4]            ;345
00006c  1c60              ADDS     r0,r4,#1              ;343
00006e  b284              UXTH     r4,r0                 ;343
                  |L1.112|
000070  f5b45f80          CMP      r4,#0x1000            ;343
000074  dbf7              BLT      |L1.102|
000076  e00d              B        |L1.148|
                  |L1.120|
000078  f44f5280          MOV      r2,#0x1000            ;351
00007c  4641              MOV      r1,r8                 ;351
00007e  481f              LDR      r0,|L1.252|
000080  f7fffffe          BL       Flash_ReadBuffer
000084  f3c5040b          UBFX     r4,r5,#0,#12          ;354
000088  491c              LDR      r1,|L1.252|
00008a  1908              ADDS     r0,r1,r4              ;355
00008c  4632              MOV      r2,r6                 ;355
00008e  4639              MOV      r1,r7                 ;355
000090  f7fffffe          BL       __aeabi_memcpy
                  |L1.148|
000094  f04f0b00          MOV      r11,#0                ;359
000098  2400              MOVS     r4,#0                 ;360
00009a  e02a              B        |L1.242|
                  |L1.156|
00009c  f1ba0f01          CMP      r10,#1                ;363
0000a0  d102              BNE      |L1.168|
0000a2  4640              MOV      r0,r8                 ;365
0000a4  f7fffffe          BL       Flash_EraseSector
                  |L1.168|
0000a8  f44f5280          MOV      r2,#0x1000            ;368
0000ac  4641              MOV      r1,r8                 ;368
0000ae  4813              LDR      r0,|L1.252|
0000b0  f7fffffe          BL       Flash_PageWrite
0000b4  4632              MOV      r2,r6                 ;370
0000b6  4639              MOV      r1,r7                 ;370
0000b8  4628              MOV      r0,r5                 ;370
0000ba  f7fffffe          BL       Flash_CmpData
0000be  b910              CBNZ     r0,|L1.198|
0000c0  f04f0b01          MOV      r11,#1                ;372
0000c4  e017              B        |L1.246|
                  |L1.198|
0000c6  4632              MOV      r2,r6                 ;377
0000c8  4639              MOV      r1,r7                 ;377
0000ca  4628              MOV      r0,r5                 ;377
0000cc  f7fffffe          BL       Flash_CmpData
0000d0  b910              CBNZ     r0,|L1.216|
0000d2  f04f0b01          MOV      r11,#1                ;379
0000d6  e00e              B        |L1.246|
                  |L1.216|
0000d8  f04f0900          MOV      r9,#0                 ;384
0000dc  e003              B        |L1.230|
                  |L1.222|
0000de  f1090001          ADD      r0,r9,#1              ;384
0000e2  fa1ff980          UXTH     r9,r0                 ;384
                  |L1.230|
0000e6  f2427010          MOV      r0,#0x2710            ;384
0000ea  4581              CMP      r9,r0                 ;384
0000ec  dbf7              BLT      |L1.222|
0000ee  1c60              ADDS     r0,r4,#1              ;360
0000f0  b284              UXTH     r4,r0                 ;360
                  |L1.242|
0000f2  2c03              CMP      r4,#3                 ;360
0000f4  dbd2              BLT      |L1.156|
                  |L1.246|
0000f6  bf00              NOP                            ;373
0000f8  4658              MOV      r0,r11                ;387
0000fa  e788              B        |L1.14|
;;;389    /*******************************************************
                          ENDP

                  |L1.252|
                          DCD      s_spiBuf

                          AREA ||i.Flash_CmpData||, CODE, READONLY, ALIGN=2

                  Flash_CmpData PROC
;;;225    ***************************************************/
;;;226    static uint8_t Flash_CmpData(uint32_t _uiSrcAddr, uint8_t *_ucpTar, uint32_t _uiSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;227    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;228    	uint8_t ucValue;
;;;229    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;230    	if ((_uiSrcAddr + _uiSize) > Flash_TOTAL_SIZE)
00000a  1960              ADDS     r0,r4,r5
00000c  f5b01f00          CMP      r0,#0x200000
000010  d902              BLS      |L2.24|
;;;231    	{
;;;232    		return 1;
000012  2001              MOVS     r0,#1
                  |L2.20|
;;;233    	}
;;;234    	if (_uiSize == 0) 	
;;;235    	{
;;;236    		return 0;
;;;237    	}
;;;238    	Flash_CS_LOW();									/* 使能片选 */
;;;239    	Flash_SendByte(CMD_READ);							/* 发送读命令 */
;;;240    	Flash_SendByte((_uiSrcAddr & 0xFF0000) >> 16);		/* 发送扇区地址的高8bit */
;;;241    	Flash_SendByte((_uiSrcAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;242    	Flash_SendByte(_uiSrcAddr & 0xFF);					/* 发送扇区地址低8bit */	
;;;243    	while (_uiSize--)
;;;244    	{
;;;245    		/* 读一个字节 */
;;;246    		ucValue = Flash_SendByte(DUMMY_BYTE);		
;;;247    		if (*_ucpTar++ != ucValue)
;;;248    		{
;;;249    			Flash_CS_HIGH();
;;;250    			return 1;
;;;251    		}
;;;252    	}
;;;253    	Flash_CS_HIGH();	
;;;254    	return 0;
;;;255    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L2.24|
000018  b90d              CBNZ     r5,|L2.30|
00001a  2000              MOVS     r0,#0                 ;236
00001c  e7fa              B        |L2.20|
                  |L2.30|
00001e  2110              MOVS     r1,#0x10              ;238
000020  4814              LDR      r0,|L2.116|
000022  f7fffffe          BL       GPIO_ResetBits
000026  2003              MOVS     r0,#3                 ;239
000028  f7fffffe          BL       Flash_SendByte
00002c  f3c44007          UBFX     r0,r4,#16,#8          ;240
000030  f7fffffe          BL       Flash_SendByte
000034  f3c42007          UBFX     r0,r4,#8,#8           ;241
000038  f7fffffe          BL       Flash_SendByte
00003c  b2e0              UXTB     r0,r4                 ;242
00003e  f7fffffe          BL       Flash_SendByte
000042  e00d              B        |L2.96|
                  |L2.68|
000044  20a5              MOVS     r0,#0xa5              ;246
000046  f7fffffe          BL       Flash_SendByte
00004a  4607              MOV      r7,r0                 ;246
00004c  f8161b01          LDRB     r1,[r6],#1            ;247
000050  42b9              CMP      r1,r7                 ;247
000052  d005              BEQ      |L2.96|
000054  2110              MOVS     r1,#0x10              ;249
000056  4807              LDR      r0,|L2.116|
000058  f7fffffe          BL       GPIO_SetBits
00005c  2001              MOVS     r0,#1                 ;250
00005e  e7d9              B        |L2.20|
                  |L2.96|
000060  0028              MOVS     r0,r5                 ;243
000062  f1a50501          SUB      r5,r5,#1              ;243
000066  d1ed              BNE      |L2.68|
000068  2110              MOVS     r1,#0x10              ;253
00006a  4802              LDR      r0,|L2.116|
00006c  f7fffffe          BL       GPIO_SetBits
000070  2000              MOVS     r0,#0                 ;254
000072  e7cf              B        |L2.20|
;;;256    /**************************************************
                          ENDP

                  |L2.116|
                          DCD      0x40010800

                          AREA ||i.Flash_EraseChip||, CODE, READONLY, ALIGN=2

                  Flash_EraseChip PROC
;;;134    *****************************************************/  
;;;135    void Flash_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    	Flash_WriteEnable();								/* 发送写使能命令 */	
000002  f7fffffe          BL       Flash_WriteEnable
;;;138    	/* 擦除扇区操作 */
;;;139    	Flash_CS_LOW();									/* 使能片选 */
000006  2110              MOVS     r1,#0x10
000008  4806              LDR      r0,|L3.36|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;140    	Flash_SendByte(CMD_BE);							/* 发送擦除命令 */
00000e  20c7              MOVS     r0,#0xc7
000010  f7fffffe          BL       Flash_SendByte
;;;141    	Flash_CS_HIGH();									/* 禁能片选 */
000014  2110              MOVS     r1,#0x10
000016  4803              LDR      r0,|L3.36|
000018  f7fffffe          BL       GPIO_SetBits
;;;142    	Flash_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
00001c  f7fffffe          BL       Flash_WaitForWriteEnd
;;;143    }
000020  bd10              POP      {r4,pc}
;;;144    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x40010800

                          AREA ||i.Flash_EraseSector||, CODE, READONLY, ALIGN=2

                  Flash_EraseSector PROC
;;;115    ******************************************************/
;;;116    void Flash_EraseSector(uint32_t _uiSectorAddr)
000000  b510              PUSH     {r4,lr}
;;;117    {
000002  4604              MOV      r4,r0
;;;118    	Flash_WriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       Flash_WriteEnable
;;;119    	/* 擦除扇区操作 */
;;;120    	Flash_CS_LOW();									/* 使能片选 */
000008  2110              MOVS     r1,#0x10
00000a  480c              LDR      r0,|L4.60|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;121    	Flash_SendByte(CMD_SE);							/* 发送擦除命令 */
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       Flash_SendByte
;;;122    	Flash_SendByte((_uiSectorAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       Flash_SendByte
;;;123    	Flash_SendByte((_uiSectorAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       Flash_SendByte
;;;124    	Flash_SendByte(_uiSectorAddr & 0xFF);				/* 发送扇区地址低8bit */
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       Flash_SendByte
;;;125    	Flash_CS_HIGH();									/* 禁能片选 */	
00002c  2110              MOVS     r1,#0x10
00002e  4803              LDR      r0,|L4.60|
000030  f7fffffe          BL       GPIO_SetBits
;;;126    	Flash_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000034  f7fffffe          BL       Flash_WaitForWriteEnd
;;;127    }
000038  bd10              POP      {r4,pc}
;;;128    
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      0x40010800

                          AREA ||i.Flash_InitHard||, CODE, READONLY, ALIGN=2

                  Flash_InitHard PROC
;;;70     ***********************************/
;;;71     void Flash_InitHard(void)
000000  b500              PUSH     {lr}
;;;72     {
000002  b087              SUB      sp,sp,#0x1c
;;;73     	SPI_InitTypeDef  SPI_InitStructure;
;;;74     	GPIO_InitTypeDef GPIO_InitStructure;	
;;;75     	/* 使能 SPI 和 GPIO 时钟 */
;;;76     	RCC_APB2PeriphClockCmd(Flash_CLK | Flash_GPIO_CLK | Flash_CS_GPIO_CLK, ENABLE);	
000004  2101              MOVS     r1,#1
000006  f2410004          MOV      r0,#0x1004
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;77     	/* 配置SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;78     	GPIO_InitStructure.GPIO_Pin = Flash_PIN_SCK | Flash_PIN_MISO | Flash_PIN_MOSI;
00000e  20e0              MOVS     r0,#0xe0
000010  f8ad0004          STRH     r0,[sp,#4]
;;;79     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000014  2018              MOVS     r0,#0x18
000016  f88d0007          STRB     r0,[sp,#7]
;;;80     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  2003              MOVS     r0,#3
00001c  f88d0006          STRB     r0,[sp,#6]
;;;81     	GPIO_Init(Flash_GPIO, &GPIO_InitStructure);	
000020  a901              ADD      r1,sp,#4
000022  4823              LDR      r0,|L5.176|
000024  f7fffffe          BL       GPIO_Init
;;;82     	/* 配置片选口线为推挽输出模式 */
;;;83     	GPIO_InitStructure.GPIO_Pin = Flash_CS;
000028  2010              MOVS     r0,#0x10
00002a  f8ad0004          STRH     r0,[sp,#4]
;;;84     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00002e  f88d0007          STRB     r0,[sp,#7]
;;;85     	GPIO_Init(Flash_CS_GPIO, &GPIO_InitStructure);	
000032  a901              ADD      r1,sp,#4
000034  481e              LDR      r0,|L5.176|
000036  f7fffffe          BL       GPIO_Init
;;;86     	/* 片选置高，不选中 */
;;;87     	Flash_CS_HIGH();	
00003a  2110              MOVS     r1,#0x10
00003c  481c              LDR      r0,|L5.176|
00003e  f7fffffe          BL       GPIO_SetBits
;;;88     	/* 配置SPI硬件参数 */
;;;89     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000042  2000              MOVS     r0,#0
000044  f8ad0008          STRH     r0,[sp,#8]
;;;90     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
000048  f44f7082          MOV      r0,#0x104
00004c  f8ad000a          STRH     r0,[sp,#0xa]
;;;91     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000050  2000              MOVS     r0,#0
000052  f8ad000c          STRH     r0,[sp,#0xc]
;;;92     	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;93     	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;94     	*/
;;;95     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000056  2002              MOVS     r0,#2
000058  f8ad000e          STRH     r0,[sp,#0xe]
;;;96     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00005c  2001              MOVS     r0,#1
00005e  f8ad0010          STRH     r0,[sp,#0x10]
;;;97     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000062  0240              LSLS     r0,r0,#9
000064  f8ad0012          STRH     r0,[sp,#0x12]
;;;98     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;	/* 波特率预分频系数：4分频 */
000068  2008              MOVS     r0,#8
00006a  f8ad0014          STRH     r0,[sp,#0x14]
;;;99     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
00006e  2000              MOVS     r0,#0
000070  f8ad0016          STRH     r0,[sp,#0x16]
;;;100    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000074  2007              MOVS     r0,#7
000076  f8ad0018          STRH     r0,[sp,#0x18]
;;;101    	SPI_Init(SPI_FLASH, &SPI_InitStructure);
00007a  a902              ADD      r1,sp,#8
00007c  480d              LDR      r0,|L5.180|
00007e  f7fffffe          BL       SPI_Init
;;;102    	SPI_Cmd(SPI_FLASH, ENABLE);		/* 使能SPI  */
000082  2101              MOVS     r1,#1
000084  480b              LDR      r0,|L5.180|
000086  f7fffffe          BL       SPI_Cmd
;;;103    	Flash_CS_LOW();				/* 软件方式，使能串行Flash片选 */
00008a  2110              MOVS     r1,#0x10
00008c  4808              LDR      r0,|L5.176|
00008e  f7fffffe          BL       GPIO_ResetBits
;;;104    	Flash_SendByte(CMD_DISWR);		/* 发送禁止写入的命令,即使能软件写保护 */
000092  2004              MOVS     r0,#4
000094  f7fffffe          BL       Flash_SendByte
;;;105    	Flash_CS_HIGH();				/* 软件方式，禁能串行Flash片选 */
000098  2110              MOVS     r1,#0x10
00009a  4805              LDR      r0,|L5.176|
00009c  f7fffffe          BL       GPIO_SetBits
;;;106    	Flash_WaitForWriteEnd();		/* 等待串行Flash内部操作完成 */	
0000a0  f7fffffe          BL       Flash_WaitForWriteEnd
;;;107    	Flash_WriteStatus(0);			/* 解除所有BLOCK的写保护 */
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       Flash_WriteStatus
;;;108    }
0000aa  b007              ADD      sp,sp,#0x1c
0000ac  bd00              POP      {pc}
;;;109    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L5.176|
                          DCD      0x40010800
                  |L5.180|
                          DCD      0x40013000

                          AREA ||i.Flash_NeedErase||, CODE, READONLY, ALIGN=1

                  Flash_NeedErase PROC
;;;263    *****************************************************/ 
;;;264    static uint8_t Flash_NeedErase(uint8_t * _ucpOldBuf, uint8_t *_ucpNewBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;265    {
000002  4603              MOV      r3,r0
;;;266    	uint16_t i;
;;;267    	uint8_t ucOld;
;;;268    	/*
;;;269    	算法第1步：old 求反, new 不变
;;;270    	      old    new
;;;271    		  1101   0101
;;;272    	~     1111
;;;273    		= 0010   0101
;;;274    
;;;275    	算法第2步: old 求反的结果与 new 位与
;;;276    		  0010   old
;;;277    	&	  0101   new
;;;278    		 =0000
;;;279    
;;;280    	算法第3步: 结果为0,则表示无需擦除. 否则表示需要擦除
;;;281    	*/
;;;282    	for (i = 0; i < _usLen; i++)
000004  2400              MOVS     r4,#0
000006  e00b              B        |L6.32|
                  |L6.8|
;;;283    	{
;;;284    		ucOld = *_ucpOldBuf++;
000008  f8135b01          LDRB     r5,[r3],#1
;;;285    		ucOld = ~ucOld;
00000c  43e8              MVNS     r0,r5
00000e  b2c5              UXTB     r5,r0
;;;286    
;;;287    		/* 注意错误的写法: if (ucOld & (*_ucpNewBuf++) != 0) */
;;;288    		if ((ucOld & (*_ucpNewBuf++)) != 0)
000010  f8110b01          LDRB     r0,[r1],#1
000014  4028              ANDS     r0,r0,r5
000016  b108              CBZ      r0,|L6.28|
;;;289    		{
;;;290    			return 1;
000018  2001              MOVS     r0,#1
                  |L6.26|
;;;291    		}
;;;292    	}
;;;293    	return 0;
;;;294    }
00001a  bd70              POP      {r4-r6,pc}
                  |L6.28|
00001c  1c60              ADDS     r0,r4,#1              ;282
00001e  b284              UXTH     r4,r0                 ;282
                  |L6.32|
000020  4294              CMP      r4,r2                 ;282
000022  dbf1              BLT      |L6.8|
000024  2000              MOVS     r0,#0                 ;293
000026  e7f8              B        |L6.26|
;;;295    
                          ENDP


                          AREA ||i.Flash_PageWrite||, CODE, READONLY, ALIGN=2

                  Flash_PageWrite PROC
;;;152    ***********************************************************/  
;;;153    void Flash_PageWrite(uint8_t * _pBuf, uint32_t _uiWriteAddr, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;154    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;155    	uint32_t i;	
;;;156    	/* AAI指令要求传入的数据个数是偶数 */
;;;157    	if ((_usSize < 2) && (_usSize % 2))
00000a  2d02              CMP      r5,#2
00000c  da08              BGE      |L7.32|
00000e  4628              MOV      r0,r5
000010  eb0571d0          ADD      r1,r5,r0,LSR #31
000014  1049              ASRS     r1,r1,#1
000016  eba50141          SUB      r1,r5,r1,LSL #1
00001a  b109              CBZ      r1,|L7.32|
                  |L7.28|
;;;158    	{
;;;159    		return ;
;;;160    	}
;;;161    	Flash_WriteEnable();								/* 发送写使能命令 */	
;;;162    	/* 擦除扇区操作 */
;;;163    	Flash_CS_LOW();									/* 使能片选 */
;;;164    	Flash_SendByte(CMD_AAI);							/* 发送AAI命令(地址自动增加编程) */
;;;165    	Flash_SendByte((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;166    	Flash_SendByte((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;167    	Flash_SendByte(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */	
;;;168    	Flash_SendByte(*_pBuf++);							/* 发送第1个数据 */
;;;169    	Flash_SendByte(*_pBuf++);							/* 发送第2个数据 */
;;;170    	Flash_CS_HIGH();									/* 禁能片选 */	
;;;171    	Flash_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;172    	_usSize -= 2;									/* 计算剩余字节数 */
;;;173    	
;;;174    	for (i = 0; i < _usSize / 2; i++)
;;;175    	{
;;;176    		Flash_CS_LOW();								/* 使能片选 */
;;;177    		Flash_SendByte(CMD_AAI);						/* 发送AAI命令(地址自动增加编程) */
;;;178    		Flash_SendByte(*_pBuf++);					/* 发送数据 */
;;;179    		Flash_SendByte(*_pBuf++);					/* 发送数据 */
;;;180    		Flash_CS_HIGH();								/* 禁能片选 */
;;;181    		Flash_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
;;;182    	}
;;;183    	/* 进入写保护状态 */
;;;184    	Flash_CS_LOW();
;;;185    	Flash_SendByte(CMD_DISWR);							
;;;186    	Flash_CS_HIGH();
;;;187    	Flash_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;188    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L7.32|
000020  f7fffffe          BL       Flash_WriteEnable
000024  2110              MOVS     r1,#0x10              ;163
000026  4826              LDR      r0,|L7.192|
000028  f7fffffe          BL       GPIO_ResetBits
00002c  20ad              MOVS     r0,#0xad              ;164
00002e  f7fffffe          BL       Flash_SendByte
000032  f3c64007          UBFX     r0,r6,#16,#8          ;165
000036  f7fffffe          BL       Flash_SendByte
00003a  f3c62007          UBFX     r0,r6,#8,#8           ;166
00003e  f7fffffe          BL       Flash_SendByte
000042  b2f0              UXTB     r0,r6                 ;167
000044  f7fffffe          BL       Flash_SendByte
000048  f8140b01          LDRB     r0,[r4],#1            ;168
00004c  f7fffffe          BL       Flash_SendByte
000050  f8140b01          LDRB     r0,[r4],#1            ;169
000054  f7fffffe          BL       Flash_SendByte
000058  2110              MOVS     r1,#0x10              ;170
00005a  4819              LDR      r0,|L7.192|
00005c  f7fffffe          BL       GPIO_SetBits
000060  f7fffffe          BL       Flash_WaitForWriteEnd
000064  1ea8              SUBS     r0,r5,#2              ;172
000066  b285              UXTH     r5,r0                 ;172
000068  2700              MOVS     r7,#0                 ;174
00006a  e015              B        |L7.152|
                  |L7.108|
00006c  2110              MOVS     r1,#0x10              ;176
00006e  4814              LDR      r0,|L7.192|
000070  f7fffffe          BL       GPIO_ResetBits
000074  20ad              MOVS     r0,#0xad              ;177
000076  f7fffffe          BL       Flash_SendByte
00007a  f8140b01          LDRB     r0,[r4],#1            ;178
00007e  f7fffffe          BL       Flash_SendByte
000082  f8140b01          LDRB     r0,[r4],#1            ;179
000086  f7fffffe          BL       Flash_SendByte
00008a  2110              MOVS     r1,#0x10              ;180
00008c  480c              LDR      r0,|L7.192|
00008e  f7fffffe          BL       GPIO_SetBits
000092  f7fffffe          BL       Flash_WaitForWriteEnd
000096  1c7f              ADDS     r7,r7,#1              ;174
                  |L7.152|
000098  eb0571d5          ADD      r1,r5,r5,LSR #31      ;174
00009c  ebb70f61          CMP      r7,r1,ASR #1          ;174
0000a0  d3e4              BCC      |L7.108|
0000a2  2110              MOVS     r1,#0x10              ;184
0000a4  4806              LDR      r0,|L7.192|
0000a6  f7fffffe          BL       GPIO_ResetBits
0000aa  2004              MOVS     r0,#4                 ;185
0000ac  f7fffffe          BL       Flash_SendByte
0000b0  2110              MOVS     r1,#0x10              ;186
0000b2  4803              LDR      r0,|L7.192|
0000b4  f7fffffe          BL       GPIO_SetBits
0000b8  f7fffffe          BL       Flash_WaitForWriteEnd
0000bc  bf00              NOP      
0000be  e7ad              B        |L7.28|
;;;189    
                          ENDP

                  |L7.192|
                          DCD      0x40010800

                          AREA ||i.Flash_ReadBuffer||, CODE, READONLY, ALIGN=2

                  Flash_ReadBuffer PROC
;;;197    *************************************************/
;;;198    void Flash_ReadBuffer(uint8_t * _pBuf, uint32_t _uiReadAddr, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;199    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;200    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;201    	if ((_uiSize == 0) ||(_uiReadAddr + _uiSize) > Flash_TOTAL_SIZE)
000008  b11d              CBZ      r5,|L8.18|
00000a  1960              ADDS     r0,r4,r5
00000c  f5b01f00          CMP      r0,#0x200000
000010  d900              BLS      |L8.20|
                  |L8.18|
;;;202    	{
;;;203    		return;
;;;204    	}
;;;205    	/* 擦除扇区操作 */
;;;206    	Flash_CS_LOW();									/* 使能片选 */
;;;207    	Flash_SendByte(CMD_READ);							/* 发送读命令 */
;;;208    	Flash_SendByte((_uiReadAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;209    	Flash_SendByte((_uiReadAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;210    	Flash_SendByte(_uiReadAddr & 0xFF);				/* 发送扇区地址低8bit */	
;;;211    	while (_uiSize--)
;;;212    	{
;;;213    		*_pBuf++ = Flash_SendByte(DUMMY_BYTE);			/* 读一个字节并存储到pBuf，读完后指针自加1 */
;;;214    	}
;;;215    	Flash_CS_HIGH();									/* 禁能片选 */
;;;216    }
000012  bd70              POP      {r4-r6,pc}
                  |L8.20|
000014  2110              MOVS     r1,#0x10              ;206
000016  4810              LDR      r0,|L8.88|
000018  f7fffffe          BL       GPIO_ResetBits
00001c  2003              MOVS     r0,#3                 ;207
00001e  f7fffffe          BL       Flash_SendByte
000022  f3c44007          UBFX     r0,r4,#16,#8          ;208
000026  f7fffffe          BL       Flash_SendByte
00002a  f3c42007          UBFX     r0,r4,#8,#8           ;209
00002e  f7fffffe          BL       Flash_SendByte
000032  b2e0              UXTB     r0,r4                 ;210
000034  f7fffffe          BL       Flash_SendByte
000038  e004              B        |L8.68|
                  |L8.58|
00003a  20a5              MOVS     r0,#0xa5              ;213
00003c  f7fffffe          BL       Flash_SendByte
000040  f8060b01          STRB     r0,[r6],#1            ;213
                  |L8.68|
000044  0028              MOVS     r0,r5                 ;211
000046  f1a50501          SUB      r5,r5,#1              ;211
00004a  d1f6              BNE      |L8.58|
00004c  2110              MOVS     r1,#0x10              ;215
00004e  4802              LDR      r0,|L8.88|
000050  f7fffffe          BL       GPIO_SetBits
000054  bf00              NOP      
000056  e7dc              B        |L8.18|
;;;217    
                          ENDP

                  |L8.88|
                          DCD      0x40010800

                          AREA ||i.Flash_ReadID||, CODE, READONLY, ALIGN=2

                  Flash_ReadID PROC
;;;499    ***************************************************/  
;;;500    uint32_t Flash_ReadID(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;501    {
;;;502    	uint32_t uiID; 
;;;503    	uint8_t id1, id2, id3;	
;;;504    	Flash_WriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       Flash_WriteEnable
;;;505    	/* 擦除扇区操作 */
;;;506    	Flash_CS_LOW();									/* 使能片选 */
000008  2110              MOVS     r1,#0x10
00000a  480f              LDR      r0,|L9.72|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;507    	Flash_SendByte(CMD_RDID);							/* 发送读ID命令 */
000010  209f              MOVS     r0,#0x9f
000012  f7fffffe          BL       Flash_SendByte
;;;508    	id1 = Flash_SendByte(DUMMY_BYTE);					/* 读ID的第1个字节 */
000016  20a5              MOVS     r0,#0xa5
000018  f7fffffe          BL       Flash_SendByte
00001c  4605              MOV      r5,r0
;;;509    	id2 = Flash_SendByte(DUMMY_BYTE);					/* 读ID的第2个字节 */
00001e  20a5              MOVS     r0,#0xa5
000020  f7fffffe          BL       Flash_SendByte
000024  4606              MOV      r6,r0
;;;510    	id3 = Flash_SendByte(DUMMY_BYTE);					/* 读ID的第3个字节 */
000026  20a5              MOVS     r0,#0xa5
000028  f7fffffe          BL       Flash_SendByte
00002c  4607              MOV      r7,r0
;;;511    	Flash_CS_HIGH();									/* 禁能片选 */
00002e  2110              MOVS     r1,#0x10
000030  4805              LDR      r0,|L9.72|
000032  f7fffffe          BL       GPIO_SetBits
;;;512    	uiID = ((uint32_t)id1 << 16) | ((uint32_t)id2 << 8) | id3;
000036  0428              LSLS     r0,r5,#16
000038  ea402006          ORR      r0,r0,r6,LSL #8
00003c  ea400407          ORR      r4,r0,r7
;;;513    	return uiID;
000040  4620              MOV      r0,r4
;;;514    }		
000042  e8bd81f0          POP      {r4-r8,pc}
;;;515    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0x40010800

                          AREA ||i.Flash_SendByte||, CODE, READONLY, ALIGN=2

                  Flash_SendByte PROC
;;;521    ***************************************************/
;;;522    static uint8_t Flash_SendByte(uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524    	/* 等待上个数据未发送完毕 */
;;;525    	while (SPI_I2S_GetFlagStatus(SPI_FLASH, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L10.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L10.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L10.6|
;;;526    	/* 通过SPI硬件发送1个字节 */
;;;527    	SPI_I2S_SendData(SPI_FLASH, _ucValue);
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L10.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;528    	/* 等待接收一个字节任务完成 */
;;;529    	while (SPI_I2S_GetFlagStatus(SPI_FLASH, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L10.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L10.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L10.28|
;;;530    	/* 返回从SPI总线读到的数据 */
;;;531    	return SPI_I2S_ReceiveData(SPI_FLASH);
000028  4802              LDR      r0,|L10.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;532    }
000030  bd10              POP      {r4,pc}
;;;533    /****************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40013000

                          AREA ||i.Flash_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  Flash_WaitForWriteEnd PROC
;;;569    ****************************************************/  
;;;570    static void Flash_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;571    {
;;;572    	Flash_CS_LOW();									/* 使能片选 */
000002  2110              MOVS     r1,#0x10
000004  4809              LDR      r0,|L11.44|
000006  f7fffffe          BL       GPIO_ResetBits
;;;573    	Flash_SendByte(CMD_RDSR);							/* 发送命令， 读状态寄存器 */
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       Flash_SendByte
;;;574    	while((Flash_SendByte(DUMMY_BYTE) & WIP_FLAG) == SET);	/* 判断状态寄存器的忙标志位 */
000010  bf00              NOP      
                  |L11.18|
000012  20a5              MOVS     r0,#0xa5
000014  f7fffffe          BL       Flash_SendByte
000018  f0000001          AND      r0,r0,#1
00001c  2800              CMP      r0,#0
00001e  d1f8              BNE      |L11.18|
;;;575    	Flash_CS_HIGH();									/* 禁能片选 */ 	
000020  2110              MOVS     r1,#0x10
000022  4802              LDR      r0,|L11.44|
000024  f7fffffe          BL       GPIO_SetBits
;;;576    }
000028  bd10              POP      {r4,pc}
;;;577    /********** (C) COPYRIGHT DIY嵌入式开发工作室 *****END OF FILE****************/
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40010800

                          AREA ||i.Flash_WriteBuffer||, CODE, READONLY, ALIGN=1

                  Flash_WriteBuffer PROC
;;;396    ********************************************************/ 
;;;397    uint8_t Flash_WriteBuffer(uint8_t* _pBuf, uint32_t _uiWriteAddr, uint16_t _usWriteSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;398    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;399    	uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  46c1              MOV      r9,r8
000010  46c2              MOV      r10,r8
000012  2500              MOVS     r5,#0
000014  46ab              MOV      r11,r5
;;;400    	
;;;401    	Addr = _uiWriteAddr % Flash_PAGE_SIZE;
000016  f0060aff          AND      r10,r6,#0xff
;;;402    	count = Flash_PAGE_SIZE - Addr;
00001a  f1ca0000          RSB      r0,r10,#0
00001e  b2c5              UXTB     r5,r0
;;;403    	NumOfPage =  _usWriteSize / Flash_PAGE_SIZE;
000020  4620              MOV      r0,r4
000022  17e1              ASRS     r1,r4,#31
000024  eb045111          ADD      r1,r4,r1,LSR #20
000028  f3c13807          UBFX     r8,r1,#12,#8
;;;404    	NumOfSingle = _usWriteSize % Flash_PAGE_SIZE;
00002c  17e1              ASRS     r1,r4,#31
00002e  eb045111          ADD      r1,r4,r1,LSR #20
000032  1309              ASRS     r1,r1,#12
000034  eba43101          SUB      r1,r4,r1,LSL #12
000038  f00109ff          AND      r9,r1,#0xff
;;;405    	
;;;406    	if (Addr == 0) /* 起始地址是页面首地址  */
00003c  f1ba0f00          CMP      r10,#0
000040  d128              BNE      |L12.148|
;;;407    	{
;;;408    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
000042  f1b80f00          CMP      r8,#0
000046  d108              BNE      |L12.90|
;;;409    		{
;;;410    			if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
000048  4622              MOV      r2,r4
00004a  4631              MOV      r1,r6
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       Flash_AutoWritePage
000052  2800              CMP      r0,#0
000054  d17c              BNE      |L12.336|
                  |L12.86|
;;;411    			{
;;;412    				return 0;
;;;413    			}
;;;414    		}
;;;415    		else 	/* 数据长度大于等于页面大小 */
;;;416    		{
;;;417    			while (NumOfPage--)
;;;418    			{
;;;419    				if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, Flash_PAGE_SIZE) == 0)
;;;420    				{
;;;421    					return 0;
;;;422    				}				
;;;423    				_uiWriteAddr +=  Flash_PAGE_SIZE;
;;;424    				_pBuf += Flash_PAGE_SIZE;
;;;425    			}
;;;426    			if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;427    			{
;;;428    				return 0;
;;;429    			}				
;;;430    		}
;;;431    	}
;;;432    	else  /* 起始地址不是页面首地址  */
;;;433    	{
;;;434    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
;;;435    		{
;;;436    			if (NumOfSingle > count) /* (_usWriteSize + _uiWriteAddr) > SPI_FLASH_PAGESIZE */
;;;437    			{
;;;438    				temp = NumOfSingle - count;
;;;439    				
;;;440    				if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;441    				{
;;;442    					return 0;
;;;443    				}
;;;444    								
;;;445    				_uiWriteAddr +=  count;
;;;446    				_pBuf += count;
;;;447    			
;;;448    				if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, temp) == 0)
;;;449    				{
;;;450    					return 0;
;;;451    				}				
;;;452    			}
;;;453    			else
;;;454    			{
;;;455    				if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
;;;456    				{
;;;457    					return 0;
;;;458    				}
;;;459    			}
;;;460    		}
;;;461    		else	/* 数据长度大于等于页面大小 */
;;;462    		{
;;;463    			_usWriteSize -= count;
;;;464    			NumOfPage =  _usWriteSize / Flash_PAGE_SIZE;
;;;465    			NumOfSingle = _usWriteSize % Flash_PAGE_SIZE;		
;;;466    			if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;467    			{
;;;468    				return 0;
;;;469    			}				
;;;470    			_uiWriteAddr +=  count;
;;;471    			_pBuf += count;
;;;472    			
;;;473    			while (NumOfPage--)
;;;474    			{
;;;475    				if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, Flash_PAGE_SIZE) == 0)
;;;476    				{
;;;477    					return 0;
;;;478    				}				
;;;479    				_uiWriteAddr +=  Flash_PAGE_SIZE;
;;;480    				_pBuf += Flash_PAGE_SIZE;
;;;481    			}
;;;482    			
;;;483    			if (NumOfSingle != 0)
;;;484    			{
;;;485    				if (Flash_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;486    				{
;;;487    					return 0;
;;;488    				}				
;;;489    			}
;;;490    		}
;;;491    	}
;;;492    	return 1;	/* 成功 */
;;;493    }
000056  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.90|
00005a  e00c              B        |L12.118|
                  |L12.92|
00005c  f44f5280          MOV      r2,#0x1000            ;419
000060  4631              MOV      r1,r6                 ;419
000062  4638              MOV      r0,r7                 ;419
000064  f7fffffe          BL       Flash_AutoWritePage
000068  b908              CBNZ     r0,|L12.110|
00006a  2000              MOVS     r0,#0                 ;421
00006c  e7f3              B        |L12.86|
                  |L12.110|
00006e  f5065680          ADD      r6,r6,#0x1000         ;423
000072  f5075780          ADD      r7,r7,#0x1000         ;424
                  |L12.118|
000076  ea5f0008          MOVS     r0,r8                 ;417
00007a  f1a80101          SUB      r1,r8,#1              ;417
00007e  f00108ff          AND      r8,r1,#0xff           ;417
000082  d1eb              BNE      |L12.92|
000084  464a              MOV      r2,r9                 ;426
000086  4631              MOV      r1,r6                 ;426
000088  4638              MOV      r0,r7                 ;426
00008a  f7fffffe          BL       Flash_AutoWritePage
00008e  2800              CMP      r0,#0                 ;426
000090  d15e              BNE      |L12.336|
000092  e7e0              B        |L12.86|
                  |L12.148|
000094  f1b80f00          CMP      r8,#0                 ;434
000098  d11f              BNE      |L12.218|
00009a  45a9              CMP      r9,r5                 ;436
00009c  dd15              BLE      |L12.202|
00009e  eba90005          SUB      r0,r9,r5              ;438
0000a2  f0000bff          AND      r11,r0,#0xff          ;438
0000a6  462a              MOV      r2,r5                 ;440
0000a8  4631              MOV      r1,r6                 ;440
0000aa  4638              MOV      r0,r7                 ;440
0000ac  f7fffffe          BL       Flash_AutoWritePage
0000b0  b908              CBNZ     r0,|L12.182|
0000b2  2000              MOVS     r0,#0                 ;442
0000b4  e7cf              B        |L12.86|
                  |L12.182|
0000b6  442e              ADD      r6,r6,r5              ;445
0000b8  442f              ADD      r7,r7,r5              ;446
0000ba  465a              MOV      r2,r11                ;448
0000bc  4631              MOV      r1,r6                 ;448
0000be  4638              MOV      r0,r7                 ;448
0000c0  f7fffffe          BL       Flash_AutoWritePage
0000c4  2800              CMP      r0,#0                 ;448
0000c6  d143              BNE      |L12.336|
0000c8  e7c5              B        |L12.86|
                  |L12.202|
0000ca  4622              MOV      r2,r4                 ;455
0000cc  4631              MOV      r1,r6                 ;455
0000ce  4638              MOV      r0,r7                 ;455
0000d0  f7fffffe          BL       Flash_AutoWritePage
0000d4  bbd8              CBNZ     r0,|L12.334|
0000d6  2000              MOVS     r0,#0                 ;457
0000d8  e7bd              B        |L12.86|
                  |L12.218|
0000da  1b60              SUBS     r0,r4,r5              ;463
0000dc  b284              UXTH     r4,r0                 ;463
0000de  4620              MOV      r0,r4                 ;464
0000e0  17e1              ASRS     r1,r4,#31             ;464
0000e2  eb045111          ADD      r1,r4,r1,LSR #20      ;464
0000e6  ea4f3821          ASR      r8,r1,#12             ;464
0000ea  17e1              ASRS     r1,r4,#31             ;465
0000ec  eb045111          ADD      r1,r4,r1,LSR #20      ;465
0000f0  1309              ASRS     r1,r1,#12             ;465
0000f2  eba43101          SUB      r1,r4,r1,LSL #12      ;465
0000f6  f00109ff          AND      r9,r1,#0xff           ;465
0000fa  462a              MOV      r2,r5                 ;466
0000fc  4631              MOV      r1,r6                 ;466
0000fe  4638              MOV      r0,r7                 ;466
000100  f7fffffe          BL       Flash_AutoWritePage
000104  b908              CBNZ     r0,|L12.266|
000106  2000              MOVS     r0,#0                 ;468
000108  e7a5              B        |L12.86|
                  |L12.266|
00010a  442e              ADD      r6,r6,r5              ;470
00010c  442f              ADD      r7,r7,r5              ;471
00010e  e00c              B        |L12.298|
                  |L12.272|
000110  f44f5280          MOV      r2,#0x1000            ;475
000114  4631              MOV      r1,r6                 ;475
000116  4638              MOV      r0,r7                 ;475
000118  f7fffffe          BL       Flash_AutoWritePage
00011c  b908              CBNZ     r0,|L12.290|
00011e  2000              MOVS     r0,#0                 ;477
000120  e799              B        |L12.86|
                  |L12.290|
000122  f5065680          ADD      r6,r6,#0x1000         ;479
000126  f5075780          ADD      r7,r7,#0x1000         ;480
                  |L12.298|
00012a  ea5f0008          MOVS     r0,r8                 ;473
00012e  f1a80101          SUB      r1,r8,#1              ;473
000132  f00108ff          AND      r8,r1,#0xff           ;473
000136  d1eb              BNE      |L12.272|
000138  f1b90f00          CMP      r9,#0                 ;483
00013c  d008              BEQ      |L12.336|
00013e  464a              MOV      r2,r9                 ;485
000140  4631              MOV      r1,r6                 ;485
000142  4638              MOV      r0,r7                 ;485
000144  f7fffffe          BL       Flash_AutoWritePage
000148  b908              CBNZ     r0,|L12.334|
00014a  2000              MOVS     r0,#0                 ;487
00014c  e783              B        |L12.86|
                  |L12.334|
00014e  e7ff              B        |L12.336|
                  |L12.336|
000150  2001              MOVS     r0,#1                 ;492
000152  e780              B        |L12.86|
;;;494    /*************************************************
                          ENDP


                          AREA ||i.Flash_WriteEnable||, CODE, READONLY, ALIGN=2

                  Flash_WriteEnable PROC
;;;538    ******************************************/
;;;539    static void Flash_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;540    {
;;;541    	Flash_CS_LOW();									/* 使能片选 */
000002  2110              MOVS     r1,#0x10
000004  4805              LDR      r0,|L13.28|
000006  f7fffffe          BL       GPIO_ResetBits
;;;542    	Flash_SendByte(CMD_WREN);							/* 发送命令 */
00000a  2006              MOVS     r0,#6
00000c  f7fffffe          BL       Flash_SendByte
;;;543    	Flash_CS_HIGH();									/* 禁能片选 */  
000010  2110              MOVS     r1,#0x10
000012  4802              LDR      r0,|L13.28|
000014  f7fffffe          BL       GPIO_SetBits
;;;544    }
000018  bd10              POP      {r4,pc}
;;;545    /******************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40010800

                          AREA ||i.Flash_WriteStatus||, CODE, READONLY, ALIGN=2

                  Flash_WriteStatus PROC
;;;550    *******************************************************/  
;;;551    static void Flash_WriteStatus(uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;552    {
000002  4604              MOV      r4,r0
;;;553    	/* 第1步：先使能写状态寄存器 */
;;;554    	Flash_CS_LOW();									/* 使能片选 */
000004  2110              MOVS     r1,#0x10
000006  480c              LDR      r0,|L14.56|
000008  f7fffffe          BL       GPIO_ResetBits
;;;555    	Flash_SendByte(CMD_EWRSR);							/* 发送命令， 允许写状态寄存器 */
00000c  2050              MOVS     r0,#0x50
00000e  f7fffffe          BL       Flash_SendByte
;;;556    	Flash_CS_HIGH();									/* 禁能片选 */ 	
000012  2110              MOVS     r1,#0x10
000014  4808              LDR      r0,|L14.56|
000016  f7fffffe          BL       GPIO_SetBits
;;;557    	/* 第2步：再写状态寄存器 */
;;;558    	Flash_CS_LOW();									/* 使能片选 */
00001a  2110              MOVS     r1,#0x10
00001c  4806              LDR      r0,|L14.56|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;559    	Flash_SendByte(CMD_WRSR);							/* 发送命令， 写状态寄存器 */
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       Flash_SendByte
;;;560    	Flash_SendByte(_ucValue);							/* 发送数据：状态寄存器的值 */
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       Flash_SendByte
;;;561    	Flash_CS_HIGH();									/* 禁能片选 */ 	
00002e  2110              MOVS     r1,#0x10
000030  4801              LDR      r0,|L14.56|
000032  f7fffffe          BL       GPIO_SetBits
;;;562    }	
000036  bd10              POP      {r4,pc}
;;;563    
                          ENDP

                  |L14.56|
                          DCD      0x40010800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  s_spiBuf
                          %        4096

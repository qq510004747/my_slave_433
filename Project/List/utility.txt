; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\utility.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\utility.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\utility.crf ..\User\Utility.c]
                          THUMB

                          AREA ||i.BCDToChar||, CODE, READONLY, ALIGN=1

                  BCDToChar PROC
;;;451    */
;;;452    char BCDToChar(unsigned char c	)
000000  4601              MOV      r1,r0
;;;453    {
;;;454    	return (char)((c>>4)&0X0F)*10+(c&0x0F);
000002  f001000f          AND      r0,r1,#0xf
000006  090a              LSRS     r2,r1,#4
000008  eb020282          ADD      r2,r2,r2,LSL #2
00000c  eb000042          ADD      r0,r0,r2,LSL #1
000010  b2c0              UXTB     r0,r0
;;;455    }
000012  4770              BX       lr
;;;456    /**
                          ENDP


                          AREA ||i.BSP_InitDWT||, CODE, READONLY, ALIGN=2

                  BSP_InitDWT PROC
;;;107    ***********************************/
;;;108    void BSP_InitDWT(void)
000000  4807              LDR      r0,|L2.32|
;;;109    {
;;;110    	DEM_CR         |= (unsigned int)DEM_CR_TRCENA;   /* Enable Cortex-M4's DWT CYCCNT reg.  */
000002  6800              LDR      r0,[r0,#0]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4905              LDR      r1,|L2.32|
00000a  6008              STR      r0,[r1,#0]
;;;111    	DWT_CYCCNT      = (unsigned int)0u;
00000c  2000              MOVS     r0,#0
00000e  4905              LDR      r1,|L2.36|
000010  6048              STR      r0,[r1,#4]
;;;112    	DWT_CR         |= (unsigned int)DWT_CR_CYCCNTENA;
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0400001          ORR      r0,r0,#1
00001a  6008              STR      r0,[r1,#0]
;;;113    }
00001c  4770              BX       lr
;;;114    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0xe000edfc
                  |L2.36|
                          DCD      0xe0001000

                          AREA ||i.C2D||, CODE, READONLY, ALIGN=1

                  ||C2D|| PROC
;;;410    */
;;;411    char C2D(unsigned char c	)
000000  4601              MOV      r1,r0
;;;412    {
;;;413    	if (c >= '0' && c <= '9')
000002  2930              CMP      r1,#0x30
000004  db05              BLT      |L3.18|
000006  2939              CMP      r1,#0x39
000008  dc03              BGT      |L3.18|
;;;414    		return c - '0';
00000a  f1a10030          SUB      r0,r1,#0x30
00000e  b2c0              UXTB     r0,r0
                  |L3.16|
;;;415    	if (c >= 'a' && c <= 'f')
;;;416    		return 10 + c -'a';
;;;417    	if (c >= 'A' && c <= 'F')
;;;418    		return 10 + c -'A';
;;;419    
;;;420    	return (char)c;
;;;421    }
000010  4770              BX       lr
                  |L3.18|
000012  2961              CMP      r1,#0x61              ;415
000014  db05              BLT      |L3.34|
000016  2966              CMP      r1,#0x66              ;415
000018  dc03              BGT      |L3.34|
00001a  f1a10057          SUB      r0,r1,#0x57           ;416
00001e  b2c0              UXTB     r0,r0                 ;416
000020  e7f6              B        |L3.16|
                  |L3.34|
000022  2941              CMP      r1,#0x41              ;417
000024  db05              BLT      |L3.50|
000026  2946              CMP      r1,#0x46              ;417
000028  dc03              BGT      |L3.50|
00002a  f1a10037          SUB      r0,r1,#0x37           ;418
00002e  b2c0              UXTB     r0,r0                 ;418
000030  e7ee              B        |L3.16|
                  |L3.50|
000032  4608              MOV      r0,r1                 ;420
000034  e7ec              B        |L3.16|
;;;422    ///**
                          ENDP


                          AREA ||i.Caculate_CRC8_Byte||, CODE, READONLY, ALIGN=1

                  Caculate_CRC8_Byte PROC
;;;338    *******************************************************************************/
;;;339    static uint8_t Caculate_CRC8_Byte(uint8_t abyte)
000000  4601              MOV      r1,r0
;;;340    {
;;;341       uint8_t i,crc_1byte;
;;;342    
;;;343    	crc_1byte=0;                //设定crc_1byte初值为0
000002  2000              MOVS     r0,#0
;;;344    	for(i = 0; i < 8; i++)
000004  2200              MOVS     r2,#0
000006  e00e              B        |L4.38|
                  |L4.8|
;;;345    	{
;;;346    		if(((crc_1byte^abyte)&0x01))
000008  ea800301          EOR      r3,r0,r1
00000c  f0030301          AND      r3,r3,#1
000010  b12b              CBZ      r3,|L4.30|
;;;347    		{
;;;348    			crc_1byte^=0x18;
000012  f0800018          EOR      r0,r0,#0x18
;;;349    			crc_1byte>>=1;
000016  1040              ASRS     r0,r0,#1
;;;350    			crc_1byte|=0x80;
000018  f0400080          ORR      r0,r0,#0x80
00001c  e000              B        |L4.32|
                  |L4.30|
;;;351    		}
;;;352    		else
;;;353    		{
;;;354    			crc_1byte>>=1;
00001e  1040              ASRS     r0,r0,#1
                  |L4.32|
;;;355    		}
;;;356    		abyte>>=1;
000020  1049              ASRS     r1,r1,#1
000022  1c53              ADDS     r3,r2,#1              ;344
000024  b2da              UXTB     r2,r3                 ;344
                  |L4.38|
000026  2a08              CMP      r2,#8                 ;344
000028  dbee              BLT      |L4.8|
;;;357    	}
;;;358    	return crc_1byte;
;;;359    }
00002a  4770              BX       lr
;;;360    
                          ENDP


                          AREA ||i.CharToBCD||, CODE, READONLY, ALIGN=1

                  CharToBCD PROC
;;;442    */
;;;443    char CharToBCD(unsigned char c	)
000000  4601              MOV      r1,r0
;;;444    {
;;;445    	return (char)((c/10<<4)+(c%10));
000002  200a              MOVS     r0,#0xa
000004  fb91f2f0          SDIV     r2,r1,r0
000008  fb001012          MLS      r0,r0,r2,r1
00000c  220a              MOVS     r2,#0xa
00000e  fb91f2f2          SDIV     r2,r1,r2
000012  eb001002          ADD      r0,r0,r2,LSL #4
000016  b2c0              UXTB     r0,r0
;;;446    }
000018  4770              BX       lr
;;;447    /**
                          ENDP


                          AREA ||i.Delay_Init||, CODE, READONLY, ALIGN=2

                  Delay_Init PROC
;;;120    
;;;121    void Delay_Init(u8 SYSCLK)
000000  b510              PUSH     {r4,lr}
;;;122    {
000002  4604              MOV      r4,r0
;;;123    	fac_ms = fac_ms;
000004  480d              LDR      r0,|L6.60|
000006  8800              LDRH     r0,[r0,#0]  ; fac_ms
000008  490c              LDR      r1,|L6.60|
00000a  8008              STRH     r0,[r1,#0]
;;;124     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);
00000c  f06f0004          MVN      r0,#4
000010  f7fffffe          BL       SysTick_CLKSourceConfig
;;;125    	fac_us=SYSCLK/8;		//不论是否使用ucos,fac_us都需要使用
000014  17e1              ASRS     r1,r4,#31
000016  eb047151          ADD      r1,r4,r1,LSR #29
00001a  f3c101c7          UBFX     r1,r1,#3,#8
00001e  4a08              LDR      r2,|L6.64|
000020  7011              STRB     r1,[r2,#0]
;;;126    	fac_ms=(u16)fac_us*1000;//非ucos下,代表每个ms需要的systick时钟数   
000022  4610              MOV      r0,r2
000024  7800              LDRB     r0,[r0,#0]  ; fac_us
000026  eb000140          ADD      r1,r0,r0,LSL #1
00002a  ebc110c0          RSB      r0,r1,r0,LSL #7
00002e  f64f71ff          MOV      r1,#0xffff
000032  ea0100c0          AND      r0,r1,r0,LSL #3
000036  4901              LDR      r1,|L6.60|
000038  8008              STRH     r0,[r1,#0]
;;;127    }
00003a  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  |L6.60|
                          DCD      fac_ms
                  |L6.64|
                          DCD      fac_us

                          AREA ||i.Delay_ms||, CODE, READONLY, ALIGN=1

                  Delay_ms PROC
;;;184    //nms:0~65535
;;;185    void Delay_ms(u16 nms)
000000  b510              PUSH     {r4,lr}
;;;186    {	 	 
000002  4604              MOV      r4,r0
;;;187    	vTaskDelay(nms);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       vTaskDelay
;;;188    } 
00000a  bd10              POP      {r4,pc}
;;;189    
                          ENDP


                          AREA ||i.Delay_us||, CODE, READONLY, ALIGN=2

                  Delay_us PROC
;;;148    //注意:nus的值,不要大于798915us
;;;149    void Delay_us(u32 nus)
000000  4601              MOV      r1,r0
;;;150    {		
;;;151    	u32 temp;	    	 
;;;152    	SysTick->LOAD=nus*fac_us; //时间加载	  		 
000002  4a11              LDR      r2,|L8.72|
000004  7812              LDRB     r2,[r2,#0]  ; fac_us
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;153    	SysTick->VAL=0x00;        //清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;154    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;155    	do
00001c  bf00              NOP      
                  |L8.30|
;;;156    	{
;;;157    		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;158    	}
;;;159    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L8.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L8.30|
                  |L8.50|
;;;160    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;161    	SysTick->VAL =0X00;       //清空计数器	 
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;162    }
000046  4770              BX       lr
;;;163    //延时nms
                          ENDP

                  |L8.72|
                          DCD      fac_us

                          AREA ||i.Get_ChipID||, CODE, READONLY, ALIGN=2

                  Get_ChipID PROC
;;;220    */
;;;221    void Get_ChipID(void)
000000  4806              LDR      r0,|L9.28|
;;;222    {
;;;223    #if 1    
;;;224         //地址从小到大,先放低字节，再放高字节：小端模式
;;;225         //地址从小到大,先放高字节，再放低字节：大端模式
;;;226     ChipUniqueID[2] = *(__IO u32*)(0X1FFFF7E8);  // 低字节
000002  6800              LDR      r0,[r0,#0]
000004  4906              LDR      r1,|L9.32|
000006  6088              STR      r0,[r1,#8]  ; ChipUniqueID
;;;227     ChipUniqueID[1] = *(__IO u32 *)(0X1FFFF7EC); // 
000008  4804              LDR      r0,|L9.28|
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
00000e  6048              STR      r0,[r1,#4]  ; ChipUniqueID
;;;228     ChipUniqueID[0] = *(__IO u32 *)(0X1FFFF7F0); // 高字节
000010  4802              LDR      r0,|L9.28|
000012  3008              ADDS     r0,r0,#8
000014  6800              LDR      r0,[r0,#0]
000016  6008              STR      r0,[r1,#0]  ; ChipUniqueID
;;;229    // printf("######## 芯片的唯一ID为: X-X-X  rn",ChipUniqueID[0],ChipUniqueID[1],ChipUniqueID[2]);
;;;230              //此条语句输出32位
;;;231    #else   //调整了大小端模式，与ISP下载软件的一致
;;;232        u8 temp[12];   
;;;233        u32 temp0,temp1,temp2;
;;;234        temp0=*(__IO u32*)(0x1FFFF7E8);    //产品唯一身份标识寄存器（96位）
;;;235        temp1=*(__IO u32*)(0x1FFFF7EC);
;;;236        temp2=*(__IO u32*)(0x1FFFF7F0);
;;;237        temp[0] = (u8)(temp0 & 0x000000FF);
;;;238        temp[1] = (u8)((temp0 & 0x0000FF00)>>8);
;;;239        temp[2] = (u8)((temp0 & 0x00FF0000)>>16);
;;;240        temp[3] = (u8)((temp0 & 0xFF000000)>>24);
;;;241        temp[4] = (u8)(temp1 & 0x000000FF);
;;;242        temp[5] = (u8)((temp1 & 0x0000FF00)>>8);
;;;243        temp[6] = (u8)((temp1 & 0x00FF0000)>>16);
;;;244        temp[7] = (u8)((temp1 & 0xFF000000)>>24);
;;;245        temp[8] = (u8)(temp2 & 0x000000FF);
;;;246        temp[9] = (u8)((temp2 & 0x0000FF00)>>8);
;;;247        temp[10] = (u8)((temp2 & 0x00FF0000)>>16);
;;;248        temp[11] = (u8)((temp2 & 0xFF000000)>>24);
;;;249    //    printf("######## STM32芯片ID为: %.2X%.2X%.2X%.2X-%.2X%.2X%.2X%.2X-%.2X%.2X%.2X%.2X rn",
;;;250    //  temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6],temp[7],temp[8],temp[9],temp[10],temp [11]); //串口打印出芯片ID
;;;251    #endif
;;;252    }
000018  4770              BX       lr
;;;253    /*
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x1ffff7e8
                  |L9.32|
                          DCD      ChipUniqueID

                          AREA ||i.Get_ChipInfo||, CODE, READONLY, ALIGN=2

                  Get_ChipInfo PROC
;;;259    */
;;;260    void Get_ChipInfo(void)
000000  4808              LDR      r0,|L10.36|
;;;261    {
;;;262       ChipUniqueID[0] = *(__IO u32 *)(0X1FFF7A10); // 高字节
000002  6800              LDR      r0,[r0,#0]
000004  4908              LDR      r1,|L10.40|
000006  6008              STR      r0,[r1,#0]  ; ChipUniqueID
;;;263       ChipUniqueID[1] = *(__IO u32 *)(0X1FFF7A14); //
000008  4806              LDR      r0,|L10.36|
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
00000e  6048              STR      r0,[r1,#4]  ; ChipUniqueID
;;;264       ChipUniqueID[2] = *(__IO u32 *)(0X1FFF7A18); // 低字节
000010  4804              LDR      r0,|L10.36|
000012  3008              ADDS     r0,r0,#8
000014  6800              LDR      r0,[r0,#0]
000016  6088              STR      r0,[r1,#8]  ; ChipUniqueID
;;;265       STM32_FLASH_SIZE= *(u16*)(0x1FFFF7E0);    //闪存容量寄存器  
000018  4804              LDR      r0,|L10.44|
00001a  8800              LDRH     r0,[r0,#0]
00001c  4904              LDR      r1,|L10.48|
00001e  8008              STRH     r0,[r1,#0]
;;;266    //   printf("rn########### 芯片的唯一ID为: %X-%X-%X n",
;;;267    //           ChipUniqueID[0],ChipUniqueID[1],ChipUniqueID[2]);  
;;;268    //   printf("rn########### 芯片flash的容量为: %dK n", STM32_FLASH_SIZE);
;;;269    //   printf("rn########### 烧录日期: "__DATE__" - "__TIME__"n");
;;;270          //输出使用固件库版本号 
;;;271    }
000020  4770              BX       lr
;;;272    
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      0x1fff7a10
                  |L10.40|
                          DCD      ChipUniqueID
                  |L10.44|
                          DCD      0x1ffff7e0
                  |L10.48|
                          DCD      STM32_FLASH_SIZE

                          AREA ||i.Soft_delay_ms||, CODE, READONLY, ALIGN=1

                  Soft_delay_ms PROC
;;;206    //软件延时函数，ms级别
;;;207    void Soft_delay_ms(u16 time)
000000  b510              PUSH     {r4,lr}
;;;208    {    
000002  4604              MOV      r4,r0
;;;209    	vTaskDelay(time);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       vTaskDelay
;;;210    }
00000a  bd10              POP      {r4,pc}
;;;211    
                          ENDP


                          AREA ||i.Soft_delay_us||, CODE, READONLY, ALIGN=1

                  Soft_delay_us PROC
;;;191    //软件延时函数，us级别
;;;192    void Soft_delay_us(u16 time)
000000  e009              B        |L12.22|
                  |L12.2|
;;;193    {    
;;;194       u32 i;  
;;;195       while(time--)
;;;196       {
;;;197          i=8;  //自己定义  调试时间：20141116
000002  2108              MOVS     r1,#8
;;;198          while(i--){};
000004  bf00              NOP      
                  |L12.6|
000006  1e0a              SUBS     r2,r1,#0
000008  f1a10101          SUB      r1,r1,#1
00000c  d1fb              BNE      |L12.6|
;;;199            __nop();
00000e  bf00              NOP      
;;;200            __nop();
000010  bf00              NOP      
;;;201            __nop();
000012  bf00              NOP      
;;;202            __nop();
000014  bf00              NOP      
                  |L12.22|
000016  1e02              SUBS     r2,r0,#0              ;195
000018  f1a00301          SUB      r3,r0,#1              ;195
00001c  b298              UXTH     r0,r3                 ;195
00001e  d1f0              BNE      |L12.2|
;;;203       }
;;;204    }
000020  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||i.StrCmp||, CODE, READONLY, ALIGN=1

                  StrCmp PROC
;;;578    //两个数组比较
;;;579    uint8_t StrCmp(uint8_t *str1,uint8_t *str2,uint16_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;580    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;581        for(uint16_t i=0;i<len;i++)
000006  2100              MOVS     r1,#0
000008  e007              B        |L13.26|
                  |L13.10|
;;;582    	{
;;;583    	   if(*(str1+i) == *(str2+i));
00000a  5c58              LDRB     r0,[r3,r1]
00000c  5c65              LDRB     r5,[r4,r1]
00000e  42a8              CMP      r0,r5
000010  d001              BEQ      |L13.22|
;;;584    	   else return FALSE;
000012  2000              MOVS     r0,#0
                  |L13.20|
;;;585    	}
;;;586    	return TRUE;
;;;587    }
000014  bd30              POP      {r4,r5,pc}
                  |L13.22|
000016  1c48              ADDS     r0,r1,#1              ;581
000018  b281              UXTH     r1,r0                 ;581
                  |L13.26|
00001a  4291              CMP      r1,r2                 ;581
00001c  dbf5              BLT      |L13.10|
00001e  2001              MOVS     r0,#1                 ;586
000020  e7f8              B        |L13.20|
;;;588    
                          ENDP


                          AREA ||i.XORValid||, CODE, READONLY, ALIGN=1

                  XORValid PROC
;;;566    //异或校验
;;;567    uint8_t XORValid(uint8_t *buffer,uint16_t Len)
000000  b510              PUSH     {r4,lr}
;;;568    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;569        uint8_t checksum = 0;
000006  2000              MOVS     r0,#0
;;;570    	uint8_t i;
;;;571        for (i = 0;  i<Len;  i++)
000008  2100              MOVS     r1,#0
00000a  e003              B        |L14.20|
                  |L14.12|
;;;572        {
;;;573            checksum = checksum ^ buffer[i]; //进行异或交验取值
00000c  5c54              LDRB     r4,[r2,r1]
00000e  4060              EORS     r0,r0,r4
000010  1c4c              ADDS     r4,r1,#1              ;571
000012  b2e1              UXTB     r1,r4                 ;571
                  |L14.20|
000014  4299              CMP      r1,r3                 ;571
000016  dbf9              BLT      |L14.12|
;;;574    	}
;;;575    	return(checksum);
;;;576    }
000018  bd10              POP      {r4,pc}
;;;577    
                          ENDP


                          AREA ||i.atoi16||, CODE, READONLY, ALIGN=1

                  atoi16 PROC
;;;479    */
;;;480    uint16_t atoi16(char* str,uint16_t base	)
000000  b530              PUSH     {r4,r5,lr}
;;;481    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;482      unsigned int num = 0;
000006  2400              MOVS     r4,#0
;;;483      while (*str !=0)
000008  e005              B        |L15.22|
                  |L15.10|
;;;484              num = num * base + C2D(*str++);
00000a  f8120b01          LDRB     r0,[r2],#1
00000e  f7fffffe          BL       ||C2D||
000012  fb040403          MLA      r4,r4,r3,r0
                  |L15.22|
000016  7810              LDRB     r0,[r2,#0]            ;483
000018  2800              CMP      r0,#0                 ;483
00001a  d1f6              BNE      |L15.10|
;;;485      return num;
00001c  b2a0              UXTH     r0,r4
;;;486    }
00001e  bd30              POP      {r4,r5,pc}
;;;487    
                          ENDP


                          AREA ||i.checkCRC16||, CODE, READONLY, ALIGN=1

                  checkCRC16 PROC
;;;301    *******************************************************************************/
;;;302    uint8_t checkCRC16(uint8_t *msg, const uint16_t msg_length, uint8_t overturn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;303    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;304        uint16_t  crc_calc;
;;;305        uint16_t crc_received;
;;;306    
;;;307        if(msg_length < 3)
00000a  2c03              CMP      r4,#3
00000c  da02              BGE      |L16.20|
;;;308        {
;;;309            return 1;
00000e  2001              MOVS     r0,#1
                  |L16.16|
;;;310        }
;;;311    
;;;312        crc_calc = getCRC16(msg, msg_length - 2);
;;;313        if(overturn)
;;;314        {
;;;315            crc_received = (msg[msg_length - 1] << 8) | msg[msg_length - 2]; //接受数据时,先收到低字节,再是高字节.
;;;316        }else
;;;317        {
;;;318            crc_received = (msg[msg_length - 2] << 8) | msg[msg_length - 1];
;;;319        }
;;;320    
;;;321        /* Check CRC of msg */
;;;322        if (crc_calc == crc_received)
;;;323        {
;;;324            return 1;
;;;325        }
;;;326        else
;;;327        {
;;;328            return 0;
;;;329        }
;;;330    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L16.20|
000014  1ea0              SUBS     r0,r4,#2              ;312
000016  b281              UXTH     r1,r0                 ;312
000018  4628              MOV      r0,r5                 ;312
00001a  f7fffffe          BL       getCRC16
00001e  4606              MOV      r6,r0                 ;312
000020  f1b80f00          CMP      r8,#0                 ;313
000024  d006              BEQ      |L16.52|
000026  1ea0              SUBS     r0,r4,#2              ;315
000028  5c29              LDRB     r1,[r5,r0]            ;315
00002a  1e60              SUBS     r0,r4,#1              ;315
00002c  5c28              LDRB     r0,[r5,r0]            ;315
00002e  ea412700          ORR      r7,r1,r0,LSL #8       ;315
000032  e005              B        |L16.64|
                  |L16.52|
000034  1e60              SUBS     r0,r4,#1              ;318
000036  5c29              LDRB     r1,[r5,r0]            ;318
000038  1ea0              SUBS     r0,r4,#2              ;318
00003a  5c28              LDRB     r0,[r5,r0]            ;318
00003c  ea412700          ORR      r7,r1,r0,LSL #8       ;318
                  |L16.64|
000040  42be              CMP      r6,r7                 ;322
000042  d101              BNE      |L16.72|
000044  2001              MOVS     r0,#1                 ;324
000046  e7e3              B        |L16.16|
                  |L16.72|
000048  2000              MOVS     r0,#0                 ;328
00004a  e7e1              B        |L16.16|
;;;331    
                          ENDP


                          AREA ||i.checkCRC8||, CODE, READONLY, ALIGN=1

                  checkCRC8 PROC
;;;387    *******************************************************************************/
;;;388    uint8_t checkCRC8(uint8_t *pbuf,uint8_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;389    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;390        uint8_t crc=0,i;
000008  2600              MOVS     r6,#0
;;;391    
;;;392        for(i=0;i<len;i++)
00000a  2700              MOVS     r7,#0
00000c  e008              B        |L17.32|
                  |L17.14|
;;;393        {
;;;394            crc = Caculate_CRC8_Byte(crc^*pbuf++);
00000e  f8141b01          LDRB     r1,[r4],#1
000012  ea810006          EOR      r0,r1,r6
000016  f7fffffe          BL       Caculate_CRC8_Byte
00001a  4606              MOV      r6,r0
00001c  1c78              ADDS     r0,r7,#1              ;392
00001e  b2c7              UXTB     r7,r0                 ;392
                  |L17.32|
000020  42af              CMP      r7,r5                 ;392
000022  dbf4              BLT      |L17.14|
;;;395        }
;;;396        if(crc == 0)
000024  b916              CBNZ     r6,|L17.44|
;;;397        {
;;;398            return 1;
000026  2001              MOVS     r0,#1
                  |L17.40|
;;;399        }else 
;;;400        {   
;;;401            return 0;
;;;402        }
;;;403    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L17.44|
00002c  2000              MOVS     r0,#0                 ;401
00002e  e7fb              B        |L17.40|
;;;404    
                          ENDP


                          AREA ||i.getAskForIdPeriod||, CODE, READONLY, ALIGN=1

                  getAskForIdPeriod PROC
;;;645      */
;;;646    uint8_t getAskForIdPeriod(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;647    {
;;;648    	uint16_t value;
;;;649    	uint32_t mac[3];
;;;650    	
;;;651    	if (getCpuId(&mac[0], &mac[1], &mac[2])) {
000002  aa02              ADD      r2,sp,#8
000004  a901              ADD      r1,sp,#4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       getCpuId
00000c  b170              CBZ      r0,|L18.44|
;;;652    		value = (crc16((uint8_t *)mac, sizeof(mac)) & (0x001F));
00000e  210c              MOVS     r1,#0xc
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       crc16
000016  f000041f          AND      r4,r0,#0x1f
;;;653    		
;;;654    		if (value == 0) {
00001a  b90c              CBNZ     r4,|L18.32|
;;;655    			value = 100;
00001c  2464              MOVS     r4,#0x64
00001e  e007              B        |L18.48|
                  |L18.32|
;;;656    			
;;;657    		} else {
;;;658    			value = value*25;
000020  eb0400c4          ADD      r0,r4,r4,LSL #3
000024  eb001004          ADD      r0,r0,r4,LSL #4
000028  b284              UXTH     r4,r0
00002a  e001              B        |L18.48|
                  |L18.44|
;;;659    		} 			
;;;660    		
;;;661    	} else {
;;;662    		
;;;663    		value = 500;
00002c  f44f74fa          MOV      r4,#0x1f4
                  |L18.48|
;;;664    	}
;;;665    	
;;;666    	return value;
000030  b2e0              UXTB     r0,r4
;;;667    }
000032  bd3e              POP      {r1-r5,pc}
;;;668    
                          ENDP


                          AREA ||i.getCRC16||, CODE, READONLY, ALIGN=2

                  getCRC16 PROC
;;;274    //返回的CRC校验结果,高低位未互换
;;;275    uint16_t getCRC16(uint8_t *buffer, uint16_t buffer_length)
000000  b570              PUSH     {r4-r6,lr}
;;;276    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;277        uint8_t crc_hi = 0xFF; /* high CRC byte initialized */
000006  25ff              MOVS     r5,#0xff
;;;278        uint8_t crc_lo = 0xFF; /* low CRC byte initialized */
000008  23ff              MOVS     r3,#0xff
;;;279        unsigned int i; /* will index into CRC lookup */
;;;280    
;;;281        /* pass through message buffer */
;;;282        while (buffer_length--)
00000a  e009              B        |L19.32|
                  |L19.12|
;;;283        {
;;;284            i = crc_hi ^ *buffer++; /* calculate the CRC  */
00000c  f8120b01          LDRB     r0,[r2],#1
000010  ea800105          EOR      r1,r0,r5
;;;285            crc_hi = crc_lo ^ table_crc_hi[i];
000014  4806              LDR      r0,|L19.48|
000016  5c40              LDRB     r0,[r0,r1]
000018  ea800503          EOR      r5,r0,r3
;;;286            crc_lo = table_crc_lo[i];
00001c  4805              LDR      r0,|L19.52|
00001e  5c43              LDRB     r3,[r0,r1]
                  |L19.32|
000020  1e20              SUBS     r0,r4,#0              ;282
000022  f1a40601          SUB      r6,r4,#1              ;282
000026  b2b4              UXTH     r4,r6                 ;282
000028  d1f0              BNE      |L19.12|
;;;287        }
;;;288        return (crc_hi << 8 | crc_lo);
00002a  ea432005          ORR      r0,r3,r5,LSL #8
;;;289    }
00002e  bd70              POP      {r4-r6,pc}
;;;290    
                          ENDP

                  |L19.48|
                          DCD      table_crc_hi
                  |L19.52|
                          DCD      table_crc_lo

                          AREA ||i.getCRC8||, CODE, READONLY, ALIGN=1

                  getCRC8 PROC
;;;368    *******************************************************************************/
;;;369    uint8_t getCRC8(uint8_t *pbuf,uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;371    	uint8_t crccheck=0;
000006  2600              MOVS     r6,#0
;;;372    
;;;373        while(len--) 
000008  e006              B        |L20.24|
                  |L20.10|
;;;374        {
;;;375            crccheck = Caculate_CRC8_Byte(crccheck^*pbuf++);
00000a  f8141b01          LDRB     r1,[r4],#1
00000e  ea810006          EOR      r0,r1,r6
000012  f7fffffe          BL       Caculate_CRC8_Byte
000016  4606              MOV      r6,r0
                  |L20.24|
000018  1e28              SUBS     r0,r5,#0              ;373
00001a  f1a50101          SUB      r1,r5,#1              ;373
00001e  b2cd              UXTB     r5,r1                 ;373
000020  d1f3              BNE      |L20.10|
;;;376        }	
;;;377    	return crccheck;
000022  4630              MOV      r0,r6
;;;378    }
000024  bd70              POP      {r4-r6,pc}
;;;379    
                          ENDP


                          AREA ||i.getCpuId||, CODE, READONLY, ALIGN=2

                  getCpuId PROC
;;;598    
;;;599    bool getCpuId(uint32_t *mac_0, uint32_t *mac_1, uint32_t *mac_2)
000000  4603              MOV      r3,r0
;;;600    {
;;;601    	*mac_0 = *(uint32_t*)(0x1FFFF7E8);
000002  480a              LDR      r0,|L21.44|
000004  6800              LDR      r0,[r0,#0]
000006  6018              STR      r0,[r3,#0]
;;;602    	*mac_1 = *(uint32_t*)(0x1FFFF7EC);
000008  4808              LDR      r0,|L21.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
00000e  6008              STR      r0,[r1,#0]
;;;603    	*mac_2 = *(uint32_t*)(0x1FFFF7F0);
000010  4806              LDR      r0,|L21.44|
000012  3008              ADDS     r0,r0,#8
000014  6800              LDR      r0,[r0,#0]
000016  6010              STR      r0,[r2,#0]
;;;604    	
;;;605    	if ((*mac_0 != 0) || (*mac_1 != 0) || (*mac_2 != 0)) {
000018  6818              LDR      r0,[r3,#0]
00001a  b918              CBNZ     r0,|L21.36|
00001c  6808              LDR      r0,[r1,#0]
00001e  b908              CBNZ     r0,|L21.36|
000020  6810              LDR      r0,[r2,#0]
000022  b108              CBZ      r0,|L21.40|
                  |L21.36|
;;;606    		return true;
000024  2001              MOVS     r0,#1
                  |L21.38|
;;;607    		
;;;608    	} else {
;;;609    		return false;
;;;610    	}
;;;611    }
000026  4770              BX       lr
                  |L21.40|
000028  2000              MOVS     r0,#0                 ;609
00002a  e7fc              B        |L21.38|
;;;612    
                          ENDP

                  |L21.44|
                          DCD      0x1ffff7e8

                          AREA ||i.getDevMac||, CODE, READONLY, ALIGN=1

                  getDevMac PROC
;;;619      */
;;;620    bool getDevMac(uint8_t *mac0, uint8_t *mac1, uint8_t *mac2, uint8_t *mac3, uint8_t *mac4, uint8_t *mac5)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;621    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;622    	uint32_t mac_0;
;;;623    	uint32_t mac_1;
;;;624    	uint32_t mac_2;
;;;625    
;;;626    	if (getCpuId(&mac_0, &mac_1, &mac_2)) {
000010  466a              MOV      r2,sp
000012  a901              ADD      r1,sp,#4
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       getCpuId
00001a  b1a0              CBZ      r0,|L22.70|
;;;627    		*mac0	= 0x4c;
00001c  204c              MOVS     r0,#0x4c
00001e  7020              STRB     r0,[r4,#0]
;;;628    		*mac1	= (uint8_t)(mac_0 >> 16);
000020  9802              LDR      r0,[sp,#8]
000022  0c00              LSRS     r0,r0,#16
000024  7028              STRB     r0,[r5,#0]
;;;629    		*mac2	= (uint8_t)(mac_2 >> 24);
000026  9800              LDR      r0,[sp,#0]
000028  0e00              LSRS     r0,r0,#24
00002a  7030              STRB     r0,[r6,#0]
;;;630    		*mac3	= (uint8_t)(mac_2 >> 16);
00002c  9800              LDR      r0,[sp,#0]
00002e  0c00              LSRS     r0,r0,#16
000030  7038              STRB     r0,[r7,#0]
;;;631    		*mac4	= (uint8_t)(mac_2 >> 8);
000032  9800              LDR      r0,[sp,#0]
000034  0a00              LSRS     r0,r0,#8
000036  f8880000          STRB     r0,[r8,#0]
;;;632    		*mac5	= (uint8_t)(mac_2);
00003a  9800              LDR      r0,[sp,#0]
00003c  f8890000          STRB     r0,[r9,#0]
;;;633    		return true;
000040  2001              MOVS     r0,#1
                  |L22.66|
;;;634    	} else {
;;;635    		return false;
;;;636    	}		
;;;637    }
000042  e8bd83fe          POP      {r1-r9,pc}
                  |L22.70|
000046  2000              MOVS     r0,#0                 ;635
000048  e7fb              B        |L22.66|
;;;638    
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;542    */ 
;;;543    uint16_t htons( uint16_t hostshort)	/**< A 16-bit number in host byte order.  */
000000  b500              PUSH     {lr}
;;;544    {
000002  4603              MOV      r3,r0
;;;545    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
;;;546    	return swaps(hostshort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       swaps
;;;547    #else
;;;548    	return hostshort;
;;;549    #endif		
;;;550    }
00000a  bd00              POP      {pc}
;;;551    
                          ENDP


                          AREA ||i.inet_addr_||, CODE, READONLY, ALIGN=2

                  inet_addr_ PROC
;;;492    */
;;;493    void inet_addr_(unsigned char* addr,unsigned char *ip)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;494    {
000004  b088              SUB      sp,sp,#0x20
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;495    	int i;
;;;496    	char taddr[30];
;;;497    	char * nexttok;
;;;498    	char num;
;;;499    	strcpy(taddr,(char *)addr);
00000a  4631              MOV      r1,r6
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       strcpy
;;;500    	
;;;501    	nexttok = taddr;
000012  466c              MOV      r4,sp
;;;502    	for(i = 0; i < 4 ; i++)
000014  2500              MOVS     r5,#0
000016  e01b              B        |L24.80|
                  |L24.24|
;;;503    	{
;;;504    		nexttok = strtok(nexttok,".");
000018  a110              ADR      r1,|L24.92|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       strtok
000020  4604              MOV      r4,r0
;;;505    		if(nexttok[0] == '0' && nexttok[1] == 'x') num = atoi16(nexttok+2,0x10);
000022  7820              LDRB     r0,[r4,#0]
000024  2830              CMP      r0,#0x30
000026  d109              BNE      |L24.60|
000028  7860              LDRB     r0,[r4,#1]
00002a  2878              CMP      r0,#0x78
00002c  d106              BNE      |L24.60|
00002e  2110              MOVS     r1,#0x10
000030  1ca0              ADDS     r0,r4,#2
000032  f7fffffe          BL       atoi16
000036  f00008ff          AND      r8,r0,#0xff
00003a  e005              B        |L24.72|
                  |L24.60|
;;;506    		else num = atoi16(nexttok,10);
00003c  210a              MOVS     r1,#0xa
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       atoi16
000044  f00008ff          AND      r8,r0,#0xff
                  |L24.72|
;;;507    		
;;;508    		ip[i] = num;
000048  f8078005          STRB     r8,[r7,r5]
;;;509    		nexttok = NULL;
00004c  2400              MOVS     r4,#0
00004e  1c6d              ADDS     r5,r5,#1              ;502
                  |L24.80|
000050  2d04              CMP      r5,#4                 ;502
000052  dbe1              BLT      |L24.24|
;;;510    	}
;;;511    }	
000054  b008              ADD      sp,sp,#0x20
000056  e8bd81f0          POP      {r4-r8,pc}
;;;512    /**
                          ENDP

00005a  0000              DCW      0x0000
                  |L24.92|
00005c  2e00              DCB      ".",0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.mid||, CODE, READONLY, ALIGN=1

                  mid PROC
;;;460    */
;;;461    void mid(char* src, char* s1, char* s2, char* sub)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;462    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;463    	char* sub1;
;;;464    	char* sub2;
;;;465    	unsigned short n;
;;;466    
;;;467      sub1=strstr(src,s1);
00000c  4631              MOV      r1,r6
00000e  4648              MOV      r0,r9
000010  f7fffffe          BL       strstr
000014  4604              MOV      r4,r0
;;;468      sub1+=strlen(s1);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       strlen
00001c  4404              ADD      r4,r4,r0
;;;469      sub2=strstr(sub1,s2);
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       strstr
000026  4682              MOV      r10,r0
;;;470      n=sub2-sub1;
000028  ebaa0004          SUB      r0,r10,r4
00002c  fa1ff880          UXTH     r8,r0
;;;471      strncpy(sub,sub1,n);
000030  4642              MOV      r2,r8
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       strncpy
;;;472      sub[n]=0;
00003a  2000              MOVS     r0,#0
00003c  f8050008          STRB     r0,[r5,r8]
;;;473    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;474    
                          ENDP


                          AREA ||i.ntohs||, CODE, READONLY, ALIGN=1

                  ntohs PROC
;;;556    */ 
;;;557    unsigned long ntohs(unsigned short netshort)	/**< netshort - network odering 16bit value */	
000000  b510              PUSH     {r4,lr}
;;;558    {
000002  4604              MOV      r4,r0
;;;559    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )	
;;;560    	return htons(netshort);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       htons
;;;561    #else
;;;562    	return netshort;
;;;563    #endif		
;;;564    }
00000a  bd10              POP      {r4,pc}
;;;565    
                          ENDP


                          AREA ||i.replacetochar||, CODE, READONLY, ALIGN=1

                  replacetochar PROC
;;;516    */
;;;517    void replacetochar(char * str,	char oldchar,char newchar	)
000000  b510              PUSH     {r4,lr}
;;;518    {
000002  460b              MOV      r3,r1
;;;519      int x;
;;;520      for (x = 0; str[x]; x++) 
000004  2100              MOVS     r1,#0
000006  e004              B        |L27.18|
                  |L27.8|
;;;521        if (str[x] == oldchar) str[x] = newchar;	
000008  5c44              LDRB     r4,[r0,r1]
00000a  429c              CMP      r4,r3
00000c  d100              BNE      |L27.16|
00000e  5442              STRB     r2,[r0,r1]
                  |L27.16|
000010  1c49              ADDS     r1,r1,#1              ;520
                  |L27.18|
000012  5c44              LDRB     r4,[r0,r1]            ;520
000014  2c00              CMP      r4,#0                 ;520
000016  d1f7              BNE      |L27.8|
;;;522    }
000018  bd10              POP      {r4,pc}
;;;523    
                          ENDP


                          AREA ||i.swaps||, CODE, READONLY, ALIGN=1

                  swaps PROC
;;;530    */
;;;531    uint16_t swaps(uint16_t i)
000000  4601              MOV      r1,r0
;;;532    {
;;;533      uint16_t ret=0;
000002  2000              MOVS     r0,#0
;;;534      ret = (i & 0xFF) << 8;
000004  060a              LSLS     r2,r1,#24
000006  0c10              LSRS     r0,r2,#16
;;;535      ret |= ((i >> 8)& 0xFF);
000008  ea402011          ORR      r0,r0,r1,LSR #8
;;;536      return ret;	
;;;537    }
00000c  4770              BX       lr
;;;538    /**
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ChipUniqueID
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  crc16Tab
000000  00001021          DCW      0x0000,0x1021
000004  20423063          DCW      0x2042,0x3063
000008  408450a5          DCW      0x4084,0x50a5
00000c  60c670e7          DCW      0x60c6,0x70e7
000010  81089129          DCW      0x8108,0x9129
000014  a14ab16b          DCW      0xa14a,0xb16b
000018  c18cd1ad          DCW      0xc18c,0xd1ad
00001c  e1cef1ef          DCW      0xe1ce,0xf1ef
000020  12310210          DCW      0x1231,0x0210
000024  32732252          DCW      0x3273,0x2252
000028  52b54294          DCW      0x52b5,0x4294
00002c  72f762d6          DCW      0x72f7,0x62d6
000030  93398318          DCW      0x9339,0x8318
000034  b37ba35a          DCW      0xb37b,0xa35a
000038  d3bdc39c          DCW      0xd3bd,0xc39c
00003c  f3ffe3de          DCW      0xf3ff,0xe3de
000040  24623443          DCW      0x2462,0x3443
000044  04201401          DCW      0x0420,0x1401
000048  64e674c7          DCW      0x64e6,0x74c7
00004c  44a45485          DCW      0x44a4,0x5485
000050  a56ab54b          DCW      0xa56a,0xb54b
000054  85289509          DCW      0x8528,0x9509
000058  e5eef5cf          DCW      0xe5ee,0xf5cf
00005c  c5acd58d          DCW      0xc5ac,0xd58d
000060  36532672          DCW      0x3653,0x2672
000064  16110630          DCW      0x1611,0x0630
000068  76d766f6          DCW      0x76d7,0x66f6
00006c  569546b4          DCW      0x5695,0x46b4
000070  b75ba77a          DCW      0xb75b,0xa77a
000074  97198738          DCW      0x9719,0x8738
000078  f7dfe7fe          DCW      0xf7df,0xe7fe
00007c  d79dc7bc          DCW      0xd79d,0xc7bc
000080  48c458e5          DCW      0x48c4,0x58e5
000084  688678a7          DCW      0x6886,0x78a7
000088  08401861          DCW      0x0840,0x1861
00008c  28023823          DCW      0x2802,0x3823
000090  c9ccd9ed          DCW      0xc9cc,0xd9ed
000094  e98ef9af          DCW      0xe98e,0xf9af
000098  89489969          DCW      0x8948,0x9969
00009c  a90ab92b          DCW      0xa90a,0xb92b
0000a0  5af54ad4          DCW      0x5af5,0x4ad4
0000a4  7ab76a96          DCW      0x7ab7,0x6a96
0000a8  1a710a50          DCW      0x1a71,0x0a50
0000ac  3a332a12          DCW      0x3a33,0x2a12
0000b0  dbfdcbdc          DCW      0xdbfd,0xcbdc
0000b4  fbbfeb9e          DCW      0xfbbf,0xeb9e
0000b8  9b798b58          DCW      0x9b79,0x8b58
0000bc  bb3bab1a          DCW      0xbb3b,0xab1a
0000c0  6ca67c87          DCW      0x6ca6,0x7c87
0000c4  4ce45cc5          DCW      0x4ce4,0x5cc5
0000c8  2c223c03          DCW      0x2c22,0x3c03
0000cc  0c601c41          DCW      0x0c60,0x1c41
0000d0  edaefd8f          DCW      0xedae,0xfd8f
0000d4  cdecddcd          DCW      0xcdec,0xddcd
0000d8  ad2abd0b          DCW      0xad2a,0xbd0b
0000dc  8d689d49          DCW      0x8d68,0x9d49
0000e0  7e976eb6          DCW      0x7e97,0x6eb6
0000e4  5ed54ef4          DCW      0x5ed5,0x4ef4
0000e8  3e132e32          DCW      0x3e13,0x2e32
0000ec  1e510e70          DCW      0x1e51,0x0e70
0000f0  ff9fefbe          DCW      0xff9f,0xefbe
0000f4  dfddcffc          DCW      0xdfdd,0xcffc
0000f8  bf1baf3a          DCW      0xbf1b,0xaf3a
0000fc  9f598f78          DCW      0x9f59,0x8f78
000100  918881a9          DCW      0x9188,0x81a9
000104  b1caa1eb          DCW      0xb1ca,0xa1eb
000108  d10cc12d          DCW      0xd10c,0xc12d
00010c  f14ee16f          DCW      0xf14e,0xe16f
000110  108000a1          DCW      0x1080,0x00a1
000114  30c220e3          DCW      0x30c2,0x20e3
000118  50044025          DCW      0x5004,0x4025
00011c  70466067          DCW      0x7046,0x6067
000120  83b99398          DCW      0x83b9,0x9398
000124  a3fbb3da          DCW      0xa3fb,0xb3da
000128  c33dd31c          DCW      0xc33d,0xd31c
00012c  e37ff35e          DCW      0xe37f,0xf35e
000130  02b11290          DCW      0x02b1,0x1290
000134  22f332d2          DCW      0x22f3,0x32d2
000138  42355214          DCW      0x4235,0x5214
00013c  62777256          DCW      0x6277,0x7256
000140  b5eaa5cb          DCW      0xb5ea,0xa5cb
000144  95a88589          DCW      0x95a8,0x8589
000148  f56ee54f          DCW      0xf56e,0xe54f
00014c  d52cc50d          DCW      0xd52c,0xc50d
000150  34e224c3          DCW      0x34e2,0x24c3
000154  14a00481          DCW      0x14a0,0x0481
000158  74666447          DCW      0x7466,0x6447
00015c  54244405          DCW      0x5424,0x4405
000160  a7dbb7fa          DCW      0xa7db,0xb7fa
000164  879997b8          DCW      0x8799,0x97b8
000168  e75ff77e          DCW      0xe75f,0xf77e
00016c  c71dd73c          DCW      0xc71d,0xd73c
000170  26d336f2          DCW      0x26d3,0x36f2
000174  069116b0          DCW      0x0691,0x16b0
000178  66577676          DCW      0x6657,0x7676
00017c  46155634          DCW      0x4615,0x5634
000180  d94cc96d          DCW      0xd94c,0xc96d
000184  f90ee92f          DCW      0xf90e,0xe92f
000188  99c889e9          DCW      0x99c8,0x89e9
00018c  b98aa9ab          DCW      0xb98a,0xa9ab
000190  58444865          DCW      0x5844,0x4865
000194  78066827          DCW      0x7806,0x6827
000198  18c008e1          DCW      0x18c0,0x08e1
00019c  388228a3          DCW      0x3882,0x28a3
0001a0  cb7ddb5c          DCW      0xcb7d,0xdb5c
0001a4  eb3ffb1e          DCW      0xeb3f,0xfb1e
0001a8  8bf99bd8          DCW      0x8bf9,0x9bd8
0001ac  abbbbb9a          DCW      0xabbb,0xbb9a
0001b0  4a755a54          DCW      0x4a75,0x5a54
0001b4  6a377a16          DCW      0x6a37,0x7a16
0001b8  0af11ad0          DCW      0x0af1,0x1ad0
0001bc  2ab33a92          DCW      0x2ab3,0x3a92
0001c0  fd2eed0f          DCW      0xfd2e,0xed0f
0001c4  dd6ccd4d          DCW      0xdd6c,0xcd4d
0001c8  bdaaad8b          DCW      0xbdaa,0xad8b
0001cc  9de88dc9          DCW      0x9de8,0x8dc9
0001d0  7c266c07          DCW      0x7c26,0x6c07
0001d4  5c644c45          DCW      0x5c64,0x4c45
0001d8  3ca22c83          DCW      0x3ca2,0x2c83
0001dc  1ce00cc1          DCW      0x1ce0,0x0cc1
0001e0  ef1fff3e          DCW      0xef1f,0xff3e
0001e4  cf5ddf7c          DCW      0xcf5d,0xdf7c
0001e8  af9bbfba          DCW      0xaf9b,0xbfba
0001ec  8fd99ff8          DCW      0x8fd9,0x9ff8
0001f0  6e177e36          DCW      0x6e17,0x7e36
0001f4  4e555e74          DCW      0x4e55,0x5e74
0001f8  2e933eb2          DCW      0x2e93,0x3eb2
0001fc  0ed11ef0          DCW      0x0ed1,0x1ef0
                  DataStr
000200  4d617220          DCB      0x4d,0x61,0x72,0x20
000204  32352032          DCB      0x32,0x35,0x20,0x32
000208  30313800          DCB      0x30,0x31,0x38,0x00
                  TimeStr
00020c  31303a30          DCB      0x31,0x30,0x3a,0x30
000210  343a3535          DCB      0x34,0x3a,0x35,0x35
000214  00                DCB      0x00
                  table_crc_hi
000215  00c181            DCB      0x00,0xc1,0x81
000218  4001c080          DCB      0x40,0x01,0xc0,0x80
00021c  4101c080          DCB      0x41,0x01,0xc0,0x80
000220  4100c181          DCB      0x41,0x00,0xc1,0x81
000224  4001c080          DCB      0x40,0x01,0xc0,0x80
000228  4100c181          DCB      0x41,0x00,0xc1,0x81
00022c  4000c181          DCB      0x40,0x00,0xc1,0x81
000230  4001c080          DCB      0x40,0x01,0xc0,0x80
000234  4101c080          DCB      0x41,0x01,0xc0,0x80
000238  4100c181          DCB      0x41,0x00,0xc1,0x81
00023c  4000c181          DCB      0x40,0x00,0xc1,0x81
000240  4001c080          DCB      0x40,0x01,0xc0,0x80
000244  4100c181          DCB      0x41,0x00,0xc1,0x81
000248  4001c080          DCB      0x40,0x01,0xc0,0x80
00024c  4101c080          DCB      0x41,0x01,0xc0,0x80
000250  4100c181          DCB      0x41,0x00,0xc1,0x81
000254  4001c080          DCB      0x40,0x01,0xc0,0x80
000258  4100c181          DCB      0x41,0x00,0xc1,0x81
00025c  4000c181          DCB      0x40,0x00,0xc1,0x81
000260  4001c080          DCB      0x40,0x01,0xc0,0x80
000264  4100c181          DCB      0x41,0x00,0xc1,0x81
000268  4001c080          DCB      0x40,0x01,0xc0,0x80
00026c  4101c080          DCB      0x41,0x01,0xc0,0x80
000270  4100c181          DCB      0x41,0x00,0xc1,0x81
000274  4000c181          DCB      0x40,0x00,0xc1,0x81
000278  4001c080          DCB      0x40,0x01,0xc0,0x80
00027c  4101c080          DCB      0x41,0x01,0xc0,0x80
000280  4100c181          DCB      0x41,0x00,0xc1,0x81
000284  4001c080          DCB      0x40,0x01,0xc0,0x80
000288  4100c181          DCB      0x41,0x00,0xc1,0x81
00028c  4000c181          DCB      0x40,0x00,0xc1,0x81
000290  4001c080          DCB      0x40,0x01,0xc0,0x80
000294  4101c080          DCB      0x41,0x01,0xc0,0x80
000298  4100c181          DCB      0x41,0x00,0xc1,0x81
00029c  4000c181          DCB      0x40,0x00,0xc1,0x81
0002a0  4001c080          DCB      0x40,0x01,0xc0,0x80
0002a4  4100c181          DCB      0x41,0x00,0xc1,0x81
0002a8  4001c080          DCB      0x40,0x01,0xc0,0x80
0002ac  4101c080          DCB      0x41,0x01,0xc0,0x80
0002b0  4100c181          DCB      0x41,0x00,0xc1,0x81
0002b4  4000c181          DCB      0x40,0x00,0xc1,0x81
0002b8  4001c080          DCB      0x40,0x01,0xc0,0x80
0002bc  4101c080          DCB      0x41,0x01,0xc0,0x80
0002c0  4100c181          DCB      0x41,0x00,0xc1,0x81
0002c4  4001c080          DCB      0x40,0x01,0xc0,0x80
0002c8  4100c181          DCB      0x41,0x00,0xc1,0x81
0002cc  4000c181          DCB      0x40,0x00,0xc1,0x81
0002d0  4001c080          DCB      0x40,0x01,0xc0,0x80
0002d4  4100c181          DCB      0x41,0x00,0xc1,0x81
0002d8  4001c080          DCB      0x40,0x01,0xc0,0x80
0002dc  4101c080          DCB      0x41,0x01,0xc0,0x80
0002e0  4100c181          DCB      0x41,0x00,0xc1,0x81
0002e4  4001c080          DCB      0x40,0x01,0xc0,0x80
0002e8  4100c181          DCB      0x41,0x00,0xc1,0x81
0002ec  4000c181          DCB      0x40,0x00,0xc1,0x81
0002f0  4001c080          DCB      0x40,0x01,0xc0,0x80
0002f4  4101c080          DCB      0x41,0x01,0xc0,0x80
0002f8  4100c181          DCB      0x41,0x00,0xc1,0x81
0002fc  4000c181          DCB      0x40,0x00,0xc1,0x81
000300  4001c080          DCB      0x40,0x01,0xc0,0x80
000304  4100c181          DCB      0x41,0x00,0xc1,0x81
000308  4001c080          DCB      0x40,0x01,0xc0,0x80
00030c  4101c080          DCB      0x41,0x01,0xc0,0x80
000310  4100c181          DCB      0x41,0x00,0xc1,0x81
000314  40                DCB      0x40
                  table_crc_lo
000315  00c0c1            DCB      0x00,0xc0,0xc1
000318  01c30302          DCB      0x01,0xc3,0x03,0x02
00031c  c2c60607          DCB      0xc2,0xc6,0x06,0x07
000320  c705c5c4          DCB      0xc7,0x05,0xc5,0xc4
000324  04cc0c0d          DCB      0x04,0xcc,0x0c,0x0d
000328  cd0fcfce          DCB      0xcd,0x0f,0xcf,0xce
00032c  0e0acacb          DCB      0x0e,0x0a,0xca,0xcb
000330  0bc90908          DCB      0x0b,0xc9,0x09,0x08
000334  c8d81819          DCB      0xc8,0xd8,0x18,0x19
000338  d91bdbda          DCB      0xd9,0x1b,0xdb,0xda
00033c  1a1ededf          DCB      0x1a,0x1e,0xde,0xdf
000340  1fdd1d1c          DCB      0x1f,0xdd,0x1d,0x1c
000344  dc14d4d5          DCB      0xdc,0x14,0xd4,0xd5
000348  15d71716          DCB      0x15,0xd7,0x17,0x16
00034c  d6d21213          DCB      0xd6,0xd2,0x12,0x13
000350  d311d1d0          DCB      0xd3,0x11,0xd1,0xd0
000354  10f03031          DCB      0x10,0xf0,0x30,0x31
000358  f133f3f2          DCB      0xf1,0x33,0xf3,0xf2
00035c  3236f6f7          DCB      0x32,0x36,0xf6,0xf7
000360  37f53534          DCB      0x37,0xf5,0x35,0x34
000364  f43cfcfd          DCB      0xf4,0x3c,0xfc,0xfd
000368  3dff3f3e          DCB      0x3d,0xff,0x3f,0x3e
00036c  fefa3a3b          DCB      0xfe,0xfa,0x3a,0x3b
000370  fb39f9f8          DCB      0xfb,0x39,0xf9,0xf8
000374  3828e8e9          DCB      0x38,0x28,0xe8,0xe9
000378  29eb2b2a          DCB      0x29,0xeb,0x2b,0x2a
00037c  eaee2e2f          DCB      0xea,0xee,0x2e,0x2f
000380  ef2dedec          DCB      0xef,0x2d,0xed,0xec
000384  2ce42425          DCB      0x2c,0xe4,0x24,0x25
000388  e527e7e6          DCB      0xe5,0x27,0xe7,0xe6
00038c  2622e2e3          DCB      0x26,0x22,0xe2,0xe3
000390  23e12120          DCB      0x23,0xe1,0x21,0x20
000394  e0a06061          DCB      0xe0,0xa0,0x60,0x61
000398  a163a3a2          DCB      0xa1,0x63,0xa3,0xa2
00039c  6266a6a7          DCB      0x62,0x66,0xa6,0xa7
0003a0  67a56564          DCB      0x67,0xa5,0x65,0x64
0003a4  a46cacad          DCB      0xa4,0x6c,0xac,0xad
0003a8  6daf6f6e          DCB      0x6d,0xaf,0x6f,0x6e
0003ac  aeaa6a6b          DCB      0xae,0xaa,0x6a,0x6b
0003b0  ab69a9a8          DCB      0xab,0x69,0xa9,0xa8
0003b4  6878b8b9          DCB      0x68,0x78,0xb8,0xb9
0003b8  79bb7b7a          DCB      0x79,0xbb,0x7b,0x7a
0003bc  babe7e7f          DCB      0xba,0xbe,0x7e,0x7f
0003c0  bf7dbdbc          DCB      0xbf,0x7d,0xbd,0xbc
0003c4  7cb47475          DCB      0x7c,0xb4,0x74,0x75
0003c8  b577b7b6          DCB      0xb5,0x77,0xb7,0xb6
0003cc  7672b2b3          DCB      0x76,0x72,0xb2,0xb3
0003d0  73b17170          DCB      0x73,0xb1,0x71,0x70
0003d4  b0509091          DCB      0xb0,0x50,0x90,0x91
0003d8  51935352          DCB      0x51,0x93,0x53,0x52
0003dc  92965657          DCB      0x92,0x96,0x56,0x57
0003e0  97559594          DCB      0x97,0x55,0x95,0x94
0003e4  549c5c5d          DCB      0x54,0x9c,0x5c,0x5d
0003e8  9d5f9f9e          DCB      0x9d,0x5f,0x9f,0x9e
0003ec  5e5a9a9b          DCB      0x5e,0x5a,0x9a,0x9b
0003f0  5b995958          DCB      0x5b,0x99,0x59,0x58
0003f4  98884849          DCB      0x98,0x88,0x48,0x49
0003f8  894b8b8a          DCB      0x89,0x4b,0x8b,0x8a
0003fc  4a4e8e8f          DCB      0x4a,0x4e,0x8e,0x8f
000400  4f8d4d4c          DCB      0x4f,0x8d,0x4d,0x4c
000404  8c448485          DCB      0x8c,0x44,0x84,0x85
000408  45874746          DCB      0x45,0x87,0x47,0x46
00040c  86824243          DCB      0x86,0x82,0x42,0x43
000410  83418180          DCB      0x83,0x41,0x81,0x80
000414  40                DCB      0x40

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
                  STM32_FLASH_SIZE
000004  0000              DCB      0x00,0x00

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\heap_4.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\heap_4.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\heap_4.crf ..\Libraries\FreeRTOS\portable\MemMang\heap_4.c]
                          THUMB

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;359    
;;;360    static void prvHeapInit( void )
000000  b570              PUSH     {r4-r6,lr}
;;;361    {
;;;362    BlockLink_t *pxFirstFreeBlock;
;;;363    uint8_t *pucHeapEnd, *pucAlignedHeap;
;;;364    
;;;365    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;366    	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
000002  4819              LDR      r0,|L1.104|
000004  f0200407          BIC      r4,r0,#7
;;;367    
;;;368    	/* xStart is used to hold a pointer to the first item in the list of free
;;;369    	blocks.  The void cast is used to prevent compiler warnings. */
;;;370    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000008  4818              LDR      r0,|L1.108|
00000a  6004              STR      r4,[r0,#0]  ; xStart
;;;371    	xStart.xBlockSize = ( size_t ) 0;
00000c  2000              MOVS     r0,#0
00000e  4917              LDR      r1,|L1.108|
000010  6048              STR      r0,[r1,#4]  ; xStart
;;;372    
;;;373    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;374    	at the end of the heap space. */
;;;375    	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
000012  f64470f8          MOV      r0,#0x4ff8
000016  1826              ADDS     r6,r4,r0
;;;376    	pucHeapEnd -= heapSTRUCT_SIZE;
000018  3e08              SUBS     r6,r6,#8
;;;377    	pxEnd = ( void * ) pucHeapEnd;
00001a  4815              LDR      r0,|L1.112|
00001c  6006              STR      r6,[r0,#0]  ; pxEnd
;;;378    	configASSERT( ( ( ( uint32_t ) pxEnd ) & ( ( uint32_t ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
00001e  7800              LDRB     r0,[r0,#0]  ; pxEnd
000020  f0000007          AND      r0,r0,#7
000024  b908              CBNZ     r0,|L1.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L1.44|
                  |L1.42|
00002a  2000              MOVS     r0,#0
                  |L1.44|
00002c  b918              CBNZ     r0,|L1.54|
00002e  f7fffffe          BL       ulPortSetInterruptMask
000032  bf00              NOP      
                  |L1.52|
000034  e7fe              B        |L1.52|
                  |L1.54|
;;;379    	pxEnd->xBlockSize = 0;
000036  2000              MOVS     r0,#0
000038  490d              LDR      r1,|L1.112|
00003a  6809              LDR      r1,[r1,#0]  ; pxEnd
00003c  6048              STR      r0,[r1,#4]
;;;380    	pxEnd->pxNextFreeBlock = NULL;
00003e  490c              LDR      r1,|L1.112|
000040  6809              LDR      r1,[r1,#0]  ; pxEnd
000042  6008              STR      r0,[r1,#0]
;;;381    
;;;382    	/* To start with there is a single free block that is sized to take up the
;;;383    	entire heap space, minus the space taken by pxEnd. */
;;;384    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
000044  4625              MOV      r5,r4
;;;385    	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
000046  f64470f0          MOV      r0,#0x4ff0
00004a  6068              STR      r0,[r5,#4]
;;;386    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
00004c  4808              LDR      r0,|L1.112|
00004e  6800              LDR      r0,[r0,#0]  ; pxEnd
000050  6028              STR      r0,[r5,#0]
;;;387    
;;;388    	/* The heap now contains pxEnd. */
;;;389    	xFreeBytesRemaining -= heapSTRUCT_SIZE;
000052  4808              LDR      r0,|L1.116|
000054  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
000056  3808              SUBS     r0,r0,#8
000058  4906              LDR      r1,|L1.116|
00005a  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;390    
;;;391    	/* Work out the position of the top bit in a size_t variable. */
;;;392    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
00005c  f04f4000          MOV      r0,#0x80000000
000060  4905              LDR      r1,|L1.120|
000062  6008              STR      r0,[r1,#0]  ; xBlockAllocatedBit
;;;393    }
000064  bd70              POP      {r4-r6,pc}
;;;394    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
                          DCD      ucHeap+0x8
                  |L1.108|
                          DCD      xStart
                  |L1.112|
                          DCD      pxEnd
                  |L1.116|
                          DCD      xFreeBytesRemaining
                  |L1.120|
                          DCD      xBlockAllocatedBit

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;395    
;;;396    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b510              PUSH     {r4,lr}
;;;397    {
000002  4601              MOV      r1,r0
;;;398    BlockLink_t *pxIterator;
;;;399    uint8_t *puc;
;;;400    
;;;401    	/* Iterate through the list until a block is found that has a higher address
;;;402    	than the block being inserted. */
;;;403    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000004  4816              LDR      r0,|L2.96|
000006  e000              B        |L2.10|
                  |L2.8|
000008  6800              LDR      r0,[r0,#0]
                  |L2.10|
00000a  6803              LDR      r3,[r0,#0]
00000c  428b              CMP      r3,r1
00000e  d3fb              BCC      |L2.8|
;;;404    	{
;;;405    		/* Nothing to do here, just iterate to the right position. */
;;;406    	}
;;;407    
;;;408    	/* Do the block being inserted, and the block it is being inserted after
;;;409    	make a contiguous block of memory? */
;;;410    	puc = ( uint8_t * ) pxIterator;
000010  4602              MOV      r2,r0
;;;411    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
000012  6843              LDR      r3,[r0,#4]
000014  4413              ADD      r3,r3,r2
000016  428b              CMP      r3,r1
000018  d104              BNE      |L2.36|
;;;412    	{
;;;413    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
00001a  6843              LDR      r3,[r0,#4]
00001c  684c              LDR      r4,[r1,#4]
00001e  4423              ADD      r3,r3,r4
000020  6043              STR      r3,[r0,#4]
;;;414    		pxBlockToInsert = pxIterator;
000022  4601              MOV      r1,r0
                  |L2.36|
;;;415    	}
;;;416    	else
;;;417    	{
;;;418    		mtCOVERAGE_TEST_MARKER();
;;;419    	}
;;;420    
;;;421    	/* Do the block being inserted, and the block it is being inserted before
;;;422    	make a contiguous block of memory? */
;;;423    	puc = ( uint8_t * ) pxBlockToInsert;
000024  460a              MOV      r2,r1
;;;424    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
000026  684b              LDR      r3,[r1,#4]
000028  4413              ADD      r3,r3,r2
00002a  6804              LDR      r4,[r0,#0]
00002c  42a3              CMP      r3,r4
00002e  d111              BNE      |L2.84|
;;;425    	{
;;;426    		if( pxIterator->pxNextFreeBlock != pxEnd )
000030  4c0c              LDR      r4,|L2.100|
000032  6803              LDR      r3,[r0,#0]
000034  6824              LDR      r4,[r4,#0]  ; pxEnd
000036  42a3              CMP      r3,r4
000038  d008              BEQ      |L2.76|
;;;427    		{
;;;428    			/* Form one big block from the two blocks. */
;;;429    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
00003a  684b              LDR      r3,[r1,#4]
00003c  6804              LDR      r4,[r0,#0]
00003e  6864              LDR      r4,[r4,#4]
000040  4423              ADD      r3,r3,r4
000042  604b              STR      r3,[r1,#4]
;;;430    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000044  6803              LDR      r3,[r0,#0]
000046  681b              LDR      r3,[r3,#0]
000048  600b              STR      r3,[r1,#0]
00004a  e005              B        |L2.88|
                  |L2.76|
;;;431    		}
;;;432    		else
;;;433    		{
;;;434    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
00004c  4b05              LDR      r3,|L2.100|
00004e  681b              LDR      r3,[r3,#0]  ; pxEnd
000050  600b              STR      r3,[r1,#0]
000052  e001              B        |L2.88|
                  |L2.84|
;;;435    		}
;;;436    	}
;;;437    	else
;;;438    	{
;;;439    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
000054  6803              LDR      r3,[r0,#0]
000056  600b              STR      r3,[r1,#0]
                  |L2.88|
;;;440    	}
;;;441    
;;;442    	/* If the block being inserted plugged a gab, so was merged with the block
;;;443    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;444    	already been set, and should not be set here as that would make it point
;;;445    	to itself. */
;;;446    	if( pxIterator != pxBlockToInsert )
000058  4288              CMP      r0,r1
00005a  d000              BEQ      |L2.94|
;;;447    	{
;;;448    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
00005c  6001              STR      r1,[r0,#0]
                  |L2.94|
;;;449    	}
;;;450    	else
;;;451    	{
;;;452    		mtCOVERAGE_TEST_MARKER();
;;;453    	}
;;;454    }
00005e  bd10              POP      {r4,pc}
;;;455    
                          ENDP

                  |L2.96|
                          DCD      xStart
                  |L2.100|
                          DCD      pxEnd

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;146    
;;;147    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000004  4605              MOV      r5,r0
;;;149    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;150    void *pvReturn = NULL;
000006  f04f0800          MOV      r8,#0
;;;151    
;;;152    	vTaskSuspendAll();
00000a  f7fffffe          BL       vTaskSuspendAll
;;;153    	{
;;;154    		/* If this is the first call to malloc then the heap will require
;;;155    		initialisation to setup the list of free blocks. */
;;;156    		if( pxEnd == NULL )
00000e  482b              LDR      r0,|L3.188|
000010  6800              LDR      r0,[r0,#0]  ; pxEnd
000012  b908              CBNZ     r0,|L3.24|
;;;157    		{
;;;158    			prvHeapInit();
000014  f7fffffe          BL       prvHeapInit
                  |L3.24|
;;;159    		}
;;;160    		else
;;;161    		{
;;;162    			mtCOVERAGE_TEST_MARKER();
;;;163    		}
;;;164    
;;;165    		/* Check the requested block size is not so large that the top bit is
;;;166    		set.  The top bit of the block size member of the BlockLink_t structure
;;;167    		is used to determine who owns the block - the application or the
;;;168    		kernel, so it must be free. */
;;;169    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000018  4829              LDR      r0,|L3.192|
00001a  6800              LDR      r0,[r0,#0]  ; xBlockAllocatedBit
00001c  4028              ANDS     r0,r0,r5
00001e  2800              CMP      r0,#0
000020  d147              BNE      |L3.178|
;;;170    		{
;;;171    			/* The wanted size is increased so it can contain a BlockLink_t
;;;172    			structure in addition to the requested amount of bytes. */
;;;173    			if( xWantedSize > 0 )
000022  b145              CBZ      r5,|L3.54|
;;;174    			{
;;;175    				xWantedSize += heapSTRUCT_SIZE;
000024  3508              ADDS     r5,r5,#8
;;;176    
;;;177    				/* Ensure that blocks are always aligned to the required number
;;;178    				of bytes. */
;;;179    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000026  f0050007          AND      r0,r5,#7
00002a  b120              CBZ      r0,|L3.54|
;;;180    				{
;;;181    					/* Byte alignment required. */
;;;182    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
00002c  f0050007          AND      r0,r5,#7
000030  f1c00008          RSB      r0,r0,#8
000034  4405              ADD      r5,r5,r0
                  |L3.54|
;;;183    				}
;;;184    				else
;;;185    				{
;;;186    					mtCOVERAGE_TEST_MARKER();
;;;187    				}
;;;188    			}
;;;189    			else
;;;190    			{
;;;191    				mtCOVERAGE_TEST_MARKER();
;;;192    			}
;;;193    
;;;194    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
000036  2d00              CMP      r5,#0
000038  d03b              BEQ      |L3.178|
00003a  4822              LDR      r0,|L3.196|
00003c  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
00003e  4285              CMP      r5,r0
000040  d837              BHI      |L3.178|
;;;195    			{
;;;196    				/* Traverse the list from the start	(lowest address) block until
;;;197    				one	of adequate size is found. */
;;;198    				pxPreviousBlock = &xStart;
000042  4e21              LDR      r6,|L3.200|
;;;199    				pxBlock = xStart.pxNextFreeBlock;
000044  4630              MOV      r0,r6
000046  6804              LDR      r4,[r0,#0]  ; xStart
;;;200    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000048  e001              B        |L3.78|
                  |L3.74|
;;;201    				{
;;;202    					pxPreviousBlock = pxBlock;
00004a  4626              MOV      r6,r4
;;;203    					pxBlock = pxBlock->pxNextFreeBlock;
00004c  6824              LDR      r4,[r4,#0]
                  |L3.78|
00004e  6860              LDR      r0,[r4,#4]            ;200
000050  42a8              CMP      r0,r5                 ;200
000052  d202              BCS      |L3.90|
000054  6820              LDR      r0,[r4,#0]            ;200
000056  2800              CMP      r0,#0                 ;200
000058  d1f7              BNE      |L3.74|
                  |L3.90|
;;;204    				}
;;;205    
;;;206    				/* If the end marker was reached then a block of adequate size
;;;207    				was	not found. */
;;;208    				if( pxBlock != pxEnd )
00005a  4818              LDR      r0,|L3.188|
00005c  6800              LDR      r0,[r0,#0]  ; pxEnd
00005e  4284              CMP      r4,r0
000060  d027              BEQ      |L3.178|
;;;209    				{
;;;210    					/* Return the memory space pointed to - jumping over the
;;;211    					BlockLink_t structure at its start. */
;;;212    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
000062  6830              LDR      r0,[r6,#0]
000064  f1000808          ADD      r8,r0,#8
;;;213    
;;;214    					/* This block is being returned for use so must be taken out
;;;215    					of the list of free blocks. */
;;;216    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
000068  6820              LDR      r0,[r4,#0]
00006a  6030              STR      r0,[r6,#0]
;;;217    
;;;218    					/* If the block is larger than required it can be split into
;;;219    					two. */
;;;220    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
00006c  6860              LDR      r0,[r4,#4]
00006e  1b40              SUBS     r0,r0,r5
000070  2810              CMP      r0,#0x10
000072  d907              BLS      |L3.132|
;;;221    					{
;;;222    						/* This block is to be split into two.  Create a new
;;;223    						block following the number of bytes requested. The void
;;;224    						cast is used to prevent byte alignment warnings from the
;;;225    						compiler. */
;;;226    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
000074  1967              ADDS     r7,r4,r5
;;;227    
;;;228    						/* Calculate the sizes of two blocks split from the
;;;229    						single block. */
;;;230    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
000076  6860              LDR      r0,[r4,#4]
000078  1b40              SUBS     r0,r0,r5
00007a  6078              STR      r0,[r7,#4]
;;;231    						pxBlock->xBlockSize = xWantedSize;
00007c  6065              STR      r5,[r4,#4]
;;;232    
;;;233    						/* Insert the new block into the list of free blocks. */
;;;234    						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L3.132|
;;;235    					}
;;;236    					else
;;;237    					{
;;;238    						mtCOVERAGE_TEST_MARKER();
;;;239    					}
;;;240    
;;;241    					xFreeBytesRemaining -= pxBlock->xBlockSize;
000084  490f              LDR      r1,|L3.196|
000086  6860              LDR      r0,[r4,#4]
000088  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
00008a  1a08              SUBS     r0,r1,r0
00008c  490d              LDR      r1,|L3.196|
00008e  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;242    
;;;243    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
000090  4608              MOV      r0,r1
000092  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
000094  490d              LDR      r1,|L3.204|
000096  6809              LDR      r1,[r1,#0]  ; xMinimumEverFreeBytesRemaining
000098  4288              CMP      r0,r1
00009a  d203              BCS      |L3.164|
;;;244    					{
;;;245    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
00009c  4809              LDR      r0,|L3.196|
00009e  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000a0  490a              LDR      r1,|L3.204|
0000a2  6008              STR      r0,[r1,#0]  ; xMinimumEverFreeBytesRemaining
                  |L3.164|
;;;246    					}
;;;247    					else
;;;248    					{
;;;249    						mtCOVERAGE_TEST_MARKER();
;;;250    					}
;;;251    
;;;252    					/* The block is being returned - it is allocated and owned
;;;253    					by the application and has no "next" block. */
;;;254    					pxBlock->xBlockSize |= xBlockAllocatedBit;
0000a4  4906              LDR      r1,|L3.192|
0000a6  6860              LDR      r0,[r4,#4]
0000a8  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
0000aa  4308              ORRS     r0,r0,r1
0000ac  6060              STR      r0,[r4,#4]
;;;255    					pxBlock->pxNextFreeBlock = NULL;
0000ae  2000              MOVS     r0,#0
0000b0  6020              STR      r0,[r4,#0]
                  |L3.178|
;;;256    				}
;;;257    				else
;;;258    				{
;;;259    					mtCOVERAGE_TEST_MARKER();
;;;260    				}
;;;261    			}
;;;262    			else
;;;263    			{
;;;264    				mtCOVERAGE_TEST_MARKER();
;;;265    			}
;;;266    		}
;;;267    		else
;;;268    		{
;;;269    			mtCOVERAGE_TEST_MARKER();
;;;270    		}
;;;271    
;;;272    		traceMALLOC( pvReturn, xWantedSize );
;;;273    	}
;;;274    	xTaskResumeAll();
0000b2  f7fffffe          BL       xTaskResumeAll
;;;275    
;;;276    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;277    	{
;;;278    		if( pvReturn == NULL )
;;;279    		{
;;;280    			extern void vApplicationMallocFailedHook( void );
;;;281    			vApplicationMallocFailedHook();
;;;282    		}
;;;283    		else
;;;284    		{
;;;285    			mtCOVERAGE_TEST_MARKER();
;;;286    		}
;;;287    	}
;;;288    	#endif
;;;289    
;;;290    	return pvReturn;
0000b6  4640              MOV      r0,r8
;;;291    }
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;292    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.188|
                          DCD      pxEnd
                  |L3.192|
                          DCD      xBlockAllocatedBit
                  |L3.196|
                          DCD      xFreeBytesRemaining
                  |L3.200|
                          DCD      xStart
                  |L3.204|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;293    
;;;294    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4606              MOV      r6,r0
;;;296    uint8_t *puc = ( uint8_t * ) pv;
000004  4635              MOV      r5,r6
;;;297    BlockLink_t *pxLink;
;;;298    
;;;299    	if( pv != NULL )
000006  2e00              CMP      r6,#0
000008  d031              BEQ      |L4.110|
;;;300    	{
;;;301    		/* The memory being freed will have an BlockLink_t structure immediately
;;;302    		before it. */
;;;303    		puc -= heapSTRUCT_SIZE;
00000a  3d08              SUBS     r5,r5,#8
;;;304    
;;;305    		/* This casting is to keep the compiler from issuing warnings. */
;;;306    		pxLink = ( void * ) puc;
00000c  462c              MOV      r4,r5
;;;307    
;;;308    		/* Check the block is actually allocated. */
;;;309    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
00000e  4918              LDR      r1,|L4.112|
000010  6860              LDR      r0,[r4,#4]
000012  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000014  4008              ANDS     r0,r0,r1
000016  b108              CBZ      r0,|L4.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L4.30|
                  |L4.28|
00001c  2000              MOVS     r0,#0
                  |L4.30|
00001e  b918              CBNZ     r0,|L4.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L4.38|
000026  e7fe              B        |L4.38|
                  |L4.40|
;;;310    		configASSERT( pxLink->pxNextFreeBlock == NULL );
000028  6820              LDR      r0,[r4,#0]
00002a  b908              CBNZ     r0,|L4.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L4.50|
                  |L4.48|
000030  2000              MOVS     r0,#0
                  |L4.50|
000032  b918              CBNZ     r0,|L4.60|
000034  f7fffffe          BL       ulPortSetInterruptMask
000038  bf00              NOP      
                  |L4.58|
00003a  e7fe              B        |L4.58|
                  |L4.60|
;;;311    
;;;312    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
00003c  490c              LDR      r1,|L4.112|
00003e  6860              LDR      r0,[r4,#4]
000040  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000042  4008              ANDS     r0,r0,r1
000044  b198              CBZ      r0,|L4.110|
;;;313    		{
;;;314    			if( pxLink->pxNextFreeBlock == NULL )
000046  6820              LDR      r0,[r4,#0]
000048  b988              CBNZ     r0,|L4.110|
;;;315    			{
;;;316    				/* The block is being returned to the heap - it is no longer
;;;317    				allocated. */
;;;318    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
00004a  4909              LDR      r1,|L4.112|
00004c  6860              LDR      r0,[r4,#4]
00004e  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000050  4388              BICS     r0,r0,r1
000052  6060              STR      r0,[r4,#4]
;;;319    
;;;320    				vTaskSuspendAll();
000054  f7fffffe          BL       vTaskSuspendAll
;;;321    				{
;;;322    					/* Add this block to the list of free blocks. */
;;;323    					xFreeBytesRemaining += pxLink->xBlockSize;
000058  4906              LDR      r1,|L4.116|
00005a  6860              LDR      r0,[r4,#4]
00005c  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
00005e  4408              ADD      r0,r0,r1
000060  4904              LDR      r1,|L4.116|
000062  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;324    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;325    					traceFREE( pv, pxLink->xBlockSize );
;;;326    				}
;;;327    				xTaskResumeAll();
00006a  f7fffffe          BL       xTaskResumeAll
                  |L4.110|
;;;328    			}
;;;329    			else
;;;330    			{
;;;331    				mtCOVERAGE_TEST_MARKER();
;;;332    			}
;;;333    		}
;;;334    		else
;;;335    		{
;;;336    			mtCOVERAGE_TEST_MARKER();
;;;337    		}
;;;338    	}
;;;339    }
00006e  bd70              POP      {r4-r6,pc}
;;;340    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.112|
                          DCD      xBlockAllocatedBit
                  |L4.116|
                          DCD      xFreeBytesRemaining

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=1

                  vPortInitialiseBlocks PROC
;;;353    
;;;354    void vPortInitialiseBlocks( void )
000000  4770              BX       lr
;;;355    {
;;;356    	/* This just exists to keep the linker quiet. */
;;;357    }
;;;358    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;341    
;;;342    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L6.8|
;;;343    {
;;;344    	return xFreeBytesRemaining;
000002  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;345    }
000004  4770              BX       lr
;;;346    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      xFreeBytesRemaining

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;347    
;;;348    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L7.8|
;;;349    {
;;;350    	return xMinimumEverFreeBytesRemaining;
000002  6800              LDR      r0,[r0,#0]  ; xMinimumEverFreeBytesRemaining
;;;351    }
000004  4770              BX       lr
;;;352    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        20480

                          AREA ||.data||, DATA, ALIGN=2

                  xStart
                          %        8
                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00004ff8
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00004ff8
                  xBlockAllocatedBit
                          DCD      0x00000000

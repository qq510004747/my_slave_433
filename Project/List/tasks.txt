; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\tasks.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\tasks.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\OLED -I..\BSP -I..\BSP\OLED -I..\BSP\TIMER3 -I..\BSP\BSP_Switch -I..\BSP\BSP_USART1 -I..\BSP\BSP_Internet\W5500 -I..\BSP\SX1278\radio -I..\BSP\SX1278\platform\sx12xxEiger -I..\BSP\SX1278\platform -I..\BSP\apps -I..\BSP\BSP_FIFO -I..\BSP\crc -I..\BSP\ADC -I..\BSP\BSP_USART3 -I..\BSP\E31radio_driver -I..\BSP\TIMER2 -I..\BSP\BSP_USART2 -I.\RTE\_STM32F10x________2.0.0 -IE:\keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IE:\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tasks.crf ..\Libraries\FreeRTOS\tasks.c]
                          THUMB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;2842   
;;;2843   static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
000000  b510              PUSH     {r4,lr}
;;;2844   {
000002  4604              MOV      r4,r0
;;;2845   	/* The list item will be inserted in wake time order. */
;;;2846   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000004  480e              LDR      r0,|L1.64|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000008  6044              STR      r4,[r0,#4]
;;;2847   
;;;2848   	if( xTimeToWake < xTickCount )
00000a  480e              LDR      r0,|L1.68|
00000c  6800              LDR      r0,[r0,#0]  ; xTickCount
00000e  4284              CMP      r4,r0
000010  d207              BCS      |L1.34|
;;;2849   	{
;;;2850   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;2851   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000012  480b              LDR      r0,|L1.64|
000014  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000016  1d09              ADDS     r1,r1,#4
000018  480b              LDR      r0,|L1.72|
00001a  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
00001c  f7fffffe          BL       vListInsert
000020  e00c              B        |L1.60|
                  |L1.34|
;;;2852   	}
;;;2853   	else
;;;2854   	{
;;;2855   		/* The wake time has not overflowed, so the current block list is used. */
;;;2856   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000022  4807              LDR      r0,|L1.64|
000024  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000026  1d09              ADDS     r1,r1,#4
000028  4808              LDR      r0,|L1.76|
00002a  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00002c  f7fffffe          BL       vListInsert
;;;2857   
;;;2858   		/* If the task entering the blocked state was placed at the head of the
;;;2859   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;2860   		too. */
;;;2861   		if( xTimeToWake < xNextTaskUnblockTime )
000030  4807              LDR      r0,|L1.80|
000032  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000034  4284              CMP      r4,r0
000036  d201              BCS      |L1.60|
;;;2862   		{
;;;2863   			xNextTaskUnblockTime = xTimeToWake;
000038  4805              LDR      r0,|L1.80|
00003a  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L1.60|
;;;2864   		}
;;;2865   		else
;;;2866   		{
;;;2867   			mtCOVERAGE_TEST_MARKER();
;;;2868   		}
;;;2869   	}
;;;2870   }
00003c  bd10              POP      {r4,pc}
;;;2871   /*-----------------------------------------------------------*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      pxCurrentTCB
                  |L1.68|
                          DCD      xTickCount
                  |L1.72|
                          DCD      pxOverflowDelayedTaskList
                  |L1.76|
                          DCD      pxDelayedTaskList
                  |L1.80|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAllocateTCBAndStack||, CODE, READONLY, ALIGN=1

                  prvAllocateTCBAndStack PROC
;;;2872   
;;;2873   static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;2874   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;2875   TCB_t *pxNewTCB;
;;;2876   
;;;2877   	/* Allocate space for the TCB.  Where the memory comes from depends on
;;;2878   	the implementation of the port malloc function. */
;;;2879   	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
000006  2048              MOVS     r0,#0x48
000008  f7fffffe          BL       pvPortMalloc
00000c  4604              MOV      r4,r0
;;;2880   
;;;2881   	if( pxNewTCB != NULL )
00000e  b164              CBZ      r4,|L2.42|
;;;2882   	{
;;;2883   		/* Allocate space for the stack used by the task being created.
;;;2884   		The base of the stack memory stored in the TCB so the task can
;;;2885   		be deleted later if required. */
;;;2886   		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000010  b91e              CBNZ     r6,|L2.26|
000012  00a8              LSLS     r0,r5,#2
000014  f7fffffe          BL       pvPortMalloc
000018  e000              B        |L2.28|
                  |L2.26|
00001a  4630              MOV      r0,r6
                  |L2.28|
00001c  6320              STR      r0,[r4,#0x30]
;;;2887   
;;;2888   		if( pxNewTCB->pxStack == NULL )
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b918              CBNZ     r0,|L2.42|
;;;2889   		{
;;;2890   			/* Could not allocate the stack.  Delete the allocated TCB. */
;;;2891   			vPortFree( pxNewTCB );
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       vPortFree
;;;2892   			pxNewTCB = NULL;
000028  2400              MOVS     r4,#0
                  |L2.42|
;;;2893   		}
;;;2894   		else
;;;2895   		{
;;;2896   			/* Avoid dependency on memset() if it is not required. */
;;;2897   			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;2898   			{
;;;2899   				/* Just to help debugging. */
;;;2900   				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
;;;2901   			}
;;;2902   			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;2903   		}
;;;2904   	}
;;;2905   
;;;2906   	return pxNewTCB;
00002a  4620              MOV      r0,r4
;;;2907   }
00002c  bd70              POP      {r4-r6,pc}
;;;2908   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;2803   
;;;2804   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2805   {
;;;2806   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2807   	{
;;;2808   		BaseType_t xListIsEmpty;
;;;2809   
;;;2810   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;2811   		too often in the idle task. */
;;;2812   		while( uxTasksDeleted > ( UBaseType_t ) 0U )
000002  e023              B        |L3.76|
                  |L3.4|
;;;2813   		{
;;;2814   			vTaskSuspendAll();
000004  f7fffffe          BL       vTaskSuspendAll
;;;2815   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000008  4813              LDR      r0,|L3.88|
00000a  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
00000c  b908              CBNZ     r0,|L3.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L3.20|
                  |L3.18|
000012  2000              MOVS     r0,#0
                  |L3.20|
000014  4605              MOV      r5,r0
;;;2816   			( void ) xTaskResumeAll();
000016  f7fffffe          BL       xTaskResumeAll
;;;2817   
;;;2818   			if( xListIsEmpty == pdFALSE )
00001a  b9bd              CBNZ     r5,|L3.76|
;;;2819   			{
;;;2820   				TCB_t *pxTCB;
;;;2821   
;;;2822   				taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;2823   				{
;;;2824   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
000020  480d              LDR      r0,|L3.88|
000022  68c0              LDR      r0,[r0,#0xc]
000024  68c4              LDR      r4,[r0,#0xc]
;;;2825   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       uxListRemove
;;;2826   					--uxCurrentNumberOfTasks;
00002c  480b              LDR      r0,|L3.92|
00002e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000030  1e40              SUBS     r0,r0,#1
000032  490a              LDR      r1,|L3.92|
000034  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;2827   					--uxTasksDeleted;
000036  480a              LDR      r0,|L3.96|
000038  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
00003a  1e40              SUBS     r0,r0,#1
00003c  4908              LDR      r1,|L3.96|
00003e  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;2828   				}
;;;2829   				taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;2830   
;;;2831   				prvDeleteTCB( pxTCB );
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       prvDeleteTCB
;;;2832   			}
00004a  bf00              NOP      
                  |L3.76|
00004c  4804              LDR      r0,|L3.96|
00004e  6800              LDR      r0,[r0,#0]            ;2812  ; uxTasksDeleted
000050  2800              CMP      r0,#0                 ;2812
000052  d1d7              BNE      |L3.4|
;;;2833   			else
;;;2834   			{
;;;2835   				mtCOVERAGE_TEST_MARKER();
;;;2836   			}
;;;2837   		}
;;;2838   	}
;;;2839   	#endif /* vTaskDelete */
;;;2840   }
000054  bd70              POP      {r4-r6,pc}
;;;2841   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      xTasksWaitingTermination
                  |L3.92|
                          DCD      uxCurrentNumberOfTasks
                  |L3.96|
                          DCD      uxTasksDeleted

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3029   
;;;3030   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3031   	{
000002  4604              MOV      r4,r0
;;;3032   		/* This call is required specifically for the TriCore port.  It must be
;;;3033   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3034   		want to allocate and clean RAM statically. */
;;;3035   		portCLEAN_UP_TCB( pxTCB );
;;;3036   
;;;3037   		/* Free up the memory allocated by the scheduler for the task.  It is up to
;;;3038   		the task to free any memory allocated at the application level. */
;;;3039   		vPortFreeAligned( pxTCB->pxStack );
000004  6b20              LDR      r0,[r4,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3040   		vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3041   	}
000010  bd10              POP      {r4,pc}
;;;3042   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;2516    */
;;;2517   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L5.2|
;;;2518   {
;;;2519   	/* Stop warnings. */
;;;2520   	( void ) pvParameters;
;;;2521   
;;;2522   	for( ;; )
;;;2523   	{
;;;2524   		/* See if any tasks have been deleted. */
;;;2525   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;2526   
;;;2527   		#if ( configUSE_PREEMPTION == 0 )
;;;2528   		{
;;;2529   			/* If we are not using preemption we keep forcing a task switch to
;;;2530   			see if any other task has become available.  If we are using
;;;2531   			preemption we don't need to do this as any task becoming available
;;;2532   			will automatically get the processor anyway. */
;;;2533   			taskYIELD();
;;;2534   		}
;;;2535   		#endif /* configUSE_PREEMPTION */
;;;2536   
;;;2537   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2538   		{
;;;2539   			/* When using preemption tasks of equal priority will be
;;;2540   			timesliced.  If a task that is sharing the idle priority is ready
;;;2541   			to run then the idle task should yield before the end of the
;;;2542   			timeslice.
;;;2543   
;;;2544   			A critical region is not required here as we are just reading from
;;;2545   			the list, and an occasional incorrect value will not matter.  If
;;;2546   			the ready list at the idle priority contains more than one task
;;;2547   			then a task other than the idle task is ready to execute. */
;;;2548   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  4803              LDR      r0,|L5.20|
000008  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d9f9              BLS      |L5.2|
;;;2549   			{
;;;2550   				taskYIELD();
00000e  f7fffffe          BL       vPortYield
000012  e7f6              B        |L5.2|
;;;2551   			}
;;;2552   			else
;;;2553   			{
;;;2554   				mtCOVERAGE_TEST_MARKER();
;;;2555   			}
;;;2556   		}
;;;2557   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2558   
;;;2559   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2560   		{
;;;2561   			extern void vApplicationIdleHook( void );
;;;2562   
;;;2563   			/* Call the user defined function from within the idle task.  This
;;;2564   			allows the application designer to add background functionality
;;;2565   			without the overhead of a separate task.
;;;2566   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2567   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2568   			vApplicationIdleHook();
;;;2569   		}
;;;2570   		#endif /* configUSE_IDLE_HOOK */
;;;2571   
;;;2572   		/* This conditional compilation should use inequality to 0, not equality
;;;2573   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2574   		user defined low power mode	implementations require
;;;2575   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2576   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2577   		{
;;;2578   		TickType_t xExpectedIdleTime;
;;;2579   
;;;2580   			/* It is not desirable to suspend then resume the scheduler on
;;;2581   			each iteration of the idle task.  Therefore, a preliminary
;;;2582   			test of the expected idle time is performed without the
;;;2583   			scheduler suspended.  The result here is not necessarily
;;;2584   			valid. */
;;;2585   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2586   
;;;2587   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2588   			{
;;;2589   				vTaskSuspendAll();
;;;2590   				{
;;;2591   					/* Now the scheduler is suspended, the expected idle
;;;2592   					time can be sampled again, and this time its value can
;;;2593   					be used. */
;;;2594   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2595   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2596   
;;;2597   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2598   					{
;;;2599   						traceLOW_POWER_IDLE_BEGIN();
;;;2600   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2601   						traceLOW_POWER_IDLE_END();
;;;2602   					}
;;;2603   					else
;;;2604   					{
;;;2605   						mtCOVERAGE_TEST_MARKER();
;;;2606   					}
;;;2607   				}
;;;2608   				( void ) xTaskResumeAll();
;;;2609   			}
;;;2610   			else
;;;2611   			{
;;;2612   				mtCOVERAGE_TEST_MARKER();
;;;2613   			}
;;;2614   		}
;;;2615   		#endif /* configUSE_TICKLESS_IDLE */
;;;2616   	}
;;;2617   }
;;;2618   /*-----------------------------------------------------------*/
                          ENDP

                  |L5.20|
                          DCD      pxReadyTasksLists

                          AREA ||i.prvInitialiseTCBVariables||, CODE, READONLY, ALIGN=1

                  prvInitialiseTCBVariables PROC
;;;2663   
;;;2664   static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2665   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;2666   UBaseType_t x;
;;;2667   
;;;2668   	/* Store the task name in the TCB. */
;;;2669   	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000010  2600              MOVS     r6,#0
000012  e007              B        |L6.36|
                  |L6.20|
;;;2670   	{
;;;2671   		pxTCB->pcTaskName[ x ] = pcName[ x ];
000014  5db9              LDRB     r1,[r7,r6]
000016  f1040034          ADD      r0,r4,#0x34
00001a  5581              STRB     r1,[r0,r6]
;;;2672   
;;;2673   		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;2674   		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;2675   		string is not accessible (extremely unlikely). */
;;;2676   		if( pcName[ x ] == 0x00 )
00001c  5db8              LDRB     r0,[r7,r6]
00001e  b900              CBNZ     r0,|L6.34|
;;;2677   		{
;;;2678   			break;
000020  e002              B        |L6.40|
                  |L6.34|
000022  1c76              ADDS     r6,r6,#1              ;2669
                  |L6.36|
000024  2e10              CMP      r6,#0x10              ;2669
000026  d3f5              BCC      |L6.20|
                  |L6.40|
000028  bf00              NOP      
;;;2679   		}
;;;2680   		else
;;;2681   		{
;;;2682   			mtCOVERAGE_TEST_MARKER();
;;;2683   		}
;;;2684   	}
;;;2685   
;;;2686   	/* Ensure the name string is terminated in the case that the string length
;;;2687   	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;2688   	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
00002a  2100              MOVS     r1,#0
00002c  2043              MOVS     r0,#0x43
00002e  5501              STRB     r1,[r0,r4]
;;;2689   
;;;2690   	/* This is used as an array index so must ensure it's not too large.  First
;;;2691   	remove the privilege bit if one is present. */
;;;2692   	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000030  2d05              CMP      r5,#5
000032  d300              BCC      |L6.54|
;;;2693   	{
;;;2694   		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000034  2504              MOVS     r5,#4
                  |L6.54|
;;;2695   	}
;;;2696   	else
;;;2697   	{
;;;2698   		mtCOVERAGE_TEST_MARKER();
;;;2699   	}
;;;2700   
;;;2701   	pxTCB->uxPriority = uxPriority;
000036  62e5              STR      r5,[r4,#0x2c]
;;;2702   	#if ( configUSE_MUTEXES == 1 )
;;;2703   	{
;;;2704   		pxTCB->uxBasePriority = uxPriority;
000038  6465              STR      r5,[r4,#0x44]
;;;2705   	}
;;;2706   	#endif /* configUSE_MUTEXES */
;;;2707   
;;;2708   	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       vListInitialiseItem
;;;2709   	vListInitialiseItem( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       vListInitialiseItem
;;;2710   
;;;2711   	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
;;;2712   	back to	the containing TCB from a generic item in a list. */
;;;2713   	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
000048  6124              STR      r4,[r4,#0x10]
;;;2714   
;;;2715   	/* Event lists are always in priority order. */
;;;2716   	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00004a  f1c50005          RSB      r0,r5,#5
00004e  61a0              STR      r0,[r4,#0x18]
;;;2717   	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
000050  6264              STR      r4,[r4,#0x24]
;;;2718   
;;;2719   	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;2720   	{
;;;2721   		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;2722   	}
;;;2723   	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;2724   
;;;2725   	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;2726   	{
;;;2727   		pxTCB->pxTaskTag = NULL;
;;;2728   	}
;;;2729   	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;2730   
;;;2731   	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2732   	{
;;;2733   		pxTCB->ulRunTimeCounter = 0UL;
;;;2734   	}
;;;2735   	#endif /* configGENERATE_RUN_TIME_STATS */
;;;2736   
;;;2737   	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;2738   	{
;;;2739   		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
;;;2740   	}
;;;2741   	#else /* portUSING_MPU_WRAPPERS */
;;;2742   	{
;;;2743   		( void ) xRegions;
;;;2744   		( void ) usStackDepth;
;;;2745   	}
;;;2746   	#endif /* portUSING_MPU_WRAPPERS */
;;;2747   
;;;2748   	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2749   	{
;;;2750   		/* Initialise this task's Newlib reent structure. */
;;;2751   		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
;;;2752   	}
;;;2753   	#endif /* configUSE_NEWLIB_REENTRANT */
;;;2754   }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;2755   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;2771   
;;;2772   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;2773   {
;;;2774   UBaseType_t uxPriority;
;;;2775   
;;;2776   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L7.22|
                  |L7.6|
;;;2777   	{
;;;2778   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L7.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;2776
                  |L7.22|
000016  2c05              CMP      r4,#5                 ;2776
000018  d3f5              BCC      |L7.6|
;;;2779   	}
;;;2780   
;;;2781   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L7.76|
00001c  f7fffffe          BL       vListInitialise
;;;2782   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L7.80|
000022  f7fffffe          BL       vListInitialise
;;;2783   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L7.84|
000028  f7fffffe          BL       vListInitialise
;;;2784   
;;;2785   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2786   	{
;;;2787   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L7.88|
00002e  f7fffffe          BL       vListInitialise
;;;2788   	}
;;;2789   	#endif /* INCLUDE_vTaskDelete */
;;;2790   
;;;2791   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2792   	{
;;;2793   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L7.92|
000034  f7fffffe          BL       vListInitialise
;;;2794   	}
;;;2795   	#endif /* INCLUDE_vTaskSuspend */
;;;2796   
;;;2797   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;2798   	using list2. */
;;;2799   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L7.76|
00003a  4909              LDR      r1,|L7.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;2800   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L7.80|
000040  4908              LDR      r1,|L7.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;2801   }
000044  bd10              POP      {r4,pc}
;;;2802   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L7.72|
                          DCD      pxReadyTasksLists
                  |L7.76|
                          DCD      xDelayedTaskList1
                  |L7.80|
                          DCD      xDelayedTaskList2
                  |L7.84|
                          DCD      xPendingReadyList
                  |L7.88|
                          DCD      xTasksWaitingTermination
                  |L7.92|
                          DCD      xSuspendedTaskList
                  |L7.96|
                          DCD      pxDelayedTaskList
                  |L7.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3045   
;;;3046   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L8.44|
;;;3047   {
;;;3048   TCB_t *pxTCB;
;;;3049   
;;;3050   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L8.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  2100              MOVS     r1,#0
                  |L8.14|
00000e  b121              CBZ      r1,|L8.26|
;;;3051   	{
;;;3052   		/* The new current delayed list is empty.  Set
;;;3053   		xNextTaskUnblockTime to the maximum possible value so it is
;;;3054   		extremely unlikely that the
;;;3055   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3056   		there is an item in the delayed list. */
;;;3057   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L8.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L8.40|
                  |L8.26|
;;;3058   	}
;;;3059   	else
;;;3060   	{
;;;3061   		/* The new current delayed list is not empty, get the value of
;;;3062   		the item at the head of the delayed list.  This is the time at
;;;3063   		which the task at the head of the delayed list should be removed
;;;3064   		from the Blocked state. */
;;;3065   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00001a  4904              LDR      r1,|L8.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3066   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
000022  4a03              LDR      r2,|L8.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L8.40|
;;;3067   	}
;;;3068   }
000028  4770              BX       lr
;;;3069   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      pxDelayedTaskList
                  |L8.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;1689   
;;;1690   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L9.8|
;;;1691   {
;;;1692   	/* A critical section is not required because the variables are of type
;;;1693   	BaseType_t. */
;;;1694   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;1695   }
000004  4770              BX       lr
;;;1696   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;986    
;;;987    	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;988    	{
000002  4604              MOV      r4,r0
;;;989    	TCB_t *pxTCB;
;;;990    	UBaseType_t uxReturn;
;;;991    
;;;992    		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;993    		{
;;;994    			/* If null is passed in here then we are changing the
;;;995    			priority of the calling function. */
;;;996    			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L10.16|
00000a  4805              LDR      r0,|L10.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L10.18|
                  |L10.16|
000010  4620              MOV      r0,r4
                  |L10.18|
000012  4606              MOV      r6,r0
;;;997    			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;998    		}
;;;999    		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1000   
;;;1001   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1002   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1003   
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;3482   
;;;3483   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L11.24|
;;;3484   {
;;;3485   TickType_t uxReturn;
;;;3486   
;;;3487   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;3488   
;;;3489   	/* Reset the event list item to its normal value - so it can be used with
;;;3490   	queues and semaphores. */
;;;3491   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L11.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10105          RSB      r1,r1,#5
000010  4a01              LDR      r2,|L11.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;3492   
;;;3493   	return uxReturn;
;;;3494   }
000016  4770              BX       lr
;;;3495   /*-----------------------------------------------------------*/
                          ENDP

                  |L11.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;850    
;;;851    	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;852    	{
000002  4604              MOV      r4,r0
;;;853    	TickType_t xTimeToWake;
;;;854    	BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;855    
;;;856    
;;;857    		/* A delay time of zero just forces a reschedule. */
;;;858    		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b1d4              CBZ      r4,|L12.62|
;;;859    		{
;;;860    			configASSERT( uxSchedulerSuspended == 0 );
000008  480f              LDR      r0,|L12.72|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b908              CBNZ     r0,|L12.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L12.20|
                  |L12.18|
000012  2000              MOVS     r0,#0
                  |L12.20|
000014  b918              CBNZ     r0,|L12.30|
000016  f7fffffe          BL       ulPortSetInterruptMask
00001a  bf00              NOP      
                  |L12.28|
00001c  e7fe              B        |L12.28|
                  |L12.30|
;;;861    			vTaskSuspendAll();
00001e  f7fffffe          BL       vTaskSuspendAll
;;;862    			{
;;;863    				traceTASK_DELAY();
;;;864    
;;;865    				/* A task that is removed from the event list while the
;;;866    				scheduler is suspended will not get placed in the ready
;;;867    				list or removed from the blocked list until the scheduler
;;;868    				is resumed.
;;;869    
;;;870    				This task cannot be in an event list as it is the currently
;;;871    				executing task. */
;;;872    
;;;873    				/* Calculate the time to wake - this may overflow but this is
;;;874    				not a problem. */
;;;875    				xTimeToWake = xTickCount + xTicksToDelay;
000022  480a              LDR      r0,|L12.76|
000024  6800              LDR      r0,[r0,#0]  ; xTickCount
000026  1905              ADDS     r5,r0,r4
;;;876    
;;;877    				/* We must remove ourselves from the ready list before adding
;;;878    				ourselves to the blocked list as the same list item is used for
;;;879    				both lists. */
;;;880    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000028  4809              LDR      r0,|L12.80|
00002a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00002c  1d00              ADDS     r0,r0,#4
00002e  f7fffffe          BL       uxListRemove
;;;881    				{
;;;882    					/* The current task must be in a ready list, so there is
;;;883    					no need to check, and the port reset macro can be called
;;;884    					directly. */
;;;885    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;886    				}
;;;887    				else
;;;888    				{
;;;889    					mtCOVERAGE_TEST_MARKER();
;;;890    				}
;;;891    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;892    			}
;;;893    			xAlreadyYielded = xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
00003c  4606              MOV      r6,r0
                  |L12.62|
;;;894    		}
;;;895    		else
;;;896    		{
;;;897    			mtCOVERAGE_TEST_MARKER();
;;;898    		}
;;;899    
;;;900    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;901    		have put ourselves to sleep. */
;;;902    		if( xAlreadyYielded == pdFALSE )
00003e  b90e              CBNZ     r6,|L12.68|
;;;903    		{
;;;904    			portYIELD_WITHIN_API();
000040  f7fffffe          BL       vPortYield
                  |L12.68|
;;;905    		}
;;;906    		else
;;;907    		{
;;;908    			mtCOVERAGE_TEST_MARKER();
;;;909    		}
;;;910    	}
000044  bd70              POP      {r4-r6,pc}
;;;911    
                          ENDP

000046  0000              DCW      0x0000
                  |L12.72|
                          DCD      uxSchedulerSuspended
                  |L12.76|
                          DCD      xTickCount
                  |L12.80|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;753    
;;;754    	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;755    	{
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;756    	TickType_t xTimeToWake;
;;;757    	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;758    
;;;759    		configASSERT( pxPreviousWakeTime );
00000c  b91c              CBNZ     r4,|L13.22|
00000e  f7fffffe          BL       ulPortSetInterruptMask
000012  bf00              NOP      
                  |L13.20|
000014  e7fe              B        |L13.20|
                  |L13.22|
;;;760    		configASSERT( ( xTimeIncrement > 0U ) );
000016  b10e              CBZ      r6,|L13.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L13.30|
                  |L13.28|
00001c  2000              MOVS     r0,#0
                  |L13.30|
00001e  b918              CBNZ     r0,|L13.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L13.38|
000026  e7fe              B        |L13.38|
                  |L13.40|
;;;761    		configASSERT( uxSchedulerSuspended == 0 );
000028  481b              LDR      r0,|L13.152|
00002a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002c  b908              CBNZ     r0,|L13.50|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L13.52|
                  |L13.50|
000032  2000              MOVS     r0,#0
                  |L13.52|
000034  b918              CBNZ     r0,|L13.62|
000036  f7fffffe          BL       ulPortSetInterruptMask
00003a  bf00              NOP      
                  |L13.60|
00003c  e7fe              B        |L13.60|
                  |L13.62|
;;;762    
;;;763    		vTaskSuspendAll();
00003e  f7fffffe          BL       vTaskSuspendAll
;;;764    		{
;;;765    			/* Minor optimisation.  The tick count cannot change in this
;;;766    			block. */
;;;767    			const TickType_t xConstTickCount = xTickCount;
000042  4816              LDR      r0,|L13.156|
000044  f8d08000          LDR      r8,[r0,#0]  ; xTickCount
;;;768    
;;;769    			/* Generate the tick time at which the task wants to wake. */
;;;770    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000048  6820              LDR      r0,[r4,#0]
00004a  1985              ADDS     r5,r0,r6
;;;771    
;;;772    			if( xConstTickCount < *pxPreviousWakeTime )
00004c  6820              LDR      r0,[r4,#0]
00004e  4540              CMP      r0,r8
000050  d907              BLS      |L13.98|
;;;773    			{
;;;774    				/* The tick count has overflowed since this function was
;;;775    				lasted called.  In this case the only time we should ever
;;;776    				actually delay is if the wake time has also	overflowed,
;;;777    				and the wake time is greater than the tick time.  When this
;;;778    				is the case it is as if neither time had overflowed. */
;;;779    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000052  6820              LDR      r0,[r4,#0]
000054  42a8              CMP      r0,r5
000056  d90b              BLS      |L13.112|
000058  4545              CMP      r5,r8
00005a  d909              BLS      |L13.112|
;;;780    				{
;;;781    					xShouldDelay = pdTRUE;
00005c  f04f0901          MOV      r9,#1
000060  e006              B        |L13.112|
                  |L13.98|
;;;782    				}
;;;783    				else
;;;784    				{
;;;785    					mtCOVERAGE_TEST_MARKER();
;;;786    				}
;;;787    			}
;;;788    			else
;;;789    			{
;;;790    				/* The tick time has not overflowed.  In this case we will
;;;791    				delay if either the wake time has overflowed, and/or the
;;;792    				tick time is less than the wake time. */
;;;793    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
000062  6820              LDR      r0,[r4,#0]
000064  42a8              CMP      r0,r5
000066  d801              BHI      |L13.108|
000068  4545              CMP      r5,r8
00006a  d901              BLS      |L13.112|
                  |L13.108|
;;;794    				{
;;;795    					xShouldDelay = pdTRUE;
00006c  f04f0901          MOV      r9,#1
                  |L13.112|
;;;796    				}
;;;797    				else
;;;798    				{
;;;799    					mtCOVERAGE_TEST_MARKER();
;;;800    				}
;;;801    			}
;;;802    
;;;803    			/* Update the wake time ready for the next call. */
;;;804    			*pxPreviousWakeTime = xTimeToWake;
000070  6025              STR      r5,[r4,#0]
;;;805    
;;;806    			if( xShouldDelay != pdFALSE )
000072  f1b90f00          CMP      r9,#0
000076  d007              BEQ      |L13.136|
;;;807    			{
;;;808    				traceTASK_DELAY_UNTIL();
;;;809    
;;;810    				/* We must remove ourselves from the ready list before adding
;;;811    				ourselves to the blocked list as the same list item is used for
;;;812    				both lists. */
;;;813    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000078  4809              LDR      r0,|L13.160|
00007a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00007c  1d00              ADDS     r0,r0,#4
00007e  f7fffffe          BL       uxListRemove
;;;814    				{
;;;815    					/* The current task must be in a ready list, so there is
;;;816    					no need to check, and the port reset macro can be called
;;;817    					directly. */
;;;818    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;819    				}
;;;820    				else
;;;821    				{
;;;822    					mtCOVERAGE_TEST_MARKER();
;;;823    				}
;;;824    
;;;825    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L13.136|
;;;826    			}
;;;827    			else
;;;828    			{
;;;829    				mtCOVERAGE_TEST_MARKER();
;;;830    			}
;;;831    		}
;;;832    		xAlreadyYielded = xTaskResumeAll();
000088  f7fffffe          BL       xTaskResumeAll
00008c  4607              MOV      r7,r0
;;;833    
;;;834    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;835    		have put ourselves to sleep. */
;;;836    		if( xAlreadyYielded == pdFALSE )
00008e  b90f              CBNZ     r7,|L13.148|
;;;837    		{
;;;838    			portYIELD_WITHIN_API();
000090  f7fffffe          BL       vPortYield
                  |L13.148|
;;;839    		}
;;;840    		else
;;;841    		{
;;;842    			mtCOVERAGE_TEST_MARKER();
;;;843    		}
;;;844    	}
000094  e8bd87f0          POP      {r4-r10,pc}
;;;845    
                          ENDP

                  |L13.152|
                          DCD      uxSchedulerSuspended
                  |L13.156|
                          DCD      xTickCount
                  |L13.160|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;675    
;;;676    	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;677    	{
000002  4605              MOV      r5,r0
;;;678    	TCB_t *pxTCB;
;;;679    
;;;680    		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;681    		{
;;;682    			/* If null is passed in here then it is the calling task that is
;;;683    			being deleted. */
;;;684    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L14.16|
00000a  481b              LDR      r0,|L14.120|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L14.18|
                  |L14.16|
000010  4628              MOV      r0,r5
                  |L14.18|
000012  4604              MOV      r4,r0
;;;685    
;;;686    			/* Remove task from the ready list and place in the	termination list.
;;;687    			This will stop the task from be scheduled.  The idle task will check
;;;688    			the termination list and free up any memory allocated by the
;;;689    			scheduler for the TCB and stack. */
;;;690    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;691    			{
;;;692    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;693    			}
;;;694    			else
;;;695    			{
;;;696    				mtCOVERAGE_TEST_MARKER();
;;;697    			}
;;;698    
;;;699    			/* Is the task waiting on an event also? */
;;;700    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  b118              CBZ      r0,|L14.38|
;;;701    			{
;;;702    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       uxListRemove
                  |L14.38|
;;;703    			}
;;;704    			else
;;;705    			{
;;;706    				mtCOVERAGE_TEST_MARKER();
;;;707    			}
;;;708    
;;;709    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4814              LDR      r0,|L14.124|
00002a  f7fffffe          BL       vListInsertEnd
;;;710    
;;;711    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;712    			there is a task that has been deleted and that it should therefore
;;;713    			check the xTasksWaitingTermination list. */
;;;714    			++uxTasksDeleted;
00002e  4814              LDR      r0,|L14.128|
000030  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
000032  1c40              ADDS     r0,r0,#1
000034  4912              LDR      r1,|L14.128|
000036  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;715    
;;;716    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;717    			can detect that the task lists need re-generating. */
;;;718    			uxTaskNumber++;
000038  4812              LDR      r0,|L14.132|
00003a  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00003c  1c40              ADDS     r0,r0,#1
00003e  4911              LDR      r1,|L14.132|
000040  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;719    
;;;720    			traceTASK_DELETE( pxTCB );
;;;721    		}
;;;722    		taskEXIT_CRITICAL();
000042  f7fffffe          BL       vPortExitCritical
;;;723    
;;;724    		/* Force a reschedule if it is the currently running task that has just
;;;725    		been deleted. */
;;;726    		if( xSchedulerRunning != pdFALSE )
000046  4810              LDR      r0,|L14.136|
000048  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00004a  b198              CBZ      r0,|L14.116|
;;;727    		{
;;;728    			if( pxTCB == pxCurrentTCB )
00004c  480a              LDR      r0,|L14.120|
00004e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000050  4284              CMP      r4,r0
000052  d10d              BNE      |L14.112|
;;;729    			{
;;;730    				configASSERT( uxSchedulerSuspended == 0 );
000054  480d              LDR      r0,|L14.140|
000056  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000058  b908              CBNZ     r0,|L14.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L14.96|
                  |L14.94|
00005e  2000              MOVS     r0,#0
                  |L14.96|
000060  b918              CBNZ     r0,|L14.106|
000062  f7fffffe          BL       ulPortSetInterruptMask
000066  bf00              NOP      
                  |L14.104|
000068  e7fe              B        |L14.104|
                  |L14.106|
;;;731    
;;;732    				/* The pre-delete hook is primarily for the Windows simulator,
;;;733    				in which Windows specific clean up operations are performed,
;;;734    				after which it is not possible to yield away from this task -
;;;735    				hence xYieldPending is used to latch that a context switch is
;;;736    				required. */
;;;737    				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;738    				portYIELD_WITHIN_API();
00006a  f7fffffe          BL       vPortYield
00006e  e001              B        |L14.116|
                  |L14.112|
;;;739    			}
;;;740    			else
;;;741    			{
;;;742    				/* Reset the next expected unblock time in case it referred to
;;;743    				the task that has just been deleted. */
;;;744    				prvResetNextTaskUnblockTime();
000070  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L14.116|
;;;745    			}
;;;746    		}
;;;747    	}
000074  bd70              POP      {r4-r6,pc}
;;;748    
                          ENDP

000076  0000              DCW      0x0000
                  |L14.120|
                          DCD      pxCurrentTCB
                  |L14.124|
                          DCD      xTasksWaitingTermination
                  |L14.128|
                          DCD      uxTasksDeleted
                  |L14.132|
                          DCD      uxTaskNumber
                  |L14.136|
                          DCD      xSchedulerRunning
                  |L14.140|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1502   
;;;1503   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1504   {
;;;1505   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1506   	routine so the original ISRs can be restored if necessary.  The port
;;;1507   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1508   	portDISABLE_INTERRUPTS();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;1509   	xSchedulerRunning = pdFALSE;
000006  2000              MOVS     r0,#0
000008  4902              LDR      r1,|L15.20|
00000a  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1510   	vPortEndScheduler();
00000c  f7fffffe          BL       vPortEndScheduler
;;;1511   }
000010  bd10              POP      {r4,pc}
;;;1512   /*----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;2461   
;;;2462   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;2463   {
;;;2464   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L16.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2465   }
000006  4770              BX       lr
;;;2466   /*-----------------------------------------------------------*/
                          ENDP

                  |L16.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2140   
;;;2141   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2142   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2143   TickType_t xTimeToWake;
;;;2144   
;;;2145   	configASSERT( pxEventList );
000006  b91d              CBNZ     r5,|L17.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L17.14|
00000e  e7fe              B        |L17.14|
                  |L17.16|
;;;2146   
;;;2147   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;2148   	SCHEDULER SUSPENDED. */
;;;2149   
;;;2150   	/* Place the event list item of the TCB in the appropriate event list.
;;;2151   	This is placed in the list in priority order so the highest priority task
;;;2152   	is the first to be woken by the event. */
;;;2153   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000010  480d              LDR      r0,|L17.72|
000012  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000014  3118              ADDS     r1,r1,#0x18
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       vListInsert
;;;2154   
;;;2155   	/* We must remove ourselves from the ready list before adding ourselves
;;;2156   	to the blocked list as the same list item is used for both lists.  We have
;;;2157   	exclusive access to the ready lists as the scheduler is locked. */
;;;2158   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00001c  480a              LDR      r0,|L17.72|
00001e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000020  1d00              ADDS     r0,r0,#4
000022  f7fffffe          BL       uxListRemove
;;;2159   	{
;;;2160   		/* The current task must be in a ready list, so there is no need to
;;;2161   		check, and the port reset macro can be called directly. */
;;;2162   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;2163   	}
;;;2164   	else
;;;2165   	{
;;;2166   		mtCOVERAGE_TEST_MARKER();
;;;2167   	}
;;;2168   
;;;2169   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2170   	{
;;;2171   		if( xTicksToWait == portMAX_DELAY )
000026  1c60              ADDS     r0,r4,#1
000028  b930              CBNZ     r0,|L17.56|
;;;2172   		{
;;;2173   			/* Add ourselves to the suspended task list instead of a delayed task
;;;2174   			list to ensure we are not woken by a timing event.  We will block
;;;2175   			indefinitely. */
;;;2176   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00002a  4807              LDR      r0,|L17.72|
00002c  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00002e  1d09              ADDS     r1,r1,#4
000030  4806              LDR      r0,|L17.76|
000032  f7fffffe          BL       vListInsertEnd
000036  e005              B        |L17.68|
                  |L17.56|
;;;2177   		}
;;;2178   		else
;;;2179   		{
;;;2180   			/* Calculate the time at which the task should be woken if the event does
;;;2181   			not occur.  This may overflow but this doesn't matter. */
;;;2182   			xTimeToWake = xTickCount + xTicksToWait;
000038  4805              LDR      r0,|L17.80|
00003a  6800              LDR      r0,[r0,#0]  ; xTickCount
00003c  1906              ADDS     r6,r0,r4
;;;2183   			prvAddCurrentTaskToDelayedList( xTimeToWake );
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L17.68|
;;;2184   		}
;;;2185   	}
;;;2186   	#else /* INCLUDE_vTaskSuspend */
;;;2187   	{
;;;2188   			/* Calculate the time at which the task should be woken if the event does
;;;2189   			not occur.  This may overflow but this doesn't matter. */
;;;2190   			xTimeToWake = xTickCount + xTicksToWait;
;;;2191   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2192   	}
;;;2193   	#endif /* INCLUDE_vTaskSuspend */
;;;2194   }
000044  bd70              POP      {r4-r6,pc}
;;;2195   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L17.72|
                          DCD      pxCurrentTCB
                  |L17.76|
                          DCD      xSuspendedTaskList
                  |L17.80|
                          DCD      xTickCount

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2196   
;;;2197   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2198   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;2199   TickType_t xTimeToWake;
;;;2200   
;;;2201   	configASSERT( pxEventList );
00000a  b91d              CBNZ     r5,|L18.20|
00000c  f7fffffe          BL       ulPortSetInterruptMask
000010  bf00              NOP      
                  |L18.18|
000012  e7fe              B        |L18.18|
                  |L18.20|
;;;2202   
;;;2203   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;2204   	SCHEDULER SUSPENDED. */
;;;2205   
;;;2206   	/* Store the item value in the event list item. */
;;;2207   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000014  f0464000          ORR      r0,r6,#0x80000000
000018  490f              LDR      r1,|L18.88|
00001a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00001c  6188              STR      r0,[r1,#0x18]
;;;2208   
;;;2209   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2210   	list. */
;;;2211   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00001e  480e              LDR      r0,|L18.88|
000020  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000022  3118              ADDS     r1,r1,#0x18
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       vListInsertEnd
;;;2212   
;;;2213   	/* The task must be removed from the ready list before it is added to the
;;;2214   	blocked list.  Exclusive access can be assured to the ready list as the
;;;2215   	scheduler is locked. */
;;;2216   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00002a  480b              LDR      r0,|L18.88|
00002c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00002e  1d00              ADDS     r0,r0,#4
000030  f7fffffe          BL       uxListRemove
;;;2217   	{
;;;2218   		/* The current task must be in a ready list, so there is no need to
;;;2219   		check, and the port reset macro can be called directly. */
;;;2220   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;2221   	}
;;;2222   	else
;;;2223   	{
;;;2224   		mtCOVERAGE_TEST_MARKER();
;;;2225   	}
;;;2226   
;;;2227   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2228   	{
;;;2229   		if( xTicksToWait == portMAX_DELAY )
000034  1c60              ADDS     r0,r4,#1
000036  b930              CBNZ     r0,|L18.70|
;;;2230   		{
;;;2231   			/* Add the task to the suspended task list instead of a delayed task
;;;2232   			list to ensure it is not woken by a timing event.  It will block
;;;2233   			indefinitely. */
;;;2234   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000038  4807              LDR      r0,|L18.88|
00003a  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00003c  1d09              ADDS     r1,r1,#4
00003e  4807              LDR      r0,|L18.92|
000040  f7fffffe          BL       vListInsertEnd
000044  e005              B        |L18.82|
                  |L18.70|
;;;2235   		}
;;;2236   		else
;;;2237   		{
;;;2238   			/* Calculate the time at which the task should be woken if the event does
;;;2239   			not occur.  This may overflow but this doesn't matter. */
;;;2240   			xTimeToWake = xTickCount + xTicksToWait;
000046  4806              LDR      r0,|L18.96|
000048  6800              LDR      r0,[r0,#0]  ; xTickCount
00004a  1907              ADDS     r7,r0,r4
;;;2241   			prvAddCurrentTaskToDelayedList( xTimeToWake );
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L18.82|
;;;2242   		}
;;;2243   	}
;;;2244   	#else /* INCLUDE_vTaskSuspend */
;;;2245   	{
;;;2246   			/* Calculate the time at which the task should be woken if the event does
;;;2247   			not occur.  This may overflow but this doesn't matter. */
;;;2248   			xTimeToWake = xTickCount + xTicksToWait;
;;;2249   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2250   	}
;;;2251   	#endif /* INCLUDE_vTaskSuspend */
;;;2252   }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;2253   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      pxCurrentTCB
                  |L18.92|
                          DCD      xSuspendedTaskList
                  |L18.96|
                          DCD      xTickCount

                          AREA ||i.vTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  vTaskPriorityDisinherit PROC
;;;3180   
;;;3181   	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3182   	{
000002  4605              MOV      r5,r0
;;;3183   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3184   
;;;3185   		if( pxMutexHolder != NULL )
000006  b30d              CBZ      r5,|L19.76|
;;;3186   		{
;;;3187   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000008  6c61              LDR      r1,[r4,#0x44]
00000a  6ae0              LDR      r0,[r4,#0x2c]
00000c  4288              CMP      r0,r1
00000e  d01d              BEQ      |L19.76|
;;;3188   			{
;;;3189   				/* We must be the running task to be able to give the mutex back.
;;;3190   				Remove ourselves from the ready list we currently appear in. */
;;;3191   				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       uxListRemove
;;;3192   				{
;;;3193   					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;3194   				}
;;;3195   				else
;;;3196   				{
;;;3197   					mtCOVERAGE_TEST_MARKER();
;;;3198   				}
;;;3199   
;;;3200   				/* Disinherit the priority before adding the task into the new
;;;3201   				ready list. */
;;;3202   				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3203   				pxTCB->uxPriority = pxTCB->uxBasePriority;
000016  6c60              LDR      r0,[r4,#0x44]
000018  62e0              STR      r0,[r4,#0x2c]
;;;3204   
;;;3205   				/* Only reset the event list item value if the value is not
;;;3206   				being used for anything else. */
;;;3207   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  f0004000          AND      r0,r0,#0x80000000
000020  b918              CBNZ     r0,|L19.42|
;;;3208   				{
;;;3209   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  f1c00005          RSB      r0,r0,#5
000028  61a0              STR      r0,[r4,#0x18]
                  |L19.42|
;;;3210   				}
;;;3211   				else
;;;3212   				{
;;;3213   					mtCOVERAGE_TEST_MARKER();
;;;3214   				}
;;;3215   				prvAddTaskToReadyList( pxTCB );
00002a  4909              LDR      r1,|L19.80|
00002c  6ae0              LDR      r0,[r4,#0x2c]
00002e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000030  4288              CMP      r0,r1
000032  d902              BLS      |L19.58|
000034  4906              LDR      r1,|L19.80|
000036  6ae0              LDR      r0,[r4,#0x2c]
000038  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L19.58|
00003a  6ae1              LDR      r1,[r4,#0x2c]
00003c  eb010181          ADD      r1,r1,r1,LSL #2
000040  4a04              LDR      r2,|L19.84|
000042  eb020081          ADD      r0,r2,r1,LSL #2
000046  1d21              ADDS     r1,r4,#4
000048  f7fffffe          BL       vListInsertEnd
                  |L19.76|
;;;3216   			}
;;;3217   			else
;;;3218   			{
;;;3219   				mtCOVERAGE_TEST_MARKER();
;;;3220   			}
;;;3221   		}
;;;3222   		else
;;;3223   		{
;;;3224   			mtCOVERAGE_TEST_MARKER();
;;;3225   		}
;;;3226   	}
00004c  bd70              POP      {r4-r6,pc}
;;;3227   
                          ENDP

00004e  0000              DCW      0x0000
                  |L19.80|
                          DCD      uxTopReadyPriority
                  |L19.84|
                          DCD      pxReadyTasksLists

                          AREA ||i.vTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  vTaskPriorityInherit PROC
;;;3117   
;;;3118   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3119   	{
000002  4605              MOV      r5,r0
;;;3120   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3121   
;;;3122   		/* If the mutex was given back by an interrupt while the queue was
;;;3123   		locked then the mutex holder might now be NULL. */
;;;3124   		if( pxMutexHolder != NULL )
000006  2d00              CMP      r5,#0
000008  d039              BEQ      |L20.126|
;;;3125   		{
;;;3126   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  491d              LDR      r1,|L20.128|
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000010  6ac9              LDR      r1,[r1,#0x2c]
000012  4288              CMP      r0,r1
000014  d233              BCS      |L20.126|
;;;3127   			{
;;;3128   				/* Adjust the mutex holder state to account for its new
;;;3129   				priority.  Only reset the event list item value if the value is
;;;3130   				not	being used for anything else. */
;;;3131   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0004000          AND      r0,r0,#0x80000000
00001c  b928              CBNZ     r0,|L20.42|
;;;3132   				{
;;;3133   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001e  4818              LDR      r0,|L20.128|
000020  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000022  6ac0              LDR      r0,[r0,#0x2c]
000024  f1c00005          RSB      r0,r0,#5
000028  61a0              STR      r0,[r4,#0x18]
                  |L20.42|
;;;3134   				}
;;;3135   				else
;;;3136   				{
;;;3137   					mtCOVERAGE_TEST_MARKER();
;;;3138   				}
;;;3139   
;;;3140   				/* If the task being modified is in the ready state it will need to
;;;3141   				be moved into a new list. */
;;;3142   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
00002a  6ae1              LDR      r1,[r4,#0x2c]
00002c  eb010181          ADD      r1,r1,r1,LSL #2
000030  4a14              LDR      r2,|L20.132|
000032  eb020181          ADD      r1,r2,r1,LSL #2
000036  6960              LDR      r0,[r4,#0x14]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L20.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L20.66|
                  |L20.64|
000040  2000              MOVS     r0,#0
                  |L20.66|
000042  b1c0              CBZ      r0,|L20.118|
;;;3143   				{
;;;3144   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       uxListRemove
;;;3145   					{
;;;3146   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;3147   					}
;;;3148   					else
;;;3149   					{
;;;3150   						mtCOVERAGE_TEST_MARKER();
;;;3151   					}
;;;3152   
;;;3153   					/* Inherit the priority before being moved into the new list. */
;;;3154   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00004a  480d              LDR      r0,|L20.128|
00004c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00004e  6ac0              LDR      r0,[r0,#0x2c]
000050  62e0              STR      r0,[r4,#0x2c]
;;;3155   					prvAddTaskToReadyList( pxTCB );
000052  490d              LDR      r1,|L20.136|
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000058  4288              CMP      r0,r1
00005a  d902              BLS      |L20.98|
00005c  490a              LDR      r1,|L20.136|
00005e  6ae0              LDR      r0,[r4,#0x2c]
000060  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L20.98|
000062  6ae1              LDR      r1,[r4,#0x2c]
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  4a06              LDR      r2,|L20.132|
00006a  eb020081          ADD      r0,r2,r1,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
000074  e003              B        |L20.126|
                  |L20.118|
;;;3156   				}
;;;3157   				else
;;;3158   				{
;;;3159   					/* Just inherit the priority. */
;;;3160   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000076  4802              LDR      r0,|L20.128|
000078  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00007a  6ac0              LDR      r0,[r0,#0x2c]
00007c  62e0              STR      r0,[r4,#0x2c]
                  |L20.126|
;;;3161   				}
;;;3162   
;;;3163   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3164   			}
;;;3165   			else
;;;3166   			{
;;;3167   				mtCOVERAGE_TEST_MARKER();
;;;3168   			}
;;;3169   		}
;;;3170   		else
;;;3171   		{
;;;3172   			mtCOVERAGE_TEST_MARKER();
;;;3173   		}
;;;3174   	}
00007e  bd70              POP      {r4-r6,pc}
;;;3175   
                          ENDP

                  |L20.128|
                          DCD      pxCurrentTCB
                  |L20.132|
                          DCD      pxReadyTasksLists
                  |L20.136|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1008   
;;;1009   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1010   	{
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;1011   	TCB_t *pxTCB;
;;;1012   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1013   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1014   
;;;1015   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
00000c  2d05              CMP      r5,#5
00000e  d201              BCS      |L21.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L21.22|
                  |L21.20|
000014  2000              MOVS     r0,#0
                  |L21.22|
000016  b918              CBNZ     r0,|L21.32|
000018  f7fffffe          BL       ulPortSetInterruptMask
00001c  bf00              NOP      
                  |L21.30|
00001e  e7fe              B        |L21.30|
                  |L21.32|
;;;1016   
;;;1017   		/* Ensure the new priority is valid. */
;;;1018   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000020  2d05              CMP      r5,#5
000022  d300              BCC      |L21.38|
;;;1019   		{
;;;1020   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000024  2504              MOVS     r5,#4
                  |L21.38|
;;;1021   		}
;;;1022   		else
;;;1023   		{
;;;1024   			mtCOVERAGE_TEST_MARKER();
;;;1025   		}
;;;1026   
;;;1027   		taskENTER_CRITICAL();
000026  f7fffffe          BL       vPortEnterCritical
;;;1028   		{
;;;1029   			/* If null is passed in here then it is the priority of the calling
;;;1030   			task that is being changed. */
;;;1031   			pxTCB = prvGetTCBFromHandle( xTask );
00002a  b917              CBNZ     r7,|L21.50|
00002c  482a              LDR      r0,|L21.216|
00002e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000030  e000              B        |L21.52|
                  |L21.50|
000032  4638              MOV      r0,r7
                  |L21.52|
000034  4604              MOV      r4,r0
;;;1032   
;;;1033   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1034   
;;;1035   			#if ( configUSE_MUTEXES == 1 )
;;;1036   			{
;;;1037   				uxCurrentBasePriority = pxTCB->uxBasePriority;
000036  6c66              LDR      r6,[r4,#0x44]
;;;1038   			}
;;;1039   			#else
;;;1040   			{
;;;1041   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1042   			}
;;;1043   			#endif
;;;1044   
;;;1045   			if( uxCurrentBasePriority != uxNewPriority )
000038  42ae              CMP      r6,r5
00003a  d048              BEQ      |L21.206|
;;;1046   			{
;;;1047   				/* The priority change may have readied a task of higher
;;;1048   				priority than the calling task. */
;;;1049   				if( uxNewPriority > uxCurrentBasePriority )
00003c  42b5              CMP      r5,r6
00003e  d90b              BLS      |L21.88|
;;;1050   				{
;;;1051   					if( pxTCB != pxCurrentTCB )
000040  4825              LDR      r0,|L21.216|
000042  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000044  4284              CMP      r4,r0
000046  d00d              BEQ      |L21.100|
;;;1052   					{
;;;1053   						/* The priority of a task other than the currently
;;;1054   						running task is being raised.  Is the priority being
;;;1055   						raised above that of the running task? */
;;;1056   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000048  4823              LDR      r0,|L21.216|
00004a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00004c  6ac0              LDR      r0,[r0,#0x2c]
00004e  42a8              CMP      r0,r5
000050  d808              BHI      |L21.100|
;;;1057   						{
;;;1058   							xYieldRequired = pdTRUE;
000052  f04f0901          MOV      r9,#1
000056  e005              B        |L21.100|
                  |L21.88|
;;;1059   						}
;;;1060   						else
;;;1061   						{
;;;1062   							mtCOVERAGE_TEST_MARKER();
;;;1063   						}
;;;1064   					}
;;;1065   					else
;;;1066   					{
;;;1067   						/* The priority of the running task is being raised,
;;;1068   						but the running task must already be the highest
;;;1069   						priority task able to run so no yield is required. */
;;;1070   					}
;;;1071   				}
;;;1072   				else if( pxTCB == pxCurrentTCB )
000058  481f              LDR      r0,|L21.216|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  4284              CMP      r4,r0
00005e  d101              BNE      |L21.100|
;;;1073   				{
;;;1074   					/* Setting the priority of the running task down means
;;;1075   					there may now be another task of higher priority that
;;;1076   					is ready to execute. */
;;;1077   					xYieldRequired = pdTRUE;
000060  f04f0901          MOV      r9,#1
                  |L21.100|
;;;1078   				}
;;;1079   				else
;;;1080   				{
;;;1081   					/* Setting the priority of any other task down does not
;;;1082   					require a yield as the running task must be above the
;;;1083   					new priority of the task being modified. */
;;;1084   				}
;;;1085   
;;;1086   				/* Remember the ready list the task might be referenced from
;;;1087   				before its uxPriority member is changed so the
;;;1088   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1089   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000064  f8d4802c          LDR      r8,[r4,#0x2c]
;;;1090   
;;;1091   				#if ( configUSE_MUTEXES == 1 )
;;;1092   				{
;;;1093   					/* Only change the priority being used if the task is not
;;;1094   					currently using an inherited priority. */
;;;1095   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000068  6ae1              LDR      r1,[r4,#0x2c]
00006a  6c60              LDR      r0,[r4,#0x44]
00006c  4288              CMP      r0,r1
00006e  d100              BNE      |L21.114|
;;;1096   					{
;;;1097   						pxTCB->uxPriority = uxNewPriority;
000070  62e5              STR      r5,[r4,#0x2c]
                  |L21.114|
;;;1098   					}
;;;1099   					else
;;;1100   					{
;;;1101   						mtCOVERAGE_TEST_MARKER();
;;;1102   					}
;;;1103   
;;;1104   					/* The base priority gets set whatever. */
;;;1105   					pxTCB->uxBasePriority = uxNewPriority;
000072  6465              STR      r5,[r4,#0x44]
;;;1106   				}
;;;1107   				#else
;;;1108   				{
;;;1109   					pxTCB->uxPriority = uxNewPriority;
;;;1110   				}
;;;1111   				#endif
;;;1112   
;;;1113   				/* Only reset the event list item value if the value is not
;;;1114   				being used for anything else. */
;;;1115   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000074  69a0              LDR      r0,[r4,#0x18]
000076  f0004000          AND      r0,r0,#0x80000000
00007a  b910              CBNZ     r0,|L21.130|
;;;1116   				{
;;;1117   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00007c  f1c50005          RSB      r0,r5,#5
000080  61a0              STR      r0,[r4,#0x18]
                  |L21.130|
;;;1118   				}
;;;1119   				else
;;;1120   				{
;;;1121   					mtCOVERAGE_TEST_MARKER();
;;;1122   				}
;;;1123   
;;;1124   				/* If the task is in the blocked or suspended list we need do
;;;1125   				nothing more than change it's priority variable. However, if
;;;1126   				the task is in a ready list it needs to be removed and placed
;;;1127   				in the list appropriate to its new priority. */
;;;1128   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000082  eb080188          ADD      r1,r8,r8,LSL #2
000086  4a15              LDR      r2,|L21.220|
000088  eb020181          ADD      r1,r2,r1,LSL #2
00008c  6960              LDR      r0,[r4,#0x14]
00008e  4288              CMP      r0,r1
000090  d101              BNE      |L21.150|
000092  2001              MOVS     r0,#1
000094  e000              B        |L21.152|
                  |L21.150|
000096  2000              MOVS     r0,#0
                  |L21.152|
000098  b198              CBZ      r0,|L21.194|
;;;1129   				{
;;;1130   					/* The task is currently in its ready list - remove before adding
;;;1131   					it to it's new ready list.  As we are in a critical section we
;;;1132   					can do this even if the scheduler is suspended. */
;;;1133   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00009a  1d20              ADDS     r0,r4,#4
00009c  f7fffffe          BL       uxListRemove
;;;1134   					{
;;;1135   						/* It is known that the task is in its ready list so
;;;1136   						there is no need to check again and the port level
;;;1137   						reset macro can be called directly. */
;;;1138   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1139   					}
;;;1140   					else
;;;1141   					{
;;;1142   						mtCOVERAGE_TEST_MARKER();
;;;1143   					}
;;;1144   					prvAddTaskToReadyList( pxTCB );
0000a0  490f              LDR      r1,|L21.224|
0000a2  6ae0              LDR      r0,[r4,#0x2c]
0000a4  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000a6  4288              CMP      r0,r1
0000a8  d902              BLS      |L21.176|
0000aa  490d              LDR      r1,|L21.224|
0000ac  6ae0              LDR      r0,[r4,#0x2c]
0000ae  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L21.176|
0000b0  6ae1              LDR      r1,[r4,#0x2c]
0000b2  eb010181          ADD      r1,r1,r1,LSL #2
0000b6  4a09              LDR      r2,|L21.220|
0000b8  eb020081          ADD      r0,r2,r1,LSL #2
0000bc  1d21              ADDS     r1,r4,#4
0000be  f7fffffe          BL       vListInsertEnd
                  |L21.194|
;;;1145   				}
;;;1146   				else
;;;1147   				{
;;;1148   					mtCOVERAGE_TEST_MARKER();
;;;1149   				}
;;;1150   
;;;1151   				if( xYieldRequired == pdTRUE )
0000c2  f1b90f01          CMP      r9,#1
0000c6  d101              BNE      |L21.204|
;;;1152   				{
;;;1153   					taskYIELD_IF_USING_PREEMPTION();
0000c8  f7fffffe          BL       vPortYield
                  |L21.204|
;;;1154   				}
;;;1155   				else
;;;1156   				{
;;;1157   					mtCOVERAGE_TEST_MARKER();
;;;1158   				}
;;;1159   
;;;1160   				/* Remove compiler warning about unused variables when the port
;;;1161   				optimised task selection is not being used. */
;;;1162   				( void ) uxPriorityUsedOnEntry;
0000cc  bf00              NOP      
                  |L21.206|
;;;1163   			}
;;;1164   		}
;;;1165   		taskEXIT_CRITICAL();
0000ce  f7fffffe          BL       vPortExitCritical
;;;1166   	}
0000d2  e8bd87f0          POP      {r4-r10,pc}
;;;1167   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L21.216|
                          DCD      pxCurrentTCB
                  |L21.220|
                          DCD      pxReadyTasksLists
                  |L21.224|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1303   
;;;1304   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1305   	{
000002  4605              MOV      r5,r0
;;;1306   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000004  462c              MOV      r4,r5
;;;1307   
;;;1308   		/* It does not make sense to resume the calling task. */
;;;1309   		configASSERT( xTaskToResume );
000006  b91d              CBNZ     r5,|L22.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L22.14|
00000e  e7fe              B        |L22.14|
                  |L22.16|
;;;1310   
;;;1311   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1312   		currently executing task. */
;;;1313   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000010  b344              CBZ      r4,|L22.100|
000012  4815              LDR      r0,|L22.104|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  4284              CMP      r4,r0
000018  d024              BEQ      |L22.100|
;;;1314   		{
;;;1315   			taskENTER_CRITICAL();
00001a  f7fffffe          BL       vPortEnterCritical
;;;1316   			{
;;;1317   				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       xTaskIsTaskSuspended
000024  2801              CMP      r0,#1
000026  d11b              BNE      |L22.96|
;;;1318   				{
;;;1319   					traceTASK_RESUME( pxTCB );
;;;1320   
;;;1321   					/* As we are in a critical section we can access the ready
;;;1322   					lists even if the scheduler is suspended. */
;;;1323   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
000028  1d20              ADDS     r0,r4,#4
00002a  f7fffffe          BL       uxListRemove
;;;1324   					prvAddTaskToReadyList( pxTCB );
00002e  490f              LDR      r1,|L22.108|
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000034  4288              CMP      r0,r1
000036  d902              BLS      |L22.62|
000038  490c              LDR      r1,|L22.108|
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L22.62|
00003e  6ae1              LDR      r1,[r4,#0x2c]
000040  eb010181          ADD      r1,r1,r1,LSL #2
000044  4a0a              LDR      r2,|L22.112|
000046  eb020081          ADD      r0,r2,r1,LSL #2
00004a  1d21              ADDS     r1,r4,#4
00004c  f7fffffe          BL       vListInsertEnd
;;;1325   
;;;1326   					/* We may have just resumed a higher priority task. */
;;;1327   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000050  4905              LDR      r1,|L22.104|
000052  6ae0              LDR      r0,[r4,#0x2c]
000054  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000056  6ac9              LDR      r1,[r1,#0x2c]
000058  4288              CMP      r0,r1
00005a  d301              BCC      |L22.96|
;;;1328   					{
;;;1329   						/* This yield may not cause the task just resumed to run,
;;;1330   						but will leave the lists in the correct state for the
;;;1331   						next yield. */
;;;1332   						taskYIELD_IF_USING_PREEMPTION();
00005c  f7fffffe          BL       vPortYield
                  |L22.96|
;;;1333   					}
;;;1334   					else
;;;1335   					{
;;;1336   						mtCOVERAGE_TEST_MARKER();
;;;1337   					}
;;;1338   				}
;;;1339   				else
;;;1340   				{
;;;1341   					mtCOVERAGE_TEST_MARKER();
;;;1342   				}
;;;1343   			}
;;;1344   			taskEXIT_CRITICAL();
000060  f7fffffe          BL       vPortExitCritical
                  |L22.100|
;;;1345   		}
;;;1346   		else
;;;1347   		{
;;;1348   			mtCOVERAGE_TEST_MARKER();
;;;1349   		}
;;;1350   	}
000064  bd70              POP      {r4-r6,pc}
;;;1351   
                          ENDP

000066  0000              DCW      0x0000
                  |L22.104|
                          DCD      pxCurrentTCB
                  |L22.108|
                          DCD      uxTopReadyPriority
                  |L22.112|
                          DCD      pxReadyTasksLists

                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;2404   
;;;2405   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;2406   {
000002  4604              MOV      r4,r0
;;;2407   	configASSERT( pxTimeOut );
000004  b91c              CBNZ     r4,|L23.14|
000006  f7fffffe          BL       ulPortSetInterruptMask
00000a  bf00              NOP      
                  |L23.12|
00000c  e7fe              B        |L23.12|
                  |L23.14|
;;;2408   	pxTimeOut->xOverflowCount = xNumOfOverflows;
00000e  4803              LDR      r0,|L23.28|
000010  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000012  6020              STR      r0,[r4,#0]
;;;2409   	pxTimeOut->xTimeOnEntering = xTickCount;
000014  4802              LDR      r0,|L23.32|
000016  6800              LDR      r0,[r0,#0]  ; xTickCount
000018  6060              STR      r0,[r4,#4]
;;;2410   }
00001a  bd10              POP      {r4,pc}
;;;2411   /*-----------------------------------------------------------*/
                          ENDP

                  |L23.28|
                          DCD      xNumOfOverflows
                  |L23.32|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1424   
;;;1425   void vTaskStartScheduler( void )
000000  b51f              PUSH     {r0-r4,lr}
;;;1426   {
;;;1427   BaseType_t xReturn;
;;;1428   
;;;1429   	/* Add the idle task at the lowest priority. */
;;;1430   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1431   	{
;;;1432   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1433   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1434   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1435   	}
;;;1436   	#else
;;;1437   	{
;;;1438   		/* Create the idle task without storing its handle. */
;;;1439   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
000008  9002              STR      r0,[sp,#8]
00000a  4603              MOV      r3,r0
00000c  2280              MOVS     r2,#0x80
00000e  a10c              ADR      r1,|L24.64|
000010  9003              STR      r0,[sp,#0xc]
000012  480d              LDR      r0,|L24.72|
000014  f7fffffe          BL       xTaskGenericCreate
000018  4604              MOV      r4,r0
;;;1440   	}
;;;1441   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1442   
;;;1443   	#if ( configUSE_TIMERS == 1 )
;;;1444   	{
;;;1445   		if( xReturn == pdPASS )
;;;1446   		{
;;;1447   			xReturn = xTimerCreateTimerTask();
;;;1448   		}
;;;1449   		else
;;;1450   		{
;;;1451   			mtCOVERAGE_TEST_MARKER();
;;;1452   		}
;;;1453   	}
;;;1454   	#endif /* configUSE_TIMERS */
;;;1455   
;;;1456   	if( xReturn == pdPASS )
00001a  2c01              CMP      r4,#1
00001c  d10a              BNE      |L24.52|
;;;1457   	{
;;;1458   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1459   		before or during the call to xPortStartScheduler().  The stacks of
;;;1460   		the created tasks contain a status word with interrupts switched on
;;;1461   		so interrupts will automatically get re-enabled when the first task
;;;1462   		starts to run. */
;;;1463   		portDISABLE_INTERRUPTS();
00001e  f7fffffe          BL       ulPortSetInterruptMask
;;;1464   
;;;1465   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1466   		{
;;;1467   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1468   			structure specific to the task that will run first. */
;;;1469   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1470   		}
;;;1471   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1472   
;;;1473   		xSchedulerRunning = pdTRUE;
000022  2001              MOVS     r0,#1
000024  4909              LDR      r1,|L24.76|
000026  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1474   		xTickCount = ( TickType_t ) 0U;
000028  2000              MOVS     r0,#0
00002a  4909              LDR      r1,|L24.80|
00002c  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1475   
;;;1476   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1477   		macro must be defined to configure the timer/counter used to generate
;;;1478   		the run time counter time base. */
;;;1479   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1480   
;;;1481   		/* Setting up the timer tick is hardware specific and thus in the
;;;1482   		portable interface. */
;;;1483   		if( xPortStartScheduler() != pdFALSE )
00002e  f7fffffe          BL       xPortStartScheduler
000032  e004              B        |L24.62|
                  |L24.52|
;;;1484   		{
;;;1485   			/* Should not reach here as if the scheduler is running the
;;;1486   			function will not return. */
;;;1487   		}
;;;1488   		else
;;;1489   		{
;;;1490   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1491   		}
;;;1492   	}
;;;1493   	else
;;;1494   	{
;;;1495   		/* This line will only be reached if the kernel could not be started,
;;;1496   		because there was not enough FreeRTOS heap to create the idle task
;;;1497   		or the timer task. */
;;;1498   		configASSERT( xReturn );
000034  b91c              CBNZ     r4,|L24.62|
000036  f7fffffe          BL       ulPortSetInterruptMask
00003a  bf00              NOP      
                  |L24.60|
00003c  e7fe              B        |L24.60|
                  |L24.62|
;;;1499   	}
;;;1500   }
00003e  bd1f              POP      {r0-r4,pc}
;;;1501   /*-----------------------------------------------------------*/
                          ENDP

                  |L24.64|
000040  49444c45          DCB      "IDLE",0
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
                  |L24.72|
                          DCD      prvIdleTask
                  |L24.76|
                          DCD      xSchedulerRunning
                  |L24.80|
                          DCD      xTickCount

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1172   
;;;1173   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1174   	{
000002  4605              MOV      r5,r0
;;;1175   	TCB_t *pxTCB;
;;;1176   
;;;1177   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1178   		{
;;;1179   			/* If null is passed in here then it is the running task that is
;;;1180   			being suspended. */
;;;1181   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L25.16|
00000a  481e              LDR      r0,|L25.132|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L25.18|
                  |L25.16|
000010  4628              MOV      r0,r5
                  |L25.18|
000012  4604              MOV      r4,r0
;;;1182   
;;;1183   			traceTASK_SUSPEND( pxTCB );
;;;1184   
;;;1185   			/* Remove task from the ready/delayed list and place in the
;;;1186   			suspended list. */
;;;1187   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;1188   			{
;;;1189   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1190   			}
;;;1191   			else
;;;1192   			{
;;;1193   				mtCOVERAGE_TEST_MARKER();
;;;1194   			}
;;;1195   
;;;1196   			/* Is the task waiting on an event also? */
;;;1197   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  b118              CBZ      r0,|L25.38|
;;;1198   			{
;;;1199   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       uxListRemove
                  |L25.38|
;;;1200   			}
;;;1201   			else
;;;1202   			{
;;;1203   				mtCOVERAGE_TEST_MARKER();
;;;1204   			}
;;;1205   
;;;1206   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4817              LDR      r0,|L25.136|
00002a  f7fffffe          BL       vListInsertEnd
;;;1207   		}
;;;1208   		taskEXIT_CRITICAL();
00002e  f7fffffe          BL       vPortExitCritical
;;;1209   
;;;1210   		if( pxTCB == pxCurrentTCB )
000032  4814              LDR      r0,|L25.132|
000034  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000036  4284              CMP      r4,r0
000038  d11d              BNE      |L25.118|
;;;1211   		{
;;;1212   			if( xSchedulerRunning != pdFALSE )
00003a  4814              LDR      r0,|L25.140|
00003c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00003e  b168              CBZ      r0,|L25.92|
;;;1213   			{
;;;1214   				/* The current task has just been suspended. */
;;;1215   				configASSERT( uxSchedulerSuspended == 0 );
000040  4813              LDR      r0,|L25.144|
000042  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000044  b908              CBNZ     r0,|L25.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L25.76|
                  |L25.74|
00004a  2000              MOVS     r0,#0
                  |L25.76|
00004c  b918              CBNZ     r0,|L25.86|
00004e  f7fffffe          BL       ulPortSetInterruptMask
000052  bf00              NOP      
                  |L25.84|
000054  e7fe              B        |L25.84|
                  |L25.86|
;;;1216   				portYIELD_WITHIN_API();
000056  f7fffffe          BL       vPortYield
00005a  e011              B        |L25.128|
                  |L25.92|
;;;1217   			}
;;;1218   			else
;;;1219   			{
;;;1220   				/* The scheduler is not running, but the task that was pointed
;;;1221   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1222   				must be adjusted to point to a different task. */
;;;1223   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
00005c  480a              LDR      r0,|L25.136|
00005e  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
000060  490c              LDR      r1,|L25.148|
000062  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000064  4288              CMP      r0,r1
000066  d103              BNE      |L25.112|
;;;1224   				{
;;;1225   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1226   					NULL so when the next task is created pxCurrentTCB will
;;;1227   					be set to point to it no matter what its relative priority
;;;1228   					is. */
;;;1229   					pxCurrentTCB = NULL;
000068  2000              MOVS     r0,#0
00006a  4906              LDR      r1,|L25.132|
00006c  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
00006e  e007              B        |L25.128|
                  |L25.112|
;;;1230   				}
;;;1231   				else
;;;1232   				{
;;;1233   					vTaskSwitchContext();
000070  f7fffffe          BL       vTaskSwitchContext
000074  e004              B        |L25.128|
                  |L25.118|
;;;1234   				}
;;;1235   			}
;;;1236   		}
;;;1237   		else
;;;1238   		{
;;;1239   			if( xSchedulerRunning != pdFALSE )
000076  4805              LDR      r0,|L25.140|
000078  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00007a  b108              CBZ      r0,|L25.128|
;;;1240   			{
;;;1241   				/* A task other than the currently running task was suspended,
;;;1242   				reset the next expected unblock time in case it referred to the
;;;1243   				task that is now in the Suspended state. */
;;;1244   				prvResetNextTaskUnblockTime();
00007c  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L25.128|
;;;1245   			}
;;;1246   			else
;;;1247   			{
;;;1248   				mtCOVERAGE_TEST_MARKER();
;;;1249   			}
;;;1250   		}
;;;1251   	}
000080  bd70              POP      {r4-r6,pc}
;;;1252   
                          ENDP

000082  0000              DCW      0x0000
                  |L25.132|
                          DCD      pxCurrentTCB
                  |L25.136|
                          DCD      xSuspendedTaskList
                  |L25.140|
                          DCD      xSchedulerRunning
                  |L25.144|
                          DCD      uxSchedulerSuspended
                  |L25.148|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1513   
;;;1514   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L26.12|
;;;1515   {
;;;1516   	/* A critical section is not required as the variable is of type
;;;1517   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1518   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1519   	http://goo.gl/wu4acr */
;;;1520   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L26.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1521   }
00000a  4770              BX       lr
;;;1522   /*----------------------------------------------------------*/
                          ENDP

                  |L26.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2082   
;;;2083   void vTaskSwitchContext( void )
000000  b510              PUSH     {r4,lr}
;;;2084   {
;;;2085   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  481e              LDR      r0,|L27.124|
000004  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000006  b118              CBZ      r0,|L27.16|
;;;2086   	{
;;;2087   		/* The scheduler is currently suspended - do not allow a context
;;;2088   		switch. */
;;;2089   		xYieldPending = pdTRUE;
000008  2001              MOVS     r0,#1
00000a  491d              LDR      r1,|L27.128|
00000c  6008              STR      r0,[r1,#0]  ; xYieldPending
00000e  e033              B        |L27.120|
                  |L27.16|
;;;2090   	}
;;;2091   	else
;;;2092   	{
;;;2093   		xYieldPending = pdFALSE;
000010  2000              MOVS     r0,#0
000012  491b              LDR      r1,|L27.128|
000014  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2094   		traceTASK_SWITCHED_OUT();
;;;2095   
;;;2096   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2097   		{
;;;2098   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2099   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2100   				#else
;;;2101   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2102   				#endif
;;;2103   
;;;2104   				/* Add the amount of time the task has been running to the
;;;2105   				accumulated	time so far.  The time the task started running was
;;;2106   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2107   				protection here	so count values are only valid until the timer
;;;2108   				overflows.  The guard against negative values is to protect
;;;2109   				against suspect run time stat counter implementations - which
;;;2110   				are provided by the application, not the kernel. */
;;;2111   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2112   				{
;;;2113   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2114   				}
;;;2115   				else
;;;2116   				{
;;;2117   					mtCOVERAGE_TEST_MARKER();
;;;2118   				}
;;;2119   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2120   		}
;;;2121   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2122   
;;;2123   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;2124   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;2125   
;;;2126   		taskSELECT_HIGHEST_PRIORITY_TASK();
000016  e00b              B        |L27.48|
                  |L27.24|
000018  481a              LDR      r0,|L27.132|
00001a  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
00001c  b918              CBNZ     r0,|L27.38|
00001e  f7fffffe          BL       ulPortSetInterruptMask
000022  bf00              NOP      
                  |L27.36|
000024  e7fe              B        |L27.36|
                  |L27.38|
000026  4817              LDR      r0,|L27.132|
000028  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
00002a  1e40              SUBS     r0,r0,#1
00002c  4915              LDR      r1,|L27.132|
00002e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L27.48|
000030  4814              LDR      r0,|L27.132|
000032  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
000034  eb000080          ADD      r0,r0,r0,LSL #2
000038  4913              LDR      r1,|L27.136|
00003a  f8510020          LDR      r0,[r1,r0,LSL #2]
00003e  b908              CBNZ     r0,|L27.68|
000040  2001              MOVS     r0,#1
000042  e000              B        |L27.70|
                  |L27.68|
000044  2000              MOVS     r0,#0
                  |L27.70|
000046  2800              CMP      r0,#0
000048  d1e6              BNE      |L27.24|
00004a  490e              LDR      r1,|L27.132|
00004c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00004e  eb010181          ADD      r1,r1,r1,LSL #2
000052  4a0d              LDR      r2,|L27.136|
000054  eb020081          ADD      r0,r2,r1,LSL #2
000058  6841              LDR      r1,[r0,#4]
00005a  6849              LDR      r1,[r1,#4]
00005c  6041              STR      r1,[r0,#4]
00005e  f1000108          ADD      r1,r0,#8
000062  6842              LDR      r2,[r0,#4]
000064  428a              CMP      r2,r1
000066  d102              BNE      |L27.110|
000068  6841              LDR      r1,[r0,#4]
00006a  6849              LDR      r1,[r1,#4]
00006c  6041              STR      r1,[r0,#4]
                  |L27.110|
00006e  6841              LDR      r1,[r0,#4]
000070  68c9              LDR      r1,[r1,#0xc]
000072  4a06              LDR      r2,|L27.140|
000074  6011              STR      r1,[r2,#0]  ; pxCurrentTCB
000076  bf00              NOP      
                  |L27.120|
;;;2127   
;;;2128   		traceTASK_SWITCHED_IN();
;;;2129   
;;;2130   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2131   		{
;;;2132   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2133   			structure specific to this task. */
;;;2134   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2135   		}
;;;2136   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2137   	}
;;;2138   }
000078  bd10              POP      {r4,pc}
;;;2139   /*-----------------------------------------------------------*/
                          ENDP

00007a  0000              DCW      0x0000
                  |L27.124|
                          DCD      uxSchedulerSuspended
                  |L27.128|
                          DCD      xYieldPending
                  |L27.132|
                          DCD      uxTopReadyPriority
                  |L27.136|
                          DCD      pxReadyTasksLists
                  |L27.140|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;2412   
;;;2413   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2414   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2415   BaseType_t xReturn;
;;;2416   
;;;2417   	configASSERT( pxTimeOut );
000008  b91c              CBNZ     r4,|L28.18|
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  bf00              NOP      
                  |L28.16|
000010  e7fe              B        |L28.16|
                  |L28.18|
;;;2418   	configASSERT( pxTicksToWait );
000012  b91d              CBNZ     r5,|L28.28|
000014  f7fffffe          BL       ulPortSetInterruptMask
000018  bf00              NOP      
                  |L28.26|
00001a  e7fe              B        |L28.26|
                  |L28.28|
;;;2419   
;;;2420   	taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;2421   	{
;;;2422   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2423   		const TickType_t xConstTickCount = xTickCount;
000020  4812              LDR      r0,|L28.108|
000022  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;2424   
;;;2425   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2426   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2427   			the maximum block time then the task should block indefinitely, and
;;;2428   			therefore never time out. */
;;;2429   			if( *pxTicksToWait == portMAX_DELAY )
000024  6828              LDR      r0,[r5,#0]
000026  1c40              ADDS     r0,r0,#1
000028  b908              CBNZ     r0,|L28.46|
;;;2430   			{
;;;2431   				xReturn = pdFALSE;
00002a  2600              MOVS     r6,#0
00002c  e019              B        |L28.98|
                  |L28.46|
;;;2432   			}
;;;2433   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2434   		#endif
;;;2435   
;;;2436   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00002e  4910              LDR      r1,|L28.112|
000030  6820              LDR      r0,[r4,#0]
000032  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000034  4288              CMP      r0,r1
000036  d004              BEQ      |L28.66|
000038  6860              LDR      r0,[r4,#4]
00003a  42b8              CMP      r0,r7
00003c  d801              BHI      |L28.66|
;;;2437   		{
;;;2438   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2439   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2440   			It must have wrapped all the way around and gone past us again. This
;;;2441   			passed since vTaskSetTimeout() was called. */
;;;2442   			xReturn = pdTRUE;
00003e  2601              MOVS     r6,#1
000040  e00f              B        |L28.98|
                  |L28.66|
;;;2443   		}
;;;2444   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
000042  6860              LDR      r0,[r4,#4]
000044  1a38              SUBS     r0,r7,r0
000046  6829              LDR      r1,[r5,#0]
000048  4288              CMP      r0,r1
00004a  d209              BCS      |L28.96|
;;;2445   		{
;;;2446   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2447   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
00004c  6828              LDR      r0,[r5,#0]
00004e  6861              LDR      r1,[r4,#4]
000050  1a79              SUBS     r1,r7,r1
000052  1a40              SUBS     r0,r0,r1
000054  6028              STR      r0,[r5,#0]
;;;2448   			vTaskSetTimeOutState( pxTimeOut );
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       vTaskSetTimeOutState
;;;2449   			xReturn = pdFALSE;
00005c  2600              MOVS     r6,#0
00005e  e000              B        |L28.98|
                  |L28.96|
;;;2450   		}
;;;2451   		else
;;;2452   		{
;;;2453   			xReturn = pdTRUE;
000060  2601              MOVS     r6,#1
                  |L28.98|
;;;2454   		}
;;;2455   	}
;;;2456   	taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
;;;2457   
;;;2458   	return xReturn;
000066  4630              MOV      r0,r6
;;;2459   }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;2460   /*-----------------------------------------------------------*/
                          ENDP

                  |L28.108|
                          DCD      xTickCount
                  |L28.112|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskGenericCreate||, CODE, READONLY, ALIGN=2

                  xTaskGenericCreate PROC
;;;495    
;;;496    BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;497    {
000004  b081              SUB      sp,sp,#4
000006  4680              MOV      r8,r0
000008  4616              MOV      r6,r2
00000a  469a              MOV      r10,r3
00000c  e9dd5b0e          LDRD     r5,r11,[sp,#0x38]
;;;498    BaseType_t xReturn;
;;;499    TCB_t * pxNewTCB;
;;;500    
;;;501    	configASSERT( pxTaskCode );
000010  f1b80f00          CMP      r8,#0
000014  d103              BNE      |L29.30|
000016  f7fffffe          BL       ulPortSetInterruptMask
00001a  bf00              NOP      
                  |L29.28|
00001c  e7fe              B        |L29.28|
                  |L29.30|
;;;502    	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
00001e  2d05              CMP      r5,#5
000020  d201              BCS      |L29.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L29.40|
                  |L29.38|
000026  2000              MOVS     r0,#0
                  |L29.40|
000028  b918              CBNZ     r0,|L29.50|
00002a  f7fffffe          BL       ulPortSetInterruptMask
00002e  bf00              NOP      
                  |L29.48|
000030  e7fe              B        |L29.48|
                  |L29.50|
;;;503    
;;;504    	/* Allocate the memory required by the TCB and stack for the new task,
;;;505    	checking that the allocation was successful. */
;;;506    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
000032  4630              MOV      r0,r6
000034  9910              LDR      r1,[sp,#0x40]
000036  f7fffffe          BL       prvAllocateTCBAndStack
00003a  4604              MOV      r4,r0
;;;507    
;;;508    	if( pxNewTCB != NULL )
00003c  2c00              CMP      r4,#0
00003e  d059              BEQ      |L29.244|
;;;509    	{
;;;510    		StackType_t *pxTopOfStack;
;;;511    
;;;512    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;513    			/* Should the task be created in privileged mode? */
;;;514    			BaseType_t xRunPrivileged;
;;;515    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;516    			{
;;;517    				xRunPrivileged = pdTRUE;
;;;518    			}
;;;519    			else
;;;520    			{
;;;521    				xRunPrivileged = pdFALSE;
;;;522    			}
;;;523    			uxPriority &= ~portPRIVILEGE_BIT;
;;;524    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;525    
;;;526    		/* Calculate the top of stack address.  This depends on whether the
;;;527    		stack grows from high memory to low (as per the 80x86) or vice versa.
;;;528    		portSTACK_GROWTH is used to make the result positive or negative as
;;;529    		required by the port. */
;;;530    		#if( portSTACK_GROWTH < 0 )
;;;531    		{
;;;532    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
000040  1e70              SUBS     r0,r6,#1
000042  6b21              LDR      r1,[r4,#0x30]
000044  eb010980          ADD      r9,r1,r0,LSL #2
;;;533    			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000048  f0290907          BIC      r9,r9,#7
;;;534    
;;;535    			/* Check the alignment of the calculated top of stack is correct. */
;;;536    			configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
00004c  f0090007          AND      r0,r9,#7
000050  b908              CBNZ     r0,|L29.86|
000052  2001              MOVS     r0,#1
000054  e000              B        |L29.88|
                  |L29.86|
000056  2000              MOVS     r0,#0
                  |L29.88|
000058  b918              CBNZ     r0,|L29.98|
00005a  f7fffffe          BL       ulPortSetInterruptMask
00005e  bf00              NOP      
                  |L29.96|
000060  e7fe              B        |L29.96|
                  |L29.98|
;;;537    		}
;;;538    		#else /* portSTACK_GROWTH */
;;;539    		{
;;;540    			pxTopOfStack = pxNewTCB->pxStack;
;;;541    
;;;542    			/* Check the alignment of the stack buffer is correct. */
;;;543    			configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;544    
;;;545    			/* If we want to use stack checking on architectures that use
;;;546    			a positive stack growth direction then we also need to store the
;;;547    			other extreme of the stack space. */
;;;548    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;549    		}
;;;550    		#endif /* portSTACK_GROWTH */
;;;551    
;;;552    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;553    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
000062  9600              STR      r6,[sp,#0]
000064  462a              MOV      r2,r5
000066  4620              MOV      r0,r4
000068  9b11              LDR      r3,[sp,#0x44]
00006a  9902              LDR      r1,[sp,#8]
00006c  f7fffffe          BL       prvInitialiseTCBVariables
;;;554    
;;;555    		/* Initialize the TCB stack to look as if the task was already running,
;;;556    		but had been interrupted by the scheduler.  The return address is set
;;;557    		to the start of the task function. Once the stack has been initialised
;;;558    		the	top of stack variable is updated. */
;;;559    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;560    		{
;;;561    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;562    		}
;;;563    		#else /* portUSING_MPU_WRAPPERS */
;;;564    		{
;;;565    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000070  4652              MOV      r2,r10
000072  4641              MOV      r1,r8
000074  4648              MOV      r0,r9
000076  f7fffffe          BL       pxPortInitialiseStack
00007a  6020              STR      r0,[r4,#0]
;;;566    		}
;;;567    		#endif /* portUSING_MPU_WRAPPERS */
;;;568    
;;;569    		if( ( void * ) pxCreatedTask != NULL )
00007c  f1bb0f00          CMP      r11,#0
000080  d001              BEQ      |L29.134|
;;;570    		{
;;;571    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;572    			task can use this as a handle to delete the task later if
;;;573    			required.*/
;;;574    			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000082  f8cb4000          STR      r4,[r11,#0]
                  |L29.134|
;;;575    		}
;;;576    		else
;;;577    		{
;;;578    			mtCOVERAGE_TEST_MARKER();
;;;579    		}
;;;580    
;;;581    		/* Ensure interrupts don't access the task lists while they are being
;;;582    		updated. */
;;;583    		taskENTER_CRITICAL();
000086  f7fffffe          BL       vPortEnterCritical
;;;584    		{
;;;585    			uxCurrentNumberOfTasks++;
00008a  4823              LDR      r0,|L29.280|
00008c  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00008e  1c40              ADDS     r0,r0,#1
000090  4921              LDR      r1,|L29.280|
000092  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;586    			if( pxCurrentTCB == NULL )
000094  4821              LDR      r0,|L29.284|
000096  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000098  b940              CBNZ     r0,|L29.172|
;;;587    			{
;;;588    				/* There are no other tasks, or all the other tasks are in
;;;589    				the suspended state - make this the current task. */
;;;590    				pxCurrentTCB =  pxNewTCB;
00009a  4820              LDR      r0,|L29.284|
00009c  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;591    
;;;592    				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00009e  4608              MOV      r0,r1
0000a0  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
0000a2  2801              CMP      r0,#1
0000a4  d10c              BNE      |L29.192|
;;;593    				{
;;;594    					/* This is the first task to be created so do the preliminary
;;;595    					initialisation required.  We will not recover if this call
;;;596    					fails, but we will report the failure. */
;;;597    					prvInitialiseTaskLists();
0000a6  f7fffffe          BL       prvInitialiseTaskLists
0000aa  e009              B        |L29.192|
                  |L29.172|
;;;598    				}
;;;599    				else
;;;600    				{
;;;601    					mtCOVERAGE_TEST_MARKER();
;;;602    				}
;;;603    			}
;;;604    			else
;;;605    			{
;;;606    				/* If the scheduler is not already running, make this task the
;;;607    				current task if it is the highest priority task to be created
;;;608    				so far. */
;;;609    				if( xSchedulerRunning == pdFALSE )
0000ac  481c              LDR      r0,|L29.288|
0000ae  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
0000b0  b930              CBNZ     r0,|L29.192|
;;;610    				{
;;;611    					if( pxCurrentTCB->uxPriority <= uxPriority )
0000b2  481a              LDR      r0,|L29.284|
0000b4  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000b6  6ac0              LDR      r0,[r0,#0x2c]
0000b8  42a8              CMP      r0,r5
0000ba  d801              BHI      |L29.192|
;;;612    					{
;;;613    						pxCurrentTCB = pxNewTCB;
0000bc  4817              LDR      r0,|L29.284|
0000be  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L29.192|
;;;614    					}
;;;615    					else
;;;616    					{
;;;617    						mtCOVERAGE_TEST_MARKER();
;;;618    					}
;;;619    				}
;;;620    				else
;;;621    				{
;;;622    					mtCOVERAGE_TEST_MARKER();
;;;623    				}
;;;624    			}
;;;625    
;;;626    			uxTaskNumber++;
0000c0  4818              LDR      r0,|L29.292|
0000c2  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
0000c4  1c40              ADDS     r0,r0,#1
0000c6  4917              LDR      r1,|L29.292|
0000c8  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;627    
;;;628    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;629    			{
;;;630    				/* Add a counter into the TCB for tracing only. */
;;;631    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;632    			}
;;;633    			#endif /* configUSE_TRACE_FACILITY */
;;;634    			traceTASK_CREATE( pxNewTCB );
;;;635    
;;;636    			prvAddTaskToReadyList( pxNewTCB );
0000ca  4917              LDR      r1,|L29.296|
0000cc  6ae0              LDR      r0,[r4,#0x2c]
0000ce  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000d0  4288              CMP      r0,r1
0000d2  d902              BLS      |L29.218|
0000d4  4914              LDR      r1,|L29.296|
0000d6  6ae0              LDR      r0,[r4,#0x2c]
0000d8  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L29.218|
0000da  6ae1              LDR      r1,[r4,#0x2c]
0000dc  eb010181          ADD      r1,r1,r1,LSL #2
0000e0  4a12              LDR      r2,|L29.300|
0000e2  eb020081          ADD      r0,r2,r1,LSL #2
0000e6  1d21              ADDS     r1,r4,#4
0000e8  f7fffffe          BL       vListInsertEnd
;;;637    
;;;638    			xReturn = pdPASS;
0000ec  2701              MOVS     r7,#1
;;;639    			portSETUP_TCB( pxNewTCB );
;;;640    		}
;;;641    		taskEXIT_CRITICAL();
0000ee  f7fffffe          BL       vPortExitCritical
;;;642    	}
0000f2  e001              B        |L29.248|
                  |L29.244|
;;;643    	else
;;;644    	{
;;;645    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
0000f4  f04f37ff          MOV      r7,#0xffffffff
                  |L29.248|
;;;646    		traceTASK_CREATE_FAILED();
;;;647    	}
;;;648    
;;;649    	if( xReturn == pdPASS )
0000f8  2f01              CMP      r7,#1
0000fa  d109              BNE      |L29.272|
;;;650    	{
;;;651    		if( xSchedulerRunning != pdFALSE )
0000fc  4808              LDR      r0,|L29.288|
0000fe  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000100  b130              CBZ      r0,|L29.272|
;;;652    		{
;;;653    			/* If the created task is of a higher priority than the current task
;;;654    			then it should run now. */
;;;655    			if( pxCurrentTCB->uxPriority < uxPriority )
000102  4806              LDR      r0,|L29.284|
000104  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000106  6ac0              LDR      r0,[r0,#0x2c]
000108  42a8              CMP      r0,r5
00010a  d201              BCS      |L29.272|
;;;656    			{
;;;657    				taskYIELD_IF_USING_PREEMPTION();
00010c  f7fffffe          BL       vPortYield
                  |L29.272|
;;;658    			}
;;;659    			else
;;;660    			{
;;;661    				mtCOVERAGE_TEST_MARKER();
;;;662    			}
;;;663    		}
;;;664    		else
;;;665    		{
;;;666    			mtCOVERAGE_TEST_MARKER();
;;;667    		}
;;;668    	}
;;;669    
;;;670    	return xReturn;
000110  4638              MOV      r0,r7
;;;671    }
000112  b005              ADD      sp,sp,#0x14
000114  e8bd8ff0          POP      {r4-r11,pc}
;;;672    /*-----------------------------------------------------------*/
                          ENDP

                  |L29.280|
                          DCD      uxCurrentNumberOfTasks
                  |L29.284|
                          DCD      pxCurrentTCB
                  |L29.288|
                          DCD      xSchedulerRunning
                  |L29.292|
                          DCD      uxTaskNumber
                  |L29.296|
                          DCD      uxTopReadyPriority
                  |L29.300|
                          DCD      pxReadyTasksLists

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3072   
;;;3073   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L30.8|
;;;3074   	{
;;;3075   	TaskHandle_t xReturn;
;;;3076   
;;;3077   		/* A critical section is not required as this is not called from
;;;3078   		an interrupt and the current TCB will always be the same for any
;;;3079   		individual execution thread. */
;;;3080   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3081   
;;;3082   		return xReturn;
;;;3083   	}
000004  4770              BX       lr
;;;3084   
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;1644   
;;;1645   TickType_t xTaskGetTickCount( void )
000000  b510              PUSH     {r4,lr}
;;;1646   {
;;;1647   TickType_t xTicks;
;;;1648   
;;;1649   	/* Critical section required if running on a 16 bit processor. */
;;;1650   	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;1651   	{
;;;1652   		xTicks = xTickCount;
000006  4804              LDR      r0,|L31.24|
000008  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;1653   		TickCounter =  xTickCount;
00000a  6800              LDR      r0,[r0,#0]  ; xTickCount
00000c  4903              LDR      r1,|L31.28|
00000e  6008              STR      r0,[r1,#0]  ; TickCounter
;;;1654   	}
;;;1655   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1656   
;;;1657   	return xTicks;
000014  4620              MOV      r0,r4
;;;1658   }
000016  bd10              POP      {r4,pc}
;;;1659   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.24|
                          DCD      xTickCount
                  |L31.28|
                          DCD      TickCounter

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;1660   
;;;1661   TickType_t xTaskGetTickCountFromISR( void )
000000  b570              PUSH     {r4-r6,lr}
;;;1662   {
;;;1663   TickType_t xReturn;
;;;1664   UBaseType_t uxSavedInterruptStatus;
;;;1665   
;;;1666   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1667   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1668   	above the maximum system call priority are kept permanently enabled, even
;;;1669   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1670   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1671   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1672   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1673   	assigned a priority above the configured maximum system call priority.
;;;1674   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1675   	that have been assigned a priority at or (logically) below the maximum
;;;1676   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1677   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1678   	More information (albeit Cortex-M specific) is provided on the following
;;;1679   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1680   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000002  f7fffffe          BL       vPortValidateInterruptPriority
;;;1681   
;;;1682   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000006  f7fffffe          BL       ulPortSetInterruptMask
00000a  4605              MOV      r5,r0
;;;1683   	xReturn = xTickCount;
00000c  4803              LDR      r0,|L32.28|
00000e  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;1684   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       vPortClearInterruptMask
;;;1685   
;;;1686   	return xReturn;
000016  4620              MOV      r0,r4
;;;1687   }
000018  bd70              POP      {r4-r6,pc}
;;;1688   /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L32.28|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;1818   
;;;1819   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1820   {
;;;1821   TCB_t * pxTCB;
;;;1822   TickType_t xItemValue;
;;;1823   BaseType_t xSwitchRequired = pdFALSE;
000004  f04f0800          MOV      r8,#0
;;;1824   
;;;1825   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1826   	Increments the tick then checks to see if the new tick value will cause any
;;;1827   	tasks to be unblocked. */
;;;1828   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1829   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  4841              LDR      r0,|L33.272|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  2800              CMP      r0,#0
00000e  d171              BNE      |L33.244|
;;;1830   	{
;;;1831   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1832   		delayed lists if it wraps to 0. */
;;;1833   		++xTickCount;
000010  4840              LDR      r0,|L33.276|
000012  6800              LDR      r0,[r0,#0]  ; xTickCount
000014  1c40              ADDS     r0,r0,#1
000016  493f              LDR      r1,|L33.276|
000018  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1834   
;;;1835   		{
;;;1836   			/* Minor optimisation.  The tick count cannot change in this
;;;1837   			block. */
;;;1838   			const TickType_t xConstTickCount = xTickCount;
00001a  4608              MOV      r0,r1
00001c  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1839   
;;;1840   			if( xConstTickCount == ( TickType_t ) 0U )
00001e  b9de              CBNZ     r6,|L33.88|
;;;1841   			{
;;;1842   				taskSWITCH_DELAYED_LISTS();
000020  483d              LDR      r0,|L33.280|
000022  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000024  6800              LDR      r0,[r0,#0]
000026  b908              CBNZ     r0,|L33.44|
000028  2001              MOVS     r0,#1
00002a  e000              B        |L33.46|
                  |L33.44|
00002c  2000              MOVS     r0,#0
                  |L33.46|
00002e  b918              CBNZ     r0,|L33.56|
000030  f7fffffe          BL       ulPortSetInterruptMask
000034  bf00              NOP      
                  |L33.54|
000036  e7fe              B        |L33.54|
                  |L33.56|
000038  4837              LDR      r0,|L33.280|
00003a  6807              LDR      r7,[r0,#0]  ; pxDelayedTaskList
00003c  4837              LDR      r0,|L33.284|
00003e  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000040  4935              LDR      r1,|L33.280|
000042  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
000044  4835              LDR      r0,|L33.284|
000046  6007              STR      r7,[r0,#0]  ; pxOverflowDelayedTaskList
000048  4835              LDR      r0,|L33.288|
00004a  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
00004c  1c40              ADDS     r0,r0,#1
00004e  4934              LDR      r1,|L33.288|
000050  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
000052  f7fffffe          BL       prvResetNextTaskUnblockTime
000056  bf00              NOP      
                  |L33.88|
;;;1843   			}
;;;1844   			else
;;;1845   			{
;;;1846   				mtCOVERAGE_TEST_MARKER();
;;;1847   			}
;;;1848   
;;;1849   			/* See if this tick has made a timeout expire.  Tasks are stored in
;;;1850   			the	queue in the order of their wake time - meaning once one task
;;;1851   			has been found whose block time has not expired there is no need to
;;;1852   			look any further	down the list. */
;;;1853   			if( xConstTickCount >= xNextTaskUnblockTime )
000058  4832              LDR      r0,|L33.292|
00005a  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
00005c  4286              CMP      r6,r0
00005e  d33b              BCC      |L33.216|
;;;1854   			{
;;;1855   				for( ;; )
000060  bf00              NOP      
                  |L33.98|
;;;1856   				{
;;;1857   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000062  482d              LDR      r0,|L33.280|
000064  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000066  6800              LDR      r0,[r0,#0]
000068  b908              CBNZ     r0,|L33.110|
00006a  2001              MOVS     r0,#1
00006c  e000              B        |L33.112|
                  |L33.110|
00006e  2000              MOVS     r0,#0
                  |L33.112|
000070  b120              CBZ      r0,|L33.124|
;;;1858   					{
;;;1859   						/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;1860   						to the maximum possible value so it is extremely
;;;1861   						unlikely that the
;;;1862   						if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1863   						next time through. */
;;;1864   						xNextTaskUnblockTime = portMAX_DELAY;
000072  f04f30ff          MOV      r0,#0xffffffff
000076  492b              LDR      r1,|L33.292|
000078  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1865   						break;
00007a  e02c              B        |L33.214|
                  |L33.124|
;;;1866   					}
;;;1867   					else
;;;1868   					{
;;;1869   						/* The delayed list is not empty, get the value of the
;;;1870   						item at the head of the delayed list.  This is the time
;;;1871   						at which the task at the head of the delayed list must
;;;1872   						be removed from the Blocked state. */
;;;1873   						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00007c  4826              LDR      r0,|L33.280|
00007e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000080  68c0              LDR      r0,[r0,#0xc]
000082  68c4              LDR      r4,[r0,#0xc]
;;;1874   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
000084  6865              LDR      r5,[r4,#4]
;;;1875   
;;;1876   						if( xConstTickCount < xItemValue )
000086  42ae              CMP      r6,r5
000088  d202              BCS      |L33.144|
;;;1877   						{
;;;1878   							/* It is not time to unblock this item yet, but the
;;;1879   							item value is the time at which the task at the head
;;;1880   							of the blocked list must be removed from the Blocked
;;;1881   							state -	so record the item value in
;;;1882   							xNextTaskUnblockTime. */
;;;1883   							xNextTaskUnblockTime = xItemValue;
00008a  4826              LDR      r0,|L33.292|
00008c  6005              STR      r5,[r0,#0]  ; xNextTaskUnblockTime
;;;1884   							break;
00008e  e022              B        |L33.214|
                  |L33.144|
;;;1885   						}
;;;1886   						else
;;;1887   						{
;;;1888   							mtCOVERAGE_TEST_MARKER();
;;;1889   						}
;;;1890   
;;;1891   						/* It is time to remove the item from the Blocked state. */
;;;1892   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000090  1d20              ADDS     r0,r4,#4
000092  f7fffffe          BL       uxListRemove
;;;1893   
;;;1894   						/* Is the task waiting on an event also?  If so remove
;;;1895   						it from the event list. */
;;;1896   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000096  6aa0              LDR      r0,[r4,#0x28]
000098  b118              CBZ      r0,|L33.162|
;;;1897   						{
;;;1898   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00009a  f1040018          ADD      r0,r4,#0x18
00009e  f7fffffe          BL       uxListRemove
                  |L33.162|
;;;1899   						}
;;;1900   						else
;;;1901   						{
;;;1902   							mtCOVERAGE_TEST_MARKER();
;;;1903   						}
;;;1904   
;;;1905   						/* Place the unblocked task into the appropriate ready
;;;1906   						list. */
;;;1907   						prvAddTaskToReadyList( pxTCB );
0000a2  4921              LDR      r1,|L33.296|
0000a4  6ae0              LDR      r0,[r4,#0x2c]
0000a6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000a8  4288              CMP      r0,r1
0000aa  d902              BLS      |L33.178|
0000ac  491e              LDR      r1,|L33.296|
0000ae  6ae0              LDR      r0,[r4,#0x2c]
0000b0  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L33.178|
0000b2  6ae1              LDR      r1,[r4,#0x2c]
0000b4  eb010181          ADD      r1,r1,r1,LSL #2
0000b8  4a1c              LDR      r2,|L33.300|
0000ba  eb020081          ADD      r0,r2,r1,LSL #2
0000be  1d21              ADDS     r1,r4,#4
0000c0  f7fffffe          BL       vListInsertEnd
;;;1908   
;;;1909   						/* A task being unblocked cannot cause an immediate
;;;1910   						context switch if preemption is turned off. */
;;;1911   						#if (  configUSE_PREEMPTION == 1 )
;;;1912   						{
;;;1913   							/* Preemption is on, but a context switch should
;;;1914   							only be performed if the unblocked task has a
;;;1915   							priority that is equal to or higher than the
;;;1916   							currently executing task. */
;;;1917   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000c4  491a              LDR      r1,|L33.304|
0000c6  6ae0              LDR      r0,[r4,#0x2c]
0000c8  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000ca  6ac9              LDR      r1,[r1,#0x2c]
0000cc  4288              CMP      r0,r1
0000ce  d3c8              BCC      |L33.98|
;;;1918   							{
;;;1919   								xSwitchRequired = pdTRUE;
0000d0  f04f0801          MOV      r8,#1
0000d4  e7c5              B        |L33.98|
                  |L33.214|
0000d6  bf00              NOP                            ;1865
                  |L33.216|
;;;1920   							}
;;;1921   							else
;;;1922   							{
;;;1923   								mtCOVERAGE_TEST_MARKER();
;;;1924   							}
;;;1925   						}
;;;1926   						#endif /* configUSE_PREEMPTION */
;;;1927   					}
;;;1928   				}
;;;1929   			}
;;;1930   		}
;;;1931   
;;;1932   		/* Tasks of equal priority to the currently running task will share
;;;1933   		processing time (time slice) if preemption is on, and the application
;;;1934   		writer has not explicitly turned time slicing off. */
;;;1935   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;1936   		{
;;;1937   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0000d8  4815              LDR      r0,|L33.304|
0000da  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000dc  6ac0              LDR      r0,[r0,#0x2c]
0000de  eb000080          ADD      r0,r0,r0,LSL #2
0000e2  4912              LDR      r1,|L33.300|
0000e4  f8510020          LDR      r0,[r1,r0,LSL #2]
0000e8  2801              CMP      r0,#1
0000ea  d908              BLS      |L33.254|
;;;1938   			{
;;;1939   				xSwitchRequired = pdTRUE;
0000ec  f04f0801          MOV      r8,#1
0000f0  e005              B        |L33.254|
0000f2  e7ff              B        |L33.244|
                  |L33.244|
;;;1940   			}
;;;1941   			else
;;;1942   			{
;;;1943   				mtCOVERAGE_TEST_MARKER();
;;;1944   			}
;;;1945   		}
;;;1946   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;1947   
;;;1948   		#if ( configUSE_TICK_HOOK == 1 )
;;;1949   		{
;;;1950   			/* Guard against the tick hook being called when the pended tick
;;;1951   			count is being unwound (when the scheduler is being unlocked). */
;;;1952   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;1953   			{
;;;1954   				vApplicationTickHook();
;;;1955   			}
;;;1956   			else
;;;1957   			{
;;;1958   				mtCOVERAGE_TEST_MARKER();
;;;1959   			}
;;;1960   		}
;;;1961   		#endif /* configUSE_TICK_HOOK */
;;;1962   	}
;;;1963   	else
;;;1964   	{
;;;1965   		++uxPendedTicks;
0000f4  480f              LDR      r0,|L33.308|
0000f6  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0000f8  1c40              ADDS     r0,r0,#1
0000fa  490e              LDR      r1,|L33.308|
0000fc  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L33.254|
;;;1966   
;;;1967   		/* The tick hook gets called at regular intervals, even if the
;;;1968   		scheduler is locked. */
;;;1969   		#if ( configUSE_TICK_HOOK == 1 )
;;;1970   		{
;;;1971   			vApplicationTickHook();
;;;1972   		}
;;;1973   		#endif
;;;1974   	}
;;;1975   
;;;1976   	#if ( configUSE_PREEMPTION == 1 )
;;;1977   	{
;;;1978   		if( xYieldPending != pdFALSE )
0000fe  480e              LDR      r0,|L33.312|
000100  6800              LDR      r0,[r0,#0]  ; xYieldPending
000102  b108              CBZ      r0,|L33.264|
;;;1979   		{
;;;1980   			xSwitchRequired = pdTRUE;
000104  f04f0801          MOV      r8,#1
                  |L33.264|
;;;1981   		}
;;;1982   		else
;;;1983   		{
;;;1984   			mtCOVERAGE_TEST_MARKER();
;;;1985   		}
;;;1986   	}
;;;1987   	#endif /* configUSE_PREEMPTION */
;;;1988   
;;;1989   	return xSwitchRequired;
000108  4640              MOV      r0,r8
;;;1990   }
00010a  e8bd81f0          POP      {r4-r8,pc}
;;;1991   /*-----------------------------------------------------------*/
                          ENDP

00010e  0000              DCW      0x0000
                  |L33.272|
                          DCD      uxSchedulerSuspended
                  |L33.276|
                          DCD      xTickCount
                  |L33.280|
                          DCD      pxDelayedTaskList
                  |L33.284|
                          DCD      pxOverflowDelayedTaskList
                  |L33.288|
                          DCD      xNumOfOverflows
                  |L33.292|
                          DCD      xNextTaskUnblockTime
                  |L33.296|
                          DCD      uxTopReadyPriority
                  |L33.300|
                          DCD      pxReadyTasksLists
                  |L33.304|
                          DCD      pxCurrentTCB
                  |L33.308|
                          DCD      uxPendedTicks
                  |L33.312|
                          DCD      xYieldPending

                          AREA ||i.xTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  xTaskIsTaskSuspended PROC
;;;1257   
;;;1258   	BaseType_t xTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1259   	{
000002  4605              MOV      r5,r0
;;;1260   	BaseType_t xReturn = pdFALSE;
000004  2600              MOVS     r6,#0
;;;1261   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000006  462c              MOV      r4,r5
;;;1262   
;;;1263   		/* It does not make sense to check if the calling task is suspended. */
;;;1264   		configASSERT( xTask );
000008  b91d              CBNZ     r5,|L34.18|
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  bf00              NOP      
                  |L34.16|
000010  e7fe              B        |L34.16|
                  |L34.18|
;;;1265   
;;;1266   		/* Is the task we are attempting to resume actually in the
;;;1267   		suspended list? */
;;;1268   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
000012  490c              LDR      r1,|L34.68|
000014  6960              LDR      r0,[r4,#0x14]
000016  4288              CMP      r0,r1
000018  d101              BNE      |L34.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L34.32|
                  |L34.30|
00001e  2000              MOVS     r0,#0
                  |L34.32|
000020  b170              CBZ      r0,|L34.64|
;;;1269   		{
;;;1270   			/* Has the task already been resumed from within an ISR? */
;;;1271   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000022  4909              LDR      r1,|L34.72|
000024  6aa0              LDR      r0,[r4,#0x28]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L34.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L34.48|
                  |L34.46|
00002e  2000              MOVS     r0,#0
                  |L34.48|
000030  b930              CBNZ     r0,|L34.64|
;;;1272   			{
;;;1273   				/* Is it in the suspended list because it is in the
;;;1274   				Suspended state?  It is possible to be in the suspended
;;;1275   				list because it is blocked on a task with no timeout
;;;1276   				specified. */
;;;1277   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000032  6aa0              LDR      r0,[r4,#0x28]
000034  b908              CBNZ     r0,|L34.58|
000036  2001              MOVS     r0,#1
000038  e000              B        |L34.60|
                  |L34.58|
00003a  2000              MOVS     r0,#0
                  |L34.60|
00003c  b100              CBZ      r0,|L34.64|
;;;1278   				{
;;;1279   					xReturn = pdTRUE;
00003e  2601              MOVS     r6,#1
                  |L34.64|
;;;1280   				}
;;;1281   				else
;;;1282   				{
;;;1283   					mtCOVERAGE_TEST_MARKER();
;;;1284   				}
;;;1285   			}
;;;1286   			else
;;;1287   			{
;;;1288   				mtCOVERAGE_TEST_MARKER();
;;;1289   			}
;;;1290   		}
;;;1291   		else
;;;1292   		{
;;;1293   			mtCOVERAGE_TEST_MARKER();
;;;1294   		}
;;;1295   
;;;1296   		return xReturn;
000040  4630              MOV      r0,r6
;;;1297   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000042  bd70              POP      {r4-r6,pc}
;;;1298   
                          ENDP

                  |L34.68|
                          DCD      xSuspendedTaskList
                  |L34.72|
                          DCD      xPendingReadyList

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2299   
;;;2300   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;2301   {
000002  4606              MOV      r6,r0
;;;2302   TCB_t *pxUnblockedTCB;
;;;2303   BaseType_t xReturn;
;;;2304   
;;;2305   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;2306   	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
;;;2307   
;;;2308   	/* The event list is sorted in priority order, so we can remove the
;;;2309   	first in the list, remove the TCB from the delayed list, and add
;;;2310   	it to the ready list.
;;;2311   
;;;2312   	If an event is for a queue that is locked then this function will never
;;;2313   	get called - the lock count on the queue will get modified instead.  This
;;;2314   	means we can always expect exclusive access to the event list here.
;;;2315   
;;;2316   	This function assumes that a check has already been made to ensure that
;;;2317   	pxEventList is not empty. */
;;;2318   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;2319   	configASSERT( pxUnblockedTCB );
000008  b91c              CBNZ     r4,|L35.18|
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  bf00              NOP      
                  |L35.16|
000010  e7fe              B        |L35.16|
                  |L35.18|
;;;2320   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000012  f1040018          ADD      r0,r4,#0x18
000016  f7fffffe          BL       uxListRemove
;;;2321   
;;;2322   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00001a  4815              LDR      r0,|L35.112|
00001c  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00001e  b9a0              CBNZ     r0,|L35.74|
;;;2323   	{
;;;2324   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000020  1d20              ADDS     r0,r4,#4
000022  f7fffffe          BL       uxListRemove
;;;2325   		prvAddTaskToReadyList( pxUnblockedTCB );
000026  4913              LDR      r1,|L35.116|
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00002c  4288              CMP      r0,r1
00002e  d902              BLS      |L35.54|
000030  4910              LDR      r1,|L35.116|
000032  6ae0              LDR      r0,[r4,#0x2c]
000034  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L35.54|
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  eb010181          ADD      r1,r1,r1,LSL #2
00003c  4a0e              LDR      r2,|L35.120|
00003e  eb020081          ADD      r0,r2,r1,LSL #2
000042  1d21              ADDS     r1,r4,#4
000044  f7fffffe          BL       vListInsertEnd
000048  e004              B        |L35.84|
                  |L35.74|
;;;2326   	}
;;;2327   	else
;;;2328   	{
;;;2329   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2330   		pending until the scheduler is resumed. */
;;;2331   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00004a  f1040118          ADD      r1,r4,#0x18
00004e  480b              LDR      r0,|L35.124|
000050  f7fffffe          BL       vListInsertEnd
                  |L35.84|
;;;2332   	}
;;;2333   
;;;2334   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000054  490a              LDR      r1,|L35.128|
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00005a  6ac9              LDR      r1,[r1,#0x2c]
00005c  4288              CMP      r0,r1
00005e  d904              BLS      |L35.106|
;;;2335   	{
;;;2336   		/* Return true if the task removed from the event list has
;;;2337   		a higher priority than the calling task.  This allows
;;;2338   		the calling task to know if it should force a context
;;;2339   		switch now. */
;;;2340   		xReturn = pdTRUE;
000060  2501              MOVS     r5,#1
;;;2341   
;;;2342   		/* Mark that a yield is pending in case the user is not using the
;;;2343   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2344   		xYieldPending = pdTRUE;
000062  2001              MOVS     r0,#1
000064  4907              LDR      r1,|L35.132|
000066  6008              STR      r0,[r1,#0]  ; xYieldPending
000068  e000              B        |L35.108|
                  |L35.106|
;;;2345   	}
;;;2346   	else
;;;2347   	{
;;;2348   		xReturn = pdFALSE;
00006a  2500              MOVS     r5,#0
                  |L35.108|
;;;2349   	}
;;;2350   
;;;2351   	return xReturn;
00006c  4628              MOV      r0,r5
;;;2352   }
00006e  bd70              POP      {r4-r6,pc}
;;;2353   /*-----------------------------------------------------------*/
                          ENDP

                  |L35.112|
                          DCD      uxSchedulerSuspended
                  |L35.116|
                          DCD      uxTopReadyPriority
                  |L35.120|
                          DCD      pxReadyTasksLists
                  |L35.124|
                          DCD      xPendingReadyList
                  |L35.128|
                          DCD      pxCurrentTCB
                  |L35.132|
                          DCD      xYieldPending

                          AREA ||i.xTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromUnorderedEventList PROC
;;;2354   
;;;2355   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2356   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;2357   TCB_t *pxUnblockedTCB;
;;;2358   BaseType_t xReturn;
;;;2359   
;;;2360   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;2361   	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
;;;2362   
;;;2363   	/* Store the new item value in the event list. */
;;;2364   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000008  f0474000          ORR      r0,r7,#0x80000000
00000c  6028              STR      r0,[r5,#0]
;;;2365   
;;;2366   	/* Remove the TCB from the delayed list, and add it to the ready list. */
;;;2367   
;;;2368   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
00000e  68ec              LDR      r4,[r5,#0xc]
;;;2369   	configASSERT( pxUnblockedTCB );
000010  b91c              CBNZ     r4,|L36.26|
000012  f7fffffe          BL       ulPortSetInterruptMask
000016  bf00              NOP      
                  |L36.24|
000018  e7fe              B        |L36.24|
                  |L36.26|
;;;2370   	( void ) uxListRemove( pxEventListItem );
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       uxListRemove
;;;2371   
;;;2372   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000020  4815              LDR      r0,|L36.120|
000022  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000024  b9a0              CBNZ     r0,|L36.80|
;;;2373   	{
;;;2374   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       uxListRemove
;;;2375   		prvAddTaskToReadyList( pxUnblockedTCB );
00002c  4913              LDR      r1,|L36.124|
00002e  6ae0              LDR      r0,[r4,#0x2c]
000030  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000032  4288              CMP      r0,r1
000034  d902              BLS      |L36.60|
000036  4911              LDR      r1,|L36.124|
000038  6ae0              LDR      r0,[r4,#0x2c]
00003a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L36.60|
00003c  6ae1              LDR      r1,[r4,#0x2c]
00003e  eb010181          ADD      r1,r1,r1,LSL #2
000042  4a0f              LDR      r2,|L36.128|
000044  eb020081          ADD      r0,r2,r1,LSL #2
000048  1d21              ADDS     r1,r4,#4
00004a  f7fffffe          BL       vListInsertEnd
00004e  e003              B        |L36.88|
                  |L36.80|
;;;2376   	}
;;;2377   	else
;;;2378   	{
;;;2379   		/* Cannot access the delayed or ready lists, so will hold this task
;;;2380   		pending until the scheduler is resumed. */
;;;2381   		vListInsertEnd( &( xPendingReadyList ), pxEventListItem );
000050  4629              MOV      r1,r5
000052  480c              LDR      r0,|L36.132|
000054  f7fffffe          BL       vListInsertEnd
                  |L36.88|
;;;2382   	}
;;;2383   
;;;2384   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000058  490b              LDR      r1,|L36.136|
00005a  6ae0              LDR      r0,[r4,#0x2c]
00005c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00005e  6ac9              LDR      r1,[r1,#0x2c]
000060  4288              CMP      r0,r1
000062  d904              BLS      |L36.110|
;;;2385   	{
;;;2386   		/* Return true if the task removed from the event list has
;;;2387   		a higher priority than the calling task.  This allows
;;;2388   		the calling task to know if it should force a context
;;;2389   		switch now. */
;;;2390   		xReturn = pdTRUE;
000064  2601              MOVS     r6,#1
;;;2391   
;;;2392   		/* Mark that a yield is pending in case the user is not using the
;;;2393   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2394   		xYieldPending = pdTRUE;
000066  2001              MOVS     r0,#1
000068  4908              LDR      r1,|L36.140|
00006a  6008              STR      r0,[r1,#0]  ; xYieldPending
00006c  e000              B        |L36.112|
                  |L36.110|
;;;2395   	}
;;;2396   	else
;;;2397   	{
;;;2398   		xReturn = pdFALSE;
00006e  2600              MOVS     r6,#0
                  |L36.112|
;;;2399   	}
;;;2400   
;;;2401   	return xReturn;
000070  4630              MOV      r0,r6
;;;2402   }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;2403   /*-----------------------------------------------------------*/
                          ENDP

000076  0000              DCW      0x0000
                  |L36.120|
                          DCD      uxSchedulerSuspended
                  |L36.124|
                          DCD      uxTopReadyPriority
                  |L36.128|
                          DCD      pxReadyTasksLists
                  |L36.132|
                          DCD      xPendingReadyList
                  |L36.136|
                          DCD      pxCurrentTCB
                  |L36.140|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;1551   
;;;1552   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;1553   {
;;;1554   TCB_t *pxTCB;
;;;1555   BaseType_t xAlreadyYielded = pdFALSE;
000002  2500              MOVS     r5,#0
;;;1556   
;;;1557   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1558   	previous call to vTaskSuspendAll(). */
;;;1559   	configASSERT( uxSchedulerSuspended );
000004  4830              LDR      r0,|L37.200|
000006  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000008  b918              CBNZ     r0,|L37.18|
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  bf00              NOP      
                  |L37.16|
000010  e7fe              B        |L37.16|
                  |L37.18|
;;;1560   
;;;1561   	/* It is possible that an ISR caused a task to be removed from an event
;;;1562   	list while the scheduler was suspended.  If this was the case then the
;;;1563   	removed task will have been added to the xPendingReadyList.  Once the
;;;1564   	scheduler has been resumed it is safe to move all the pending ready
;;;1565   	tasks from this list into their appropriate ready list. */
;;;1566   	taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1567   	{
;;;1568   		--uxSchedulerSuspended;
000016  482c              LDR      r0,|L37.200|
000018  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00001a  1e40              SUBS     r0,r0,#1
00001c  492a              LDR      r1,|L37.200|
00001e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1569   
;;;1570   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000024  2800              CMP      r0,#0
000026  d14a              BNE      |L37.190|
;;;1571   		{
;;;1572   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000028  4828              LDR      r0,|L37.204|
00002a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00002c  2800              CMP      r0,#0
00002e  d046              BEQ      |L37.190|
;;;1573   			{
;;;1574   				/* Move any readied tasks from the pending list into the
;;;1575   				appropriate ready list. */
;;;1576   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000030  e023              B        |L37.122|
                  |L37.50|
;;;1577   				{
;;;1578   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000032  4827              LDR      r0,|L37.208|
000034  68c0              LDR      r0,[r0,#0xc]
000036  68c4              LDR      r4,[r0,#0xc]
;;;1579   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000038  f1040018          ADD      r0,r4,#0x18
00003c  f7fffffe          BL       uxListRemove
;;;1580   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000040  1d20              ADDS     r0,r4,#4
000042  f7fffffe          BL       uxListRemove
;;;1581   					prvAddTaskToReadyList( pxTCB );
000046  4923              LDR      r1,|L37.212|
000048  6ae0              LDR      r0,[r4,#0x2c]
00004a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00004c  4288              CMP      r0,r1
00004e  d902              BLS      |L37.86|
000050  4920              LDR      r1,|L37.212|
000052  6ae0              LDR      r0,[r4,#0x2c]
000054  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L37.86|
000056  6ae1              LDR      r1,[r4,#0x2c]
000058  eb010181          ADD      r1,r1,r1,LSL #2
00005c  4a1e              LDR      r2,|L37.216|
00005e  eb020081          ADD      r0,r2,r1,LSL #2
000062  1d21              ADDS     r1,r4,#4
000064  f7fffffe          BL       vListInsertEnd
;;;1582   
;;;1583   					/* If we have moved a task that has a priority higher than
;;;1584   					the current task then we should yield. */
;;;1585   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000068  491c              LDR      r1,|L37.220|
00006a  6ae0              LDR      r0,[r4,#0x2c]
00006c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00006e  6ac9              LDR      r1,[r1,#0x2c]
000070  4288              CMP      r0,r1
000072  d302              BCC      |L37.122|
;;;1586   					{
;;;1587   						xYieldPending = pdTRUE;
000074  2001              MOVS     r0,#1
000076  491a              LDR      r1,|L37.224|
000078  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L37.122|
00007a  4815              LDR      r0,|L37.208|
00007c  6800              LDR      r0,[r0,#0]            ;1576  ; xPendingReadyList
00007e  b908              CBNZ     r0,|L37.132|
000080  2001              MOVS     r0,#1                 ;1576
000082  e000              B        |L37.134|
                  |L37.132|
000084  2000              MOVS     r0,#0                 ;1576
                  |L37.134|
000086  2800              CMP      r0,#0                 ;1576
000088  d0d3              BEQ      |L37.50|
;;;1588   					}
;;;1589   					else
;;;1590   					{
;;;1591   						mtCOVERAGE_TEST_MARKER();
;;;1592   					}
;;;1593   				}
;;;1594   
;;;1595   				/* If any ticks occurred while the scheduler was suspended then
;;;1596   				they should be processed now.  This ensures the tick count does
;;;1597   				not	slip, and that any delayed tasks are resumed at the correct
;;;1598   				time. */
;;;1599   				if( uxPendedTicks > ( UBaseType_t ) 0U )
00008a  4816              LDR      r0,|L37.228|
00008c  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
00008e  b178              CBZ      r0,|L37.176|
;;;1600   				{
;;;1601   					while( uxPendedTicks > ( UBaseType_t ) 0U )
000090  e00a              B        |L37.168|
                  |L37.146|
;;;1602   					{
;;;1603   						if( xTaskIncrementTick() != pdFALSE )
000092  f7fffffe          BL       xTaskIncrementTick
000096  b110              CBZ      r0,|L37.158|
;;;1604   						{
;;;1605   							xYieldPending = pdTRUE;
000098  2001              MOVS     r0,#1
00009a  4911              LDR      r1,|L37.224|
00009c  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L37.158|
;;;1606   						}
;;;1607   						else
;;;1608   						{
;;;1609   							mtCOVERAGE_TEST_MARKER();
;;;1610   						}
;;;1611   						--uxPendedTicks;
00009e  4811              LDR      r0,|L37.228|
0000a0  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0000a2  1e40              SUBS     r0,r0,#1
0000a4  490f              LDR      r1,|L37.228|
0000a6  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L37.168|
0000a8  480e              LDR      r0,|L37.228|
0000aa  6800              LDR      r0,[r0,#0]            ;1601  ; uxPendedTicks
0000ac  2800              CMP      r0,#0                 ;1601
0000ae  d1f0              BNE      |L37.146|
                  |L37.176|
;;;1612   					}
;;;1613   				}
;;;1614   				else
;;;1615   				{
;;;1616   					mtCOVERAGE_TEST_MARKER();
;;;1617   				}
;;;1618   
;;;1619   				if( xYieldPending == pdTRUE )
0000b0  480b              LDR      r0,|L37.224|
0000b2  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000b4  2801              CMP      r0,#1
0000b6  d102              BNE      |L37.190|
;;;1620   				{
;;;1621   					#if( configUSE_PREEMPTION != 0 )
;;;1622   					{
;;;1623   						xAlreadyYielded = pdTRUE;
0000b8  2501              MOVS     r5,#1
;;;1624   					}
;;;1625   					#endif
;;;1626   					taskYIELD_IF_USING_PREEMPTION();
0000ba  f7fffffe          BL       vPortYield
                  |L37.190|
;;;1627   				}
;;;1628   				else
;;;1629   				{
;;;1630   					mtCOVERAGE_TEST_MARKER();
;;;1631   				}
;;;1632   			}
;;;1633   		}
;;;1634   		else
;;;1635   		{
;;;1636   			mtCOVERAGE_TEST_MARKER();
;;;1637   		}
;;;1638   	}
;;;1639   	taskEXIT_CRITICAL();
0000be  f7fffffe          BL       vPortExitCritical
;;;1640   
;;;1641   	return xAlreadyYielded;
0000c2  4628              MOV      r0,r5
;;;1642   }
0000c4  bd70              POP      {r4-r6,pc}
;;;1643   /*-----------------------------------------------------------*/
                          ENDP

0000c6  0000              DCW      0x0000
                  |L37.200|
                          DCD      uxSchedulerSuspended
                  |L37.204|
                          DCD      uxCurrentNumberOfTasks
                  |L37.208|
                          DCD      xPendingReadyList
                  |L37.212|
                          DCD      uxTopReadyPriority
                  |L37.216|
                          DCD      pxReadyTasksLists
                  |L37.220|
                          DCD      pxCurrentTCB
                  |L37.224|
                          DCD      xYieldPending
                  |L37.228|
                          DCD      uxPendedTicks

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1357   
;;;1358   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1359   	{
000004  4605              MOV      r5,r0
;;;1360   	BaseType_t xYieldRequired = pdFALSE;
000006  2600              MOVS     r6,#0
;;;1361   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000008  462c              MOV      r4,r5
;;;1362   	UBaseType_t uxSavedInterruptStatus;
;;;1363   
;;;1364   		configASSERT( xTaskToResume );
00000a  b91d              CBNZ     r5,|L38.20|
00000c  f7fffffe          BL       ulPortSetInterruptMask
000010  bf00              NOP      
                  |L38.18|
000012  e7fe              B        |L38.18|
                  |L38.20|
;;;1365   
;;;1366   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1367   		maximum	system call (or maximum API call) interrupt priority.
;;;1368   		Interrupts that are	above the maximum system call priority are keep
;;;1369   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1370   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1371   		is defined in FreeRTOSConfig.h then
;;;1372   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1373   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1374   		been assigned a priority above the configured maximum system call
;;;1375   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1376   		from interrupts	that have been assigned a priority at or (logically)
;;;1377   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1378   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1379   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1380   		provided on the following link:
;;;1381   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1382   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000014  f7fffffe          BL       vPortValidateInterruptPriority
;;;1383   
;;;1384   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000018  f7fffffe          BL       ulPortSetInterruptMask
00001c  4607              MOV      r7,r0
;;;1385   		{
;;;1386   			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       xTaskIsTaskSuspended
000024  2801              CMP      r0,#1
000026  d123              BNE      |L38.112|
;;;1387   			{
;;;1388   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1389   
;;;1390   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000028  4814              LDR      r0,|L38.124|
00002a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002c  b9d8              CBNZ     r0,|L38.102|
;;;1391   				{
;;;1392   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00002e  4914              LDR      r1,|L38.128|
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000034  6ac9              LDR      r1,[r1,#0x2c]
000036  4288              CMP      r0,r1
000038  d300              BCC      |L38.60|
;;;1393   					{
;;;1394   						xYieldRequired = pdTRUE;
00003a  2601              MOVS     r6,#1
                  |L38.60|
;;;1395   					}
;;;1396   					else
;;;1397   					{
;;;1398   						mtCOVERAGE_TEST_MARKER();
;;;1399   					}
;;;1400   
;;;1401   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
00003c  1d20              ADDS     r0,r4,#4
00003e  f7fffffe          BL       uxListRemove
;;;1402   					prvAddTaskToReadyList( pxTCB );
000042  4910              LDR      r1,|L38.132|
000044  6ae0              LDR      r0,[r4,#0x2c]
000046  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000048  4288              CMP      r0,r1
00004a  d902              BLS      |L38.82|
00004c  490d              LDR      r1,|L38.132|
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L38.82|
000052  6ae1              LDR      r1,[r4,#0x2c]
000054  eb010181          ADD      r1,r1,r1,LSL #2
000058  4a0b              LDR      r2,|L38.136|
00005a  eb020081          ADD      r0,r2,r1,LSL #2
00005e  1d21              ADDS     r1,r4,#4
000060  f7fffffe          BL       vListInsertEnd
000064  e004              B        |L38.112|
                  |L38.102|
;;;1403   				}
;;;1404   				else
;;;1405   				{
;;;1406   					/* We cannot access the delayed or ready lists, so will hold this
;;;1407   					task pending until the scheduler is resumed, at which point a
;;;1408   					yield will be performed if necessary. */
;;;1409   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000066  f1040118          ADD      r1,r4,#0x18
00006a  4808              LDR      r0,|L38.140|
00006c  f7fffffe          BL       vListInsertEnd
                  |L38.112|
;;;1410   				}
;;;1411   			}
;;;1412   			else
;;;1413   			{
;;;1414   				mtCOVERAGE_TEST_MARKER();
;;;1415   			}
;;;1416   		}
;;;1417   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       vPortClearInterruptMask
;;;1418   
;;;1419   		return xYieldRequired;
000076  4630              MOV      r0,r6
;;;1420   	}
000078  e8bd81f0          POP      {r4-r8,pc}
;;;1421   
                          ENDP

                  |L38.124|
                          DCD      uxSchedulerSuspended
                  |L38.128|
                          DCD      pxCurrentTCB
                  |L38.132|
                          DCD      uxTopReadyPriority
                  |L38.136|
                          DCD      pxReadyTasksLists
                  |L38.140|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff

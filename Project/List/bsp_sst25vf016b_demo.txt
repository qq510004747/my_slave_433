; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\bsp_sst25vf016b_demo.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\bsp_sst25vf016b_demo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\J_LINK_RTT\RTT -I..\User -I..\BSP\BSP -I..\BSP\BSP_InPut -I..\BSP\BSP_OutPut -I..\BSP\BSP_FLASH -I..\BSP\BSP_USART -I..\Libraries\FreeRTOS -I..\Libraries\FreeRTOS\include -I..\Libraries\FreeRTOS\FreeRTOSConfig -I..\Libraries\FreeRTOS\portable\RVDS\ARM_CM3 -I..\BSP\BSP_USART2 -IC:\Users\Administrator\Desktop\FreeRTOS工程摸板V2.0.0\Project\RTE -IF:\keil5-22\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -IF:\keil5-22\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\bsp_sst25vf016b_demo.crf ..\BSP\BSP_FLASH\BSP_SST25VF016B_Demo.c]
                          THUMB

                          AREA ||i.Flash_Demo||, CODE, READONLY, ALIGN=2

                  Flash_Demo PROC
;;;35     *****************************/
;;;36     void Flash_Demo(void)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {	
;;;38     	uint32_t id;
;;;39     	uint32_t uiReadPageNo = 0;
000002  2400              MOVS     r4,#0
;;;40     	Flash_InitHard();	/* 初始化SPI硬件 */
000004  f7fffffe          BL       Flash_InitHard
;;;41     	id = Flash_ReadID();
000008  f7fffffe          BL       Flash_ReadID
00000c  4605              MOV      r5,r0
;;;42     	if (id != SST25VF016B_ID)
00000e  480f              LDR      r0,|L1.76|
000010  4285              CMP      r5,r0
000012  d001              BEQ      |L1.24|
;;;43     	{
;;;44     		/* 没有检测到芯片 */
;;;45     //    SEGGER_RTT_WriteString(0, "没有检测到串行Flash!\r\n");				
;;;46     		while (1);	/* 停机 */
000014  bf00              NOP      
                  |L1.22|
000016  e7fe              B        |L1.22|
                  |L1.24|
;;;47     	}
;;;48     	/* 检测串行Flash OK */
;;;49     //	SEGGER_RTT_printf(0,"检测到串行Flash,ID = %08X\r\n",id);
;;;50     	Flash_ReadTest();		  /* 读串行Flash数据，并打印出来数据内容 */	
000018  f7fffffe          BL       Flash_ReadTest
;;;51     	Flash_WriteTest();		/* 写串行Flash数据，并打印写入速度 */		
00001c  f7fffffe          BL       Flash_WriteTest
;;;52     	Flash_Erase();			  /* 擦除串行Flash数据，实际上就是写入全0xFF */		
000020  f7fffffe          BL       Flash_Erase
;;;53     	Flash_WriteAll(0x55);	/* 擦除串行Flash数据，实际上就是写入全0xFF */	
000024  2055              MOVS     r0,#0x55
000026  f7fffffe          BL       Flash_WriteAll
;;;54     	Flash_WriteAll(0xAA);	/* 擦除串行Flash数据，实际上就是写入全0xFF */
00002a  20aa              MOVS     r0,#0xaa
00002c  f7fffffe          BL       Flash_WriteAll
;;;55     /* 读取前1K */
;;;56     	if (uiReadPageNo > 0)
000030  b104              CBZ      r4,|L1.52|
;;;57     	{
;;;58     		  uiReadPageNo--;
000032  1e64              SUBS     r4,r4,#1
                  |L1.52|
;;;59     	}
;;;60     	Flash_ViewData(uiReadPageNo * 1024);
000034  02a0              LSLS     r0,r4,#10
000036  f7fffffe          BL       Flash_ViewData
;;;61     /* 读取后1K */
;;;62     	if (uiReadPageNo < 2048 - 1)
00003a  f24070ff          MOV      r0,#0x7ff
00003e  4284              CMP      r4,r0
000040  d200              BCS      |L1.68|
;;;63     	{
;;;64     		 uiReadPageNo++;
000042  1c64              ADDS     r4,r4,#1
                  |L1.68|
;;;65     	}
;;;66     	Flash_ViewData(uiReadPageNo * 1024);
000044  02a0              LSLS     r0,r4,#10
000046  f7fffffe          BL       Flash_ViewData
;;;67     }
00004a  bd70              POP      {r4-r6,pc}
;;;68     
                          ENDP

                  |L1.76|
                          DCD      0x00bf2541

                          AREA ||i.Flash_Erase||, CODE, READONLY, ALIGN=1

                  Flash_Erase PROC
;;;147    ***********************/
;;;148    static void Flash_Erase(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150    	Flash_EraseChip();
000002  f7fffffe          BL       Flash_EraseChip
;;;151    }
000006  bd10              POP      {r4,pc}
;;;152    /*******************************
                          ENDP


                          AREA ||i.Flash_ReadTest||, CODE, READONLY, ALIGN=1

                  Flash_ReadTest PROC
;;;74     ********************************/
;;;75     static void Flash_ReadTest(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
000002  f5ad5d80          SUB      sp,sp,#0x1000
;;;77     	uint16_t i;
;;;78     	uint8_t buf[TEST_SIZE];
;;;79     	Flash_ReadBuffer(buf, TEST_ADDR, TEST_SIZE);
000006  f44f5280          MOV      r2,#0x1000
00000a  2100              MOVS     r1,#0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       Flash_ReadBuffer
;;;80     	/* 打印数据 */
;;;81     	for (i = 0; i < TEST_SIZE; i++)
000012  2400              MOVS     r4,#0
000014  e001              B        |L3.26|
                  |L3.22|
000016  1c60              ADDS     r0,r4,#1
000018  b284              UXTH     r4,r0
                  |L3.26|
00001a  f5b45f80          CMP      r4,#0x1000
00001e  dbfa              BLT      |L3.22|
;;;82     	{
;;;83     //		SEGGER_RTT_printf(0,"%02X",buf[i]);
;;;84     		if ((i & 15) == 15)
;;;85     		{
;;;86     //         SEGGER_RTT_WriteString(0, "\r\n");	/* 每行显示8字节数据 */
;;;87     		}		
;;;88     	}
;;;89     }
000020  f50d5d80          ADD      sp,sp,#0x1000
000024  bd10              POP      {r4,pc}
;;;90     
                          ENDP


                          AREA ||i.Flash_ViewData||, CODE, READONLY, ALIGN=1

                  Flash_ViewData PROC
;;;157    ********************************/
;;;158    static void Flash_ViewData(uint32_t _uiAddr)
000000  b530              PUSH     {r4,r5,lr}
;;;159    {
000002  f2ad4d04          SUB      sp,sp,#0x404
000006  4604              MOV      r4,r0
;;;160    	uint16_t i;
;;;161    	uint8_t buf[1024];
;;;162    
;;;163    	Flash_ReadBuffer(buf, _uiAddr,  1024);		/* 读数据 */	
000008  f44f6280          MOV      r2,#0x400
00000c  4621              MOV      r1,r4
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       Flash_ReadBuffer
;;;164    	/* 打印数据 */
;;;165    	for (i = 0; i < 1024; i++)
000014  2500              MOVS     r5,#0
000016  e001              B        |L4.28|
                  |L4.24|
000018  1c68              ADDS     r0,r5,#1
00001a  b285              UXTH     r5,r0
                  |L4.28|
00001c  f5b56f80          CMP      r5,#0x400
000020  dbfa              BLT      |L4.24|
;;;166    	{
;;;167    //		printf(" %02X", buf[i]);	
;;;168    		if ((i & 15) == 15)
;;;169    		{
;;;170    //			printf("\r\n");	/* 每行显示8字节数据 */
;;;171    		}		
;;;172    	}
;;;173    }
000022  f20d4d04          ADD      sp,sp,#0x404
000026  bd30              POP      {r4,r5,pc}
;;;174    /********** (C) COPYRIGHT DIY嵌入式开发工作室 *****END OF FILE****************/
                          ENDP


                          AREA ||i.Flash_WriteAll||, CODE, READONLY, ALIGN=1

                  Flash_WriteAll PROC
;;;121    *********************************************/
;;;122    static void Flash_WriteAll(uint8_t _ch)
000000  b530              PUSH     {r4,r5,lr}
;;;123    {
000002  b081              SUB      sp,sp,#4
000004  f5ad5d80          SUB      sp,sp,#0x1000
000008  4605              MOV      r5,r0
;;;124    	uint16_t i;
;;;125    	uint8_t buf[Flash_PAGE_SIZE];
;;;126    	/* 填充测试缓冲区 */
;;;127    	for (i = 0; i < TEST_SIZE; i++)
00000a  2400              MOVS     r4,#0
00000c  e003              B        |L5.22|
                  |L5.14|
;;;128    	{		
;;;129    		buf[i] = _ch;
00000e  a801              ADD      r0,sp,#4
000010  5505              STRB     r5,[r0,r4]
000012  1c60              ADDS     r0,r4,#1              ;127
000014  b284              UXTH     r4,r0                 ;127
                  |L5.22|
000016  f5b45f80          CMP      r4,#0x1000            ;127
00001a  dbf8              BLT      |L5.14|
;;;130    	}	
;;;131    	/* 写EEPROM, 起始地址 = 0，数据长度为 256 */
;;;132    	for (i = 0; i < Flash_TOTAL_SIZE / Flash_PAGE_SIZE; i++)
00001c  2400              MOVS     r4,#0
00001e  e00c              B        |L5.58|
                  |L5.32|
;;;133    	{
;;;134    		if (Flash_WriteBuffer(buf, i * Flash_PAGE_SIZE, Flash_PAGE_SIZE) == 0)
000020  0321              LSLS     r1,r4,#12
000022  f44f5280          MOV      r2,#0x1000
000026  a801              ADD      r0,sp,#4
000028  f7fffffe          BL       Flash_WriteBuffer
00002c  b918              CBNZ     r0,|L5.54|
                  |L5.46|
;;;135    		{
;;;136    //			printf("写串行Flash出错！\r\n");
;;;137    			return;
;;;138    		}
;;;139    	}
;;;140    }
00002e  b001              ADD      sp,sp,#4
000030  f50d5d80          ADD      sp,sp,#0x1000
000034  bd30              POP      {r4,r5,pc}
                  |L5.54|
000036  1c60              ADDS     r0,r4,#1              ;132
000038  b284              UXTH     r4,r0                 ;132
                  |L5.58|
00003a  f5b47f00          CMP      r4,#0x200             ;132
00003e  dbef              BLT      |L5.32|
000040  bf00              NOP      
000042  e7f4              B        |L5.46|
;;;141    
                          ENDP


                          AREA ||i.Flash_WriteTest||, CODE, READONLY, ALIGN=1

                  Flash_WriteTest PROC
;;;96     *******************************************/
;;;97     static void Flash_WriteTest(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
000002  f5ad5d80          SUB      sp,sp,#0x1000
;;;99     	uint16_t i;
;;;100    	uint8_t buf[TEST_SIZE];
;;;101    	/* 填充测试缓冲区 */
;;;102    	for (i = 0; i < TEST_SIZE; i++)
000006  2400              MOVS     r4,#0
000008  e004              B        |L6.20|
                  |L6.10|
;;;103    	{		
;;;104    		buf[i] = i;
00000a  b2e0              UXTB     r0,r4
00000c  f80d0004          STRB     r0,[sp,r4]
000010  1c60              ADDS     r0,r4,#1              ;102
000012  b284              UXTH     r4,r0                 ;102
                  |L6.20|
000014  f5b45f80          CMP      r4,#0x1000            ;102
000018  dbf7              BLT      |L6.10|
;;;105    	}
;;;106    	if (Flash_WriteBuffer(buf, TEST_ADDR, TEST_SIZE) == 0)
00001a  f44f5280          MOV      r2,#0x1000
00001e  2100              MOVS     r1,#0
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       Flash_WriteBuffer
000026  b910              CBNZ     r0,|L6.46|
                  |L6.40|
;;;107    	{
;;;108    //		printf("写串行Flash出错！\r\n");
;;;109    		return;
;;;110    	}
;;;111    	else
;;;112    	{
;;;113    //		printf("写串行Flash成功！\r\n");
;;;114    	}
;;;115    }
000028  f50d5d80          ADD      sp,sp,#0x1000
00002c  bd10              POP      {r4,pc}
                  |L6.46|
00002e  bf00              NOP      
000030  e7fa              B        |L6.40|
;;;116    /********************************************
                          ENDP

